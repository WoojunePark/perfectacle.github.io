<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>오늘도 끄적끄적</title>
  
  <subtitle>Back-end Engineer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://perfectacle.github.io/"/>
  <updated>2019-08-22T23:16:36.040Z</updated>
  <id>https://perfectacle.github.io/</id>
  
  <author>
    <name>양권성</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>야놀자를 떠나며... (feat. 레저큐)</title>
    <link href="https://perfectacle.github.io/2019/08/23/exit-yanolja-feat-leisureq/"/>
    <id>https://perfectacle.github.io/2019/08/23/exit-yanolja-feat-leisureq/</id>
    <published>2019-08-22T23:16:36.000Z</published>
    <updated>2019-08-22T23:16:36.040Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/exit-yanolja-feat-leisureq/thumb.gif" alt=""><br>오늘은 야놀자 서류상 <strong>퇴사일</strong>이다. (오늘까지 남은 연차를 사용했다.)<br>총 세 번의 이직 시도 끝에 성공할 수 있었다.<br>여태까지 신입으로만 이직(프론트엔드 신입(5개월 재직) -&gt; 백엔드 중고 신입)했고, 지인 추천을 통해서만 면접을 봤는데<br>이번 이직에서는 지인 추천도 있었지만, 내 힘으로 스스로 지원해서 합격까지 한 케이스도 많아서 굉장히 뿌듯한 경험이었다.<br>나와 같은 2~3년 차 주니어 분에게 도움이 됐으면 하는 바람, 개인적으로 회고를 하고 싶어서 정리를 해봤다.  </p><a id="more"></a><h2 id="왜-퇴사를-결심했나"><a href="#왜-퇴사를-결심했나" class="headerlink" title="왜 퇴사를 결심했나"></a>왜 퇴사를 결심했나</h2><ol><li>가장 큰 요인은 <strong>개발에 집중하지 못하는 환경</strong>이었다.<br>레저큐에서 야놀자로 조직이 이동되면서(완전히 퇴사 후 입사 처리되었다.) 레저큐의 인프라 쪽을 한 번 쭉 털고 가야하는 이슈가 있었다.<br>평상시에 인프라에 관심이 많았던 내가 해당 업무를 맡게 되었고, 끝까지 털지 못하고 퇴사하게 되었다.<br>개발이 하고 싶었지만, 점점 인프라 쪽 업무의 비중이 높아지면서 내 정체성을 의심하기 시작했다.<br>나는 서버 개발자인가? 아니면 시스템 엔지니어인가…?<br>물론 인프라 쪽도 알면 좋지만, 아직까지는 개발이 더 <strong>마렵다</strong>는 생각이 들었다.</li><li><strong>연봉</strong><br>대부분의 이직 사유 중 하나일 것이다.<br>물론 나보다 열악한 근무 환경 속에서도 안 좋은 대우를 받으시는 분들도 있을 거다.<br>하지만 사람의 욕심은 끝이 없어서 자꾸만 위를 올려다 보게 되었다.<br>네임밸류 기업에서 시작을 한 게 아니기 때문에 첫 시작 자체가 높지 않았던 탓도 있었던 것 같다. (그렇다고 그렇게 낮은 편도 아니었다.)</li></ol><p>그 외에도 있긴 하지만, 너무 개인적인 일이기도 하고 크게 공감을 얻을만한 내용이 아니어서 적지 않았다.</p><h2 id="세-번의-이직-시도"><a href="#세-번의-이직-시도" class="headerlink" title="세 번의 이직 시도"></a>세 번의 이직 시도</h2><p>작년에 두 번, 올해 한 번의 이직을 시도했다.<br>공교롭게도 이직 시도할 쯤이 연봉 협상 시기와 비슷한 경우가 많았다.<br>그만큼 연봉 인상에 대한 갈증도 어느정도 있었던 것 같다.</p><h3 id="첫-번째-시도-오피지지"><a href="#첫-번째-시도-오피지지" class="headerlink" title="첫 번째 시도, 오피지지"></a>첫 번째 시도, 오피지지</h3><p><a href="https://www.op.gg/" rel="external nofollow noopener noreferrer" target="_blank">오피지지</a>는 게임 랭킹/플레이 분석 등등을 해주는 서비스를 제공해주는 회사이다.<br>우리나라 보다 외국 유저가 많은만큼 글로벌 경험도 해볼 수 있고, 또 트래픽도 굉장히 많은 걸로 알고 있다.<br>면접을 보러 건물 앞을 서성이자 프로게이머 면접 왔냐고 물어봤다.<br>프로게이머 구단을 꾸리고 있을 정도로 게임에 대한 열정을 엿볼 수 있었다.  </p><p>우선 면접 중에 가장 신선했던 것은 직접 코드리뷰를 한다는 점이다.<br>물론 코드를 제출하는 게 아니라 회사 노트북을 들고 가서 이슈가 없을 부분 중에서 그나마 잘 짰다고 생각한 부분을 리뷰했다.<br>회사 외부 사람에게 코드리뷰를 한 적은 처음이었고, 내 코드에 어떤 개선사항들이 있는지, 앞으로 어떻게 해결해나가야할지 등등에 대해서 피드백을 알 수 있어서 좋았다.<br>그 이후에는 기술적인 질문들을 받았는데 이 때 제대로 대답을 하지 못했다.<br>단골 질문들도 나왔는데 평상시 그런 내용들은 물라도 <strong>일하는데 문제가 없었던 터</strong>라 공부를 미루고 있었다.<br>또한 <strong>면접 전에 반짝 공부해서 가기에는 회사에게 미안했다.</strong><br>내 원래 모습이 아닌 거짓된 모습을 보여주는 것 같기 때문에 회사에게도, 나에게도 좋지 않다고 판단을 했다.<br>그 이후에는 인사? 면접까지 바로 이루어졌다. (이건 뭐 다른 기업들이랑 크게 다르지 않았던 것 같아서 적을만한 게 없다.)<br>그리고 면접이 끝나고 나서도 해당 질문들을 정리하고 공부했어야 했는데 게으르게도 정리하지 않았다.  </p><p>결과는 <strong>불합격</strong>이었다.<br>내 추측에 의하면 내가 답변을 제대로 못했기 때문이라기 보다는 성향이 맞지 않았던 것 같았다.<br>당시에는 <del>빨대를 꼽을</del>나를 빠르게 성장시켜 줄 사수나 환경에 대해 갈망하고 있었다.<br>시간이 흘렀지만 나는 그대로인 것 같았다.<br>그러다보니 나를 바꿀 생각을 안 하고, 주변 환경을 바꿔서 쉽게 쉽게 가려고 했던 것 같다.<br>면접 때도 그런 태도를 계속 내비췄던 것 같은데 당시 오피지지는 그렇게 막 챙겨주고 가르쳐 줄 상황이 아니었기 때문이 아닐까 생각을 한다.</p><h3 id="두-번째-시도-쿠팡"><a href="#두-번째-시도-쿠팡" class="headerlink" title="두 번째 시도, 쿠팡"></a>두 번째 시도, 쿠팡</h3><p><a href="https://www.coupang.com/" rel="external nofollow noopener noreferrer" target="_blank">쿠팡</a>은 이커머스 사업을 하는 회사이다.<br>프론트엔드 스터디 강의를 해주신 두 분께서 쿠팡 출신이기 때문에 쿠팡에 대해 굉장히 기대가 크고 벽도 높다고 생각했다.<br>경력이 적었던 터라 내부 추천으로 들어가기에는 무리가 있어보였고 신입으로 지원하게 되었다.</p><p>운 좋게 서류를 통과하고 코딩 테스트를 볼 차례가 되었다.<br><a href="http://tech.kakao.com/2018/09/21/kakao-blind-recruitment-for2019-round-1/" rel="external nofollow noopener noreferrer" target="_blank">카카오 블라인드 채용 코딩 테스트</a> 문제를 봤을 때 이걸 다 푼 사람이 있나 싶을 정도였다.<br>그 중에 1/5도 못 맞출만큼 평상시에 알고리듬에 관한 공부를 하지 않았다.<br>그러다보니 거의 벼락치기 수준으로 코딩 테스트를 준비했다.  </p><p>결과는 <strong>불합격</strong>이었다.<br>개인적인 기준에는 너무 어려웠다.<br>초반 1~2 문제는 시간이 좀 걸렸고, 풀었던 문제들도 나이스하지 못하게 풀었다.<br>뒤로 가면 갈 수록 도저히 실무에서 겪어보지 못한 복잡성이었다.<br>지금 다시 풀라고 해도 못 붙는다.  </p><p>이렇게 나에게 코딩 테스트는 넘사벽 급의 존재가 되었다.<br>이 때부터라도 알고리듬 공부를 열심히 했어야했는데 또 게으름 탓에 알고리듬 공부도 딱히 하지 않으며 시간만 흘러갔다.</p><h3 id="세-번째-시도"><a href="#세-번째-시도" class="headerlink" title="세 번째 시도"></a>세 번째 시도</h3><p>세 번째 시도부터는 올해에 시도하기 시작했다.<br>그리고 처음으로 공격적으로 동시에 여러 곳을 면접봤다.<br>일주일에 면접을 5번 본 적도 있고, 심지어 오전에 한 개, 오후에 한 개 이렇게 본 날도 있었다.<br>떨어지기도 많이 떨어졌고, 붙기도 많이 붙었다.  </p><h4 id="탈락한-기업"><a href="#탈락한-기업" class="headerlink" title="탈락한 기업"></a>탈락한 기업</h4><ol><li>스노우<br><a href="https://snowcorp.com/" rel="external nofollow noopener noreferrer" target="_blank">스노우</a>는 스마트폰의 카메라 필터나 영상과 관련된 앱을 만드는 회사이다.<br><del>비개발자인 친구들도 많이 사용하는 앱이라 스노우 지원했다고 자랑도 했다.</del><br>하지만 서류부터 <strong>광탈</strong>했다.  </li><li>카카오뱅크<br><a href="https://www.kakaobank.com/" rel="external nofollow noopener noreferrer" target="_blank">카카오뱅크</a>는 국내 최초로 온라인 100% 은행이다. (오프라인 은행 지점이 없다.)<br>평상시에 크게 사용하진 않지만(역시 사람은 익숙한 것을 바꾸기가 정말 힘들다.) 그래도 간편함과 혁신적인 부분에 있어서는 정말 좋게 생각하고 있었다.<br>스노우의 전례가 있기 때문에 이번엔 친구들에게 설레발을 떨지 않았다.<br>서류를 열심히 작성해서 제출했지만 역시나 서류에서 <strong>탈락</strong>했다.<br>지원동기를 적어내는 칸에 <strong>거짓말을 치지 않는 이상 나를 어필하는 능력이 부족</strong>했다.<br>금융 쪽은 아예 경험이 없기 때문에 뭐라 적을 내용이 없었는데 그런 경험이 없기 때문에 떨어졌던 게 아닐까 싶다.</li><li>카카오<br><a href="https://www.kakaocorp.com/" rel="external nofollow noopener noreferrer" target="_blank">카카오</a>는 카카오톡이라는 메신저로 성장하여 다음 포털까지 인수한 회사이다.<br>월간 카카오를 통해 도전했고, 한 달에 한 번씩 볼 수 있기 때문에 크게 부담 가지지 않고 지원했다.<br>서류까지는 어찌저찌 통과했지만, 역시나 코딩 테스트에서 탈락했다.<br>&nbsp;<br>하지만 카카오는 나에게 용기를 불어넣어준 아주 고마운 회사이다.<br>회사마다, 팀마다 다르겠지만 내가 여태까지 봐왔던 코딩 테스트(카카오 블라인드 채용, 쿠팡 신입)와 비교해보면 난이도가 너무 낮았다. (그렇다고 발로 풀어도 될 정도까진 아니고…)<br>아마도 신입은 경력이 없다보니 증명할 게 코딩 테스트 말고는 없어서 좀 빡세게 냈던 게 아닐까 싶다.<br>따라서 경력은 프로젝트 이력 등등을 통해 증명할 수 있으니 다소 코딩 테스트의 비중을 좀 낮춘 게 아닐까 싶다.<br>실제로 내가 본 다른 기업의 코딩 테스트는 전부 카카오의 코딩 테스트와 비슷한 수준이었다.</li></ol><h4 id="네오펙트"><a href="#네오펙트" class="headerlink" title="네오펙트"></a>네오펙트</h4><p><a href="https://www.neofect.com/" rel="external nofollow noopener noreferrer" target="_blank">네오펙트</a>는 의료 재활 솔루션 회사이다.<br>생소한 도메인이기도 하고, 서버 개발자가 뭐 할일이 크게 있나… 싶을 정도였는데<br>의료 재활 기기와 앱을 연동해서 재활을 쉽고 재미있게 도와주는데 이 때 앱에서 사용할 API 서버를 개발하는 업무의 담당자를 뽑고 있었다.</p><p>서류까지는 무사통과 되고, 그 이후에 코딩 테스트를 봤는데 신기하게 <strong>SQL, 자바스크립트(DOM 지식이 필요한)</strong> 문제들이 나왔다.<br>솔직히 다른 코딩 테스트들은 어떤 문제는 ‘이 회사는 실무에서 이정도 복잡성을 다루면서 이런 문제를 내나?’ 싶은 수준의 문제도 많았는데 네오펙트는 참 실용적인 문제들만 나와서 좋았다.<br>(그만큼 내가 준비가 덜 됐기 때문에 그렇게 느꼈을지도 모르겠다.)  </p><p>코딩 테스트 통과 후에 주말에 두 명의 면접관과 함께 행아웃으로 라이브 코딩 면접도 보았다. (손코딩은 아니고 IDE를 사용해서 풀었다.)<br>라이브 코딩이기 때문에 구글링을 하면 안 되는 줄 알고 초반에 좀 뻘뻘대다가 해도 된다는 소리를 듣고 정말 실용적으로 면접보는 것 같아서 좋았다.<br>문제 자체는 Easy 레벨이었는데 초반에 너무 성급하게 문제를 푸는 바람에 이해를 잘못해서 시간을 정말 많이 날렸다.<br>어찌저찌 문제를 풀고 코드를 제출했다.<br>너무 덜렁대는 성격을 보여준 것 같아 불안했는데 어찌저찌 통과했다.</p><p>마지막으로 기술 면접과 인사 면접을 하루에 몰아서 보았다.<br>오피지지 이후로 첫 번째 기술 면접이기 때문에 오피지지에서 대답하지 못했던 부분들은 많이 공부해둔 상태였다. (실무를 통해 경험하다보니 자연스레 공부한 내용들도 있었고…)<br>하지만 자바 관련된 질문들, 스프링 관련된 질문들은 전혀 하지 않았다.<br>오로지 내가 진행한 프로젝트 이력에 대해서만 물어봤다. (그 이외의 질문도 좀 있긴 했지만)<br>이후에 면접관에게 왜 그런 내용은 물어보지 않았냐고 여쭙자 ‘자신들이 질문한 것만으로 어느 정도 검증이 되기도 하고, 그런 걸 물어봐도 뻔한 대답이 돌아오기 때문에 제대로 검증이 안되기 때문’이라고 말했던 것 같다. (정확히는 기억이…)</p><p>결과는 <strong>합격</strong>이었다.<br>처음으로 합격한 회사라 기분이 정말 좋았다.<br>하지만 집에 돌아가는 순간 입사하지 않기로 마음 먹었다.<br>거리가 너무 멀기도 하고, 교통편이 좋지 않아서 집에 가면서 마음이 많이 돌아섰다.<br>하지만 굉장히 실용적인 부분만 검증한 것 같아서 굉장히 좋은 면접 경험이었다.</p><h4 id="네이버-파이낸셜-분사-예정"><a href="#네이버-파이낸셜-분사-예정" class="headerlink" title="네이버 파이낸셜(분사 예정)"></a>네이버 파이낸셜(분사 예정)</h4><p><a href="https://pay.naver.com/" rel="external nofollow noopener noreferrer" target="_blank">네이버 파이낸셜</a>은 네이버 페이라는 간편 결제 서비스를 개발하는 핀테크 회사이다. (아직은 네이버 소속)<br>네이버 파이낸셜은 미래에셋에서 5000억을 투자(예정)받을 정도로 미래에 촉망받는 회사이다.<br>나는 간편결제라면 대부분 네이버 페이 밖에 안 쓰고, 굉장히 편리하게 사용하고 있는 서비스이기 때문에 지원했다. (네이버라는 네임밸류도 한 몫 했다.)  </p><p>신기하게 코딩 테스트는 보지 않고 서류를 합격하였다.<br>대신 면접장에서 화이트보드에 손코딩(정확한 문법까지 작성하진 않아도 됨)과 A4 용지에 출력된 문제들을 푸는 걸로 코딩 테스트를 대체했다.<br>내가 경력이 짧다는 이유로 이런 과정도 있었는데 경력이 많은 경우에는 이마저도 스킵하지 않을까 싶었다.<br>1차 면접에서는 역시나 프로젝트 위주의 질문을 많이 받았다.<br>면접이 끝난 후에 선물을 받았는데 2019년이 절반 이상 흘러갔는데 캘린더가 선물에 포함된 건 조금 아쉬웠다.  </p><p>1주가 흐른 후에 합격 메일을 통보 받고, 2차 면접 날짜를 잡았다.<br>2차는 기술 심층 면접이었다.<br>1차에서 물어보지 않았던 부분들에 대해서 질문을 많이 받았다.<br>초반에는 인프라 쪽 질문을 많이 받았고, 면접관 분도 개발자 불러다놓고 너무 인프라 쪽 얘기만 한 것 같다고 말씀하셨다.<br>많은 질문들이 나의 추측으로 밖에 답변할 수 없을 정도로 내 지식이 크게 부족했다.<br>그 때마다 면접관 분들은 정답을 원하는 게 아니라 그냥 알고 있는 그 대로 한 번 얘기해보라고 다독여주셨다.<br>그래서인지 면접이 끝날 때 쯤에는 몸에 산소 공급이 부족한 느낌이 들 정도로 얘기를 많이 했고, 머리에서 김이 나는 것 같았다.  </p><p>또 1주가 흐른 후에 합격 메일을 통보 받고, 마지막 3차 임원진 면접 날짜를 잡았다.<br>임원진이기 때문에 비개발직군이 들어오지 않을까 싶었는데, 내가 하는 말을 전부 이해하시는 걸 보아 개발자이거나 개발자 출신 같아 보였다.<br>그리고 블로그 하는 걸 굉장히 높게 평가해주셨고, 면접을 보는 내내 긍정적인 신호를 받았다.  </p><p>결과는 <strong>합격</strong>이다.<br>개인적으로 1차에서는 프로젝트 위주로, 2차에서는 기술 위주로 평가를 받아서 다방면에서 고루고루 평가를 제대로 받았단 느낌이 들었다.<br>하지만 3차까지 면접과정이 있다보니 역시 몸과 마음이 시간이 지나면 지날 수록 지침을 느꼈다.<br>1차와 2차는 하루에 몰아서 봤으면 어땠을까… 싶기도 하다. (그러면 내가 지쳐 쓰러졌을 지도 모르겠지만…)</p><h4 id="밸런스-히어로"><a href="#밸런스-히어로" class="headerlink" title="밸런스 히어로"></a>밸런스 히어로</h4><p><a href="https://truebalance.io/" rel="external nofollow noopener noreferrer" target="_blank">밸런스 히어로</a>는 인도에서 무선통신요금을 효율적으로 관리하는 솔루션 등등을 제공해주는 앱(트루 밸런스)을 개발한 핀테크 기업이다.<br>처음에 채용 담당자로부터 <strong>카카오톡</strong>으로 연락이 왔다. (주변 지인을 통해서 내 번호를 알았다고 한다.)<br>나는 인터넷에 핸드폰 번호를 공개한 적이 없어서 맨 처음엔 스팸인가 싶어서 무시했지만 내 주제에 오히려 굴러들어온 기회를 걷어차버리는 것 같아서 먼저 채용 담당자를 만났다.  </p><p>처음에는 별 생각없이 만났는데 정말 흥미로운 서비스 같았다.<br>일단 인도 인구가 13억 명이나 되고, 인도는 현재 개발이 크게 되지 않았고,<br>매달 1,000만명이 스마트폰을 신규가입하고, 인터넷이란 환경을 스마트폰으로 처음 접하는 세대가 대부분이라는 점이 굉장히 흥미로웠다.<br>그러다 보니 비싼 아이폰은 거의 쓰지 않고, 또 대부분이 스마트폰으로 인터넷을 접했기 때문에 프론트엔드 개발자 보다는 안드로이드 개발자가 클라이언트 쪽 주력이란 사실도 흥미로웠다.<br>그리고 서비스를 개발하는 입장에서 인도 현지에 무조건 방문한다는 사실을 듣고 설렘 반, 두려움 반이었다.</p><p>바로 그 날 저녁에 이력서를 보내고, 시간이 흘러 서류는 통과하고 코딩테스트를 봤다.<br>다른 코딩 테스트와 비슷한 수준이었는데 샘플로 등록된 테스트 코드가 많지 않았다.<br>그래서 내가 테스트 코드를 등록해서 돌려봤는데 내가 등록한 테스트 코드는 잘 통과했다.<br>그래서 바로 제출을 했는데 말하기 창피한 수준의 점수가 나와서 한숨을 푹푹 쉬어가며 떨어졌다고 생각했는데 웬걸 합격 메일이 날아왔다.</p><p>1차로 기술면접을 봤는데 그 날 처음 위워크를 방문해봤는데 상당히 시설이 좋아서 일하는 분위기 보다는 노는 분위기가 났다.<br>그리고 건물은 높은데 엘레베이터가 두 대 뿐이 없어서 엘레베이터 전쟁도 어느 정도 예상되었다.<br>네오펙트는 프로젝트 이력만 물어봤던 것에 비해서 밸런스 히어로는 기본적인 기술 관련된 질문도 좀 했다. (JVM 메모리 구조나 GC 같은…)<br>그리고 내가 진행한 배포 서버 구축 프로젝트에 대해서 내가 <strong>CI/CD</strong> 서버 구축이라고 적어놨는데 사실 단순히 배포 서버만 만든 건데 해당 단어의 의미를 정확히 모르고 사용했다는 것도 피드백을 해주셨다.  </p><p>1차 면접에 대한 결과는 그날 저녁에 바로 와서 여기 사람이 그렇게 급한가… 싶었다.<br>(아니면 내가 그만큼 뽑고 싶은 인재인가…란 생각도 들긴 했지만 아직 김칫국 마시기엔 일렀기 때문에 애써 자기 최면을 했다.)<br>2차 면접은 1차에서 기술에 대한 걸 봤기 때문에 전형적인 임원진 면접으로 알고 있었는데 테크 리더 분께서 들어오셔서 기술 심층 면접을 보았다.<br>블로그에 대해 얘기를 하다가 심도있게 작성한 글을 얘기하다보니 직접 심도있게 적은 글을 골라보라 하고 그에 대해 설명도 부탁하셨다.<br>그렇게까지 디테일하게 블로그에 대해서 물어본 적은 처음이었다.<br>그리고 해시맵이나 GC의 구조 등등에 대해서 좀 더 심도있게 질문해주셨는데 처음엔 내가 답변을 제대로 못하자 문제를 해결할 수 있게 끔 질문을 유도해주셨다.  </p><p>결과는 <strong>합격</strong>이다.<br>코딩테스트까지는 일반적인 속도였지만, 그 이후부터는 굉장히 빠르게 채용이 진행되고 결과도 빨리 알려줘서 좋았다.   </p><h4 id="비바-리퍼블리카"><a href="#비바-리퍼블리카" class="headerlink" title="비바 리퍼블리카"></a>비바 리퍼블리카</h4><p><a href="https://toss.im/" rel="external nofollow noopener noreferrer" target="_blank">비바 리퍼블리카</a>는 간편 송금 서비스로 시작한 토스란 앱을 만들고, 토스로 이름이 더 많이 알려진 핀테크 스타트업이다.<br>토스하면 복지라던지, 여러가지 무성한 소문 때문에 굉장히 높은 벽으로 인식하고 있었다.  </p><p>토스는 다른 회사와 달리 코딩 테스트를 일절 보지 않았다. (손코딩도 마찬가지로)<br>이유를 물어보니 코딩 테스트로 역량 검증이 힘들다고 했던 걸로 기억한다.  </p><p>서류 넣자마자 다음날 연락이 와서 그 다음주에 바로 1차 기술 면접 날짜를 잡았다.<br>다른 곳과 마찬가지로 대부분 프로젝트 관련된 질문이었고, 다른 데서는 인프라 쪽 얘기를 많이 했는데 여기선 서버 개발 쪽 얘기를 많이 했다.<br>내가 MSA 경험이 없고 대용량의 트래픽을 받아본 경험이 없다보니 그에 대한 답변을 못하자 계속해서 답변을 유도할 수 있는 질문을 해주셨다.</p><p>그리고 그 다음날 바로 합격 전화가 와서 또 그 주에 2차 문화 면접 날짜를 잡았다.<br>임원진 면접도 아니고, 문화 면접이기 때문에 어떻게 준비를 해야할지 막막해서 지인에게 조언을 구했다.<br>지인은 아래와 같이 조언해주었다.  </p><ol><li>인생의 목표를 설정해라.  </li><li>인생의 목표와 회사의 목표를 봐라.  </li><li>공통점을 찾아라.  </li><li>공통점이 없다면, 혹은 현저히 적다면 과감히 포기해라.  </li></ol><p>나는 거짓말을 쳐서라도 들어가고 싶은 곳은 들어가야하나 싶었는데 그 분은 장기적으로 봤을 때는 회사나 본인 둘 다에게 손해라고 말씀해주셨다.<br>누구나 해줄 수 있는 말이지만 나에겐 굉장히 영향력이 큰 분이라 위 조언을 토대로 아래와 같이 행동해보았다.  </p><ol><li>인생의 목표를 정한다.  </li><li>내 인생의 목표를 이루려면 뭘 해야할까?  </li><li>회사가 내 인생의 목표를 이루는데 도움이 될까?</li><li>된다면 어떤 부분에서 어떤 도움을 받을 수 있을까?</li></ol><p>위와 같은 고민을 하자 토스에는 내 인생의 목표를 이뤄줄만한 점이 있기 때문에 그걸 토대로 면접을 준비했다.<br>이 시간은 불과 3시간도 채 걸리지 않았다.<br>배민의 2차 면접을 위해 1주일 간 배민다움 책을 읽은 것에 비하면(1주일 내내 읽은 건 아니지만)<br>굉장히 단시간 내에 2차 면접 준비를 마쳤고, 확신 또한 있었다.</p><p>2차 면접은 위에 고민한 내용을 토대로 정리해서 답변을 했고, 나를 당홯하게 만드는 질문이나 내용들이 어느 정도 있었지만 확신을 갖고 있었기 때문에 이상한 답변을 한 것 같진 않다.<br>그리고 토스가 어떻게 일하는지, 정말 기업 문화가 어떤 문화인지 알 수 있게 해주는 면접이었다.</p><p>결과는 <strong>합격</strong>했는데 바로 그 날 저녁에 알려주었다. <del>(저녁에도 열심히 일하는 무서운 사람들…)</del><br>다른것보다도 내가 여태껏 경험해본 모든 채용과정을 통틀어 제일 빨랐다.<br>모든 과정이 1주일 내로 다 끝났다.<br>개인적으로 이런 부분도 구직자를 배려해주는 한 부분인 것 같다고 느꼈다.</p><h4 id="우아한-형제들"><a href="#우아한-형제들" class="headerlink" title="우아한 형제들"></a>우아한 형제들</h4><p><a href="https://www.woowahan.com/" rel="external nofollow noopener noreferrer" target="_blank">우아한 형제들</a>은 배달의 민족(줄여서 배민), 배민찬, 배민 라이더스 등등의 서비스를 만든 회사로 오히려 <strong>배민</strong>이란 이름으로 더 잘 알려져있다.<br>우아한 형제들을 처음 지원할 때는 굉장히 망설였다.<br>월간 카카오와 달리 한 달에 한 번 지원할 수 있는 제도가 아니기 때문에 재도전하기까지 쿨타임(기간)이 어느정도 있기 때문이었다.<br>하지만 개발이 하고 싶다는 강한 욕구와 기술 블로그와 다양한 세미나 등등을 통해 개발 문화가 탄탄한 게 눈에 보였기 때문에 고민 끝에 지원했다.</p><p>이력서 양식에서부터 신경을 많이 쓴 티가 났다. <del>(내가 쓴 이력서를 재활용하지 못해서 좀 귀찮았지만…)</del><br>일반적인 회사의 지원동기 같은 건 물어보지 않았고(아마도 없었던 걸로 기억한다.),<br>배민의 B급 감성과 잘 맞는 사람을 찾는 것인지 노래와 시를 인용해서 작성하는 내용도 있었는데 평상시 가사 보다는 비트 위주의 음악을 듣다보니 해당 내용을 그냥 무시하고 적었다.</p><p>1주일 정도가 흘러 코딩 테스트 메일이 와서 서류는 합격인 줄 알았는데 코딩 테스트까지가 서류 전형이었다.<br>문제는 크게 어렵진 않았는데 복잡도(리스트가 엄청 크다거나) 부분에서 타임아웃이 발생했다.<br>시간이 없는 관계로 제출을 하긴 했는데 계속해서 마음에 걸렸지만 어쩔 수 없었다.</p><p>또 1주일 정도가 흘러 코딩 테스트는 합격 메일이 오고, 그로부터 또 1주 후에 이제 1차 기술 면접을 보게 되었다.<br>이번 기술 면접 때도 자바나 스프링 같은 기본적인 기술보다는 프로젝트 이력 위주로 물어보았다.<br>내가 인프라 쪽 얘기를 굉장히 많이 하자 내 정체성(본인은 인프라 쪽이냐, 개발 쪽이냐)을 여쭤보고 내가 개발이라고 답하자 안심하는 듯 했다.<br>면접 분위기도 딱딱하지 않고 자연스럽게 풀어주어서 좋았다.<br>코딩 테스트에 관한 건 내 코딩 습관(메서드를 쪼개거나 변수 앞에 final을 붙이는 등등)에 대해서만 물어보았다.<br>면접 중간중간 공부 열심히 했다는 칭찬도 들었는데 이 때부터 자신감이 엄청 붙기 시작해서 면접이 끝나고 붙었다는 자신이 생겼다.<br>한편으론 면접을 못봤다고 생각했을 때도 붙은 경험이 있기 때문에 반대로 되는 게 아닐까, 나 혼자 헛소리 하다 온 게 아닐까 걱정이 됐다.<br>면접이 끝나고 배민의 B급 감성이 가득 담긴 선물을 주는데 면접 때 뭘 받아본 적은 처음이어서 기분이 되게 좋았다.</p><p>그로부터 1주일 정도가 흘러 1차 합격 메일이 오고, 2차 임원진 면접을 그로부터 1주 후에 보았다.<br>면접 보기 하루 전날에 스타벅스 기프트콘을 주는 것 또한 면접자를 배려해준다는 걸 크게 느낄 수 있었다.<br>정말정말 들어가고 싶은 회사이기 때문에 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11211590" rel="external nofollow noopener noreferrer" target="_blank">배민다움</a>이란 책도 읽었다.<br>개인적으로 배민에 들어갈 생각이 없더라도 꼭 한 번 읽어보길 권한다.<br>한 기업의 역사와 어떤 마인드를 가지고, 또 어떻게 충성도 높은 고객을, 그런 문화들을 만들어냈는지 엿볼 수 있는 기회이다.<br>책을 본 덕분에 면접은 괜찮게 봤다는 느낌이 들었다.  </p><p>그로부터 1주일 정도가 흘러 최종 <strong>합격</strong> 메일이 왔다.<br>면접자를 배려하는 점은 굉장히 좋은 경험이었지만 길었던 면접 과정에 몸과 마음이 많이 지친 것 같았다.</p><h2 id="나는-어떻게-합격할-수-있었을까"><a href="#나는-어떻게-합격할-수-있었을까" class="headerlink" title="나는 어떻게 합격할 수 있었을까?"></a>나는 어떻게 합격할 수 있었을까?</h2><p>자만이 아니라 내 주관적인 판단 하에 어떤 이유 때문에 생각지도 못한 기업들에 합격할 수 있었는지 고민해봤다.<br>하나하나 나열해서 과거로 올라가자면 끝이 없을테니 적당히 추려보았다.</p><h3 id="연차대비-다양한-경험"><a href="#연차대비-다양한-경험" class="headerlink" title="연차대비 다양한 경험"></a>연차대비 다양한 경험</h3><p>나는 다음과 같은 경험을 해보았다.  </p><ol><li>프로젝트 세팅(Gradle, JDK, 기술 스택)  </li><li>서버 세팅(AWS의 VPC, Subnet, Routing Table, NAT Gateway, EC2, ELB, EB, Security Group, Route 53, RDS, ElastiCache 등등을 처음부터 끝까지 만들어보았다.)  </li><li><a href="/2017/09/28/map-api-performance-improvement/">성능 개선</a>(지도보기 API 응답 15MB -&gt; 2MB로 줄임, 응답 속도를 22초에서 0.5초로 단축)  </li><li>기존 로직을 수정할 때 먼저 기존 로직을 손대지 않고 성공하는 테스트 코드를 작성한 후에 로직을 개선하면서 테스트가 실패하지 않게 끔 하며 리팩토링</li><li>Dogfooding(외부에 제공할 서비스를 사내에서 미리 적용해봄) 용으로 진행한 프로젝트에서 Spring WebMVC를 사용해도 됨에도 불구하고 먼저 Webflux를 제안해주셔서 Webflux에 대한 간단한 이해도 및 장단점</li><li>인프라 경험<ol><li>자동화된 배포 서버 구축 및 배포 방식 통일(Jenkins, Ansible)  </li><li>서버 환경 통일(Docker)  </li><li>모니터링 시스템 구축(Prometheus, Exporter, Grafana)  </li><li>Scale In/Out에 대비하여 유동적으로 서비스 디스커버리(Consul)</li></ol></li></ol><p>위와 같은 경험은 주니어에게 AWS에 대한 제한을 걸지 않았던 환경(각자 DevOps로 일하는 문화)과 독자적으로 프로젝트를 진행할 수 있었던 환경,<br>지속적으로 AWS 쪽에 관심을 표하니 인프라 쪽 업무도 맡을 수 있게 된 환경이 나에게 주어졌기 때문에 경험할 수 있었다.<br>한마디로 복이 참 많았다.</p><h3 id="블로그"><a href="#블로그" class="headerlink" title="블로그"></a>블로그</h3><p>이번 면접에서 블로그에 대해 얘기가 나오지 않은 적이 거의 없었던 것 같다.<br>먼저 언급을 해주거나, 블로그 글 재밌게 잘 봤다고 얘기해주거나, 블로그에 나온 내용 중에 궁금한 점을 물어보거나 할 정도였으니 말이다.  </p><p>3년 전, 처음 블로그 시작은 개발자로 취직하기 전에 이력서에 한 줄이라도 더 적어보고 싶은 마음에, 스타 개발자가 되고 싶은 마음에 시작했다.<br>하지만 이제 블로그에 정리를 하지 않으면 이해도가 많이 줄어드는 것 같고, 정리를 해놓으면 마음이 좀 안심되는 지경에 이르렀다. (그럼에도 불구하고 게으를 땐 여전히 잘 안 쓴다 ㅠㅠ…)<br>또한 블로그를 해서 손해본 적은 없었던 것 같다. (앞으로는 말조심 해야할 일이 더 많을 것 같다.)<br>따라서 뭐가 됐던 블로그에 조금씩 남기다 보면 하나의 밑거름이 되지 않을까 싶다. <del>(광고 수익으로 돈까스를 공짜로 먹으려는 심산도 있긴 하다.)</del></p><h3 id="자신감"><a href="#자신감" class="headerlink" title="자신감"></a>자신감</h3><p>뭔소리냐 싶을 수 있겠지만, 합격하는 곳이 생기고 심지어 칭찬해주거나 면접 잘 봤다고 얘기해주는 면접관도 있다보니<br>그 이후에 보는 면접에서는 더 잘 대답한 것 같았다.<br>심지어 준비를 덜 했는데도 잘 본 기업도 있었다.  </p><p>물어볼 게 비슷해보였고, 그에 대해 나는 준비됐다라고 자신감을 가지기 시작하니 두렵지 않았다.<br>그전에는 ‘어떻게 내가 감히, 나는 아직 부족해’라는 생각으로 의기소침해하며 제대로 대답도 못하거나 이직 시도할 생각 조차도 하지 못했다.<br>하지만 이런 자신감을 가지고 나니 남은 면접들이 전부 수월하게 잘 풀렸다.</p><h3 id="이력서"><a href="#이력서" class="headerlink" title="이력서"></a>이력서</h3><p>지인의 조언을 받아 <a href="https://docs.google.com/document/d/1VBjqH1ghnNB7SONO0JrOHe4kTE328-YZrbm0UrQt4uE/edit?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">전형적인 국문 이력서</a>에서 <a href="https://docs.google.com/document/d/1oLILPuICSujGcaknguKo7vpfV-FrRCyp-VpDKYvAt58/edit?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">프로젝트 중심의 정보들만 남긴 이력서</a>로 탈바꿈했다.<br>전형적인 국문 이력서(사진, 성별, 나이, 주소, 학력, 성장배경 등등)는 기술 중심의 회사라면 그닥 궁금해할 거 같지 않았다.<br>‘개발자가 개발만 잘하면 되지, 뭐가 중요하냐’라는 생각에 수정을 했는데 매우 잘 한 것 같다. </p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>최종적으로 이직하기로 한 회사가 있긴 하지만, <strong>수습 3개월</strong>이라는 큰 관문이 남아있기 때문에 공개하기엔 이른 것 같다.<br>연말 쯤에는 속시원히 어떤 회사 다닌다고 말할 수 있지 않을까 싶다. </p><p>이번 면접 때 느낀 점은 회사에서 원하는 인재는 다 비슷한 것 같았다. (문화만 좀 다를 뿐이지)<br>결국엔 잘하는 사람을 원한다. (내가 잘한다고 막 자만하거나 그런 건 아니다.)<br>적어도 현재 잘하지 않더라도 열심히 해서 미래 잠재 능력을 보는 것도 같았다. (아마도 나는 이 축에 속하는 것 같고 이건 연차가 적은 주니어까지만 먹힐 것 같다.)<br>대부분이 엄청 기술적인 부분보다는 프로젝트 중심으로 많이 물어봤다. (전부 자사 서비스 회사를 가서 그런 경험이 중시된 부분도 있겠지만)<br>결국 프로젝트 경험을 쌓아야하기 때문에 개인적인 토이 프로젝트나 오픈 소스 쪽 경험을 쌓아보는 것도 좋은 것 같다.  </p><p>또한 거짓말 칠만한, 가식적인 질문들(직장 상사의 부당한 지시에 어떻게 대응할 것인지 등등)이 없었고, 나의 솔직한 대답(지원 동기)가 좋게 작용했다.<br>유튜브나 블로그에 저런 것 관련해서 어떻게 답변해야하는지, 면접관이 듣고싶어하는 답은 정해져있다 뭐 이런 내용을 어느 정도 봤었는데 그렇게까지 나 자신을 속이고 싶지 않았다. (덜 간절했던 건지도 모르겠지만…)<br>지원 동기에 대해서 어떤 회사에는 ‘잘하는 사람이 있어서 그 사람 보고 지원했습니다’, 또 어떤 회사에는 ‘평상시에 자주 사용하는 서비스인데 제가 만들고 남들이 쓰는 거 보면 뿌듯할 거 같아서’,<br>또 다른 회사에는 ‘대용량 트래픽에 대한 경험이 없다보니 그런 경험 하고 싶어서’ 이렇게 말했다.<br>인터넷에서 말하는 ‘그 회사여야만 하는 이유’, ‘다른 회사에도 써먹을 수 있는 이유면 안 된다’라는 내용에 완전 위배했다.<br>만약 내가 자신이 없었다면, 준비가 덜 됐더라면 저런 내용들로 나 자신을 숨기고 포장했을 거다.<br>하지만 나는 기술로 승부하는 개발자이기 때문에 숨김없는 나의 기술 실력으로 승부했는데 좋게 작용한 것 같고, 전부 기술 중심의 회사이기 때문에 먹힌 전략 같았다.</p><p>그리고 이번 이직을 통해서 개발자 측면에서도 많은 성장을 했지만, 한 사람 측면에서도 엄청난 성장을 했다.<br>열심히 하고, 잘 한다고 이직 해보라는 권유를 주변으로부터 종종 받았다.<br>하지만 그럴 때일 수록 ‘카프카도 잘 모르는데, 레디스도 잘 모르는데, MSA로 서버 구성도 안 해봤는데, 알고리듬이나 자료구조도 잘 모르는데, 객체지향도 잘 모르는데, 스프링도 잘 모르는데’ 이런 생각이 자꾸만 들었다.<br>그래서 ‘조금만 더 준비하고 봐야지’란 생각으로 계속 공부만 해왔다. (사실 경력 중에 공부 안 하고 인생 낭비한 세월이 절반은 된 것 같다. 물론 공부한 하면서 살진 못하겠지만…)<br>하지만 이번 이직을 통해 내가 합격하지 못할 곳이라고 생각한 기업들에 많이 떨어지기도 했지만 합격도 많이 했다.<br>그러다보니 <strong>내가 생각한 나보다 나는 좀 더 가치가 있는 사람이구나</strong>라는 걸 깨닫게 되었다.<br>그동안 내 가치를 내 스스로 깎아내리고, 제대로 판단하지 못하고 시간을 많이 낭비했다는 생각도 들었다.<br>어떻게 보면 자만일지 모르겠지만 정도 차이는 있더라도 내 가치를 내 스스로 판단하지 못한 건 사실이었다. (물론 지금도 정확히 판단하진 못하지만…)<br>그러다보니 말이나 행동할 때 자신감이 붙다보니 계속해서 좋은 결과가 있었던 것 같다.</p><p>이런 사실은 주변에서 천년 만년 말해줘도 죽었다 깨어나도 깨닫지 못한다.<br>본인이 직접 깨달아야한다. (물론 그만한 준비를 해왔다는 전제 하에…)<br>하지만 시간은 계속해서 흘러가기 때문에 최대한 빨리 깨달아야한다.<br>당신의 가치를 계속해서 깎아내리는 일이 없길 바란다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/exit-yanolja-feat-leisureq/thumb.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;오늘은 야놀자 서류상 &lt;strong&gt;퇴사일&lt;/strong&gt;이다. (오늘까지 남은 연차를 사용했다.)&lt;br&gt;총 세 번의 이직 시도 끝에 성공할 수 있었다.&lt;br&gt;여태까지 신입으로만 이직(프론트엔드 신입(5개월 재직) -&amp;gt; 백엔드 중고 신입)했고, 지인 추천을 통해서만 면접을 봤는데&lt;br&gt;이번 이직에서는 지인 추천도 있었지만, 내 힘으로 스스로 지원해서 합격까지 한 케이스도 많아서 굉장히 뿌듯한 경험이었다.&lt;br&gt;나와 같은 2~3년 차 주니어 분에게 도움이 됐으면 하는 바람, 개인적으로 회고를 하고 싶어서 정리를 해봤다.  &lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="잡동사니" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"/>
    
    
      <category term="퇴사" scheme="https://perfectacle.github.io/tags/%ED%87%B4%EC%82%AC/"/>
    
      <category term="이직" scheme="https://perfectacle.github.io/tags/%EC%9D%B4%EC%A7%81/"/>
    
      <category term="면접" scheme="https://perfectacle.github.io/tags/%EB%A9%B4%EC%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>(Hexo) NexT 테마</title>
    <link href="https://perfectacle.github.io/2019/08/22/hexo-theme-next/"/>
    <id>https://perfectacle.github.io/2019/08/22/hexo-theme-next/</id>
    <published>2019-08-22T06:38:15.000Z</published>
    <updated>2019-08-22T18:18:01.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Static-Page-Blog-테마-선정"><a href="#Static-Page-Blog-테마-선정" class="headerlink" title="Static Page Blog 테마 선정"></a>Static Page Blog 테마 선정</h2><p>Static Page로 만들어진 블로그들은 테마가 굉장히 중요하다.<br>네이버나 티스토리에는 있는 기본적인 기능들이 없는 테마들이 상당히 많다. (검색, 카테고리, 태그, 페이지네이션 등등)<br>따라서 디자인만 보고 골랐다가 커스터마이징하느라 시간을 날리기 십상이기 때문에 디자인과 기능 사이에 어느정도 절충안을 가지고 골라야한다.  </p><a id="more"></a><p><img src="/images/hexo-theme-next/hueman.png" alt=""><br>나는 이전에 <a href="https://github.com/ppoffice/hexo-theme-hueman" rel="external nofollow noopener noreferrer" target="_blank">Hueman</a> 테마를 살짝 커스터마이징해서 사용했다.<br>검색이나 카테고리, 메뉴 등등의 기능은 좋았지만 디자인이 좀 구려보였다.<br>다소 아쉽긴 했지만 블로그의 본질은 <strong>글쓰기</strong>이기 때문에 좀 더 가치있는 일에 집중을 하고 싶어서 큰 불만없이 사용하고 있었다.</p><p><img src="/images/hexo-theme-next/pork-cutlet.jpeg" alt="넘나 맛있는 내사랑 돈까스를 매주 공짜로 먹을 수만 있다면..."><br>하지만 욕심이 생겨서 구글 애드센스를 통해 조그만 수익이라도 창출해보고 싶었다.<br>그러나 번번히 정책에 부합하지 않는다는 답변만 받았다.<br>그러다보니 ‘애드센스 다느라 뻘짓할 시간에 공부해서 연봉 올리는 게 더 낫겠다’는 판단이 들었다.</p><h2 id="왜-NexT-테마로-바꾸는가"><a href="#왜-NexT-테마로-바꾸는가" class="headerlink" title="왜 NexT 테마로 바꾸는가?"></a>왜 NexT 테마로 바꾸는가?</h2><p>하지만 인간의 욕심은 끝이 없고, 주변에서 ‘왜 애드센스 안 다냐, 다른 사람들은 쉽게 통과됐다’라는 소리가 들리길래 다시 욕심이 생겼다.<br>애드센스 말고 다른 광고 플랫폼도 있지만 ‘질떨어지는 광고가 노출되면 어떡하나, 광고가 너무 과해서 사람들의 발길이 끊기면 어떡하나’ 이런 걱정들이 들었다.<br>그렇다고 해서 애드센스가 통과 잘 되는 다른 플랫폼으로 갈아타고 싶진 않았고, 내가 테마를 커스터마이징하면서 뭔가 웹표준이나 접근성에 위배되는 등등의 잘못을 저지르지 않을까 싶었다.<br>따라서 애드센스가 통과된 적이 있고, 사람들이 많이 사용하는 테마를 최대한 커스터마이징하지 않으려고 하다보니 <a href="https://github.com/theme-next/hexo-theme-next" rel="external nofollow noopener noreferrer" target="_blank">NexT</a>란 테마를 발견하게 되었다.</p><p>우선 카테고리, 메뉴, 태그, 검색 등등의 기능은 이전 Hueman 테마와 동일하다.<br>하지만 디자인이 깔끔하고 테마 안에서도 <a href="https://muse.theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Muse</a>, <a href="https://mist.theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Mist</a>, <a href="https://pisces.theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Pisces</a>, <a href="https://theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Gemini</a>와 같은 테마들이 존재한다. (나는 Pisces 테마를 택했다.)<br>또한 사이드바에 목차가 나오는 것도 좋고, 예전에는 블로그 홈에 썸네일이 없으면 좀 보기가 안 좋았는데 이 테마는 굳이 썸네일이 없어도 돼서 썸네일을 고르는데 들었던 시간을 단축시킬 수도 있다.<br><a href="https://theme-next.org/docs/" rel="external nofollow noopener noreferrer" target="_blank">문서</a>도 굉장히 잘 되있고, 한국어도 잘 지원한다.<br>또한 북마크 기능(다음에 해당 페이지 재방문시 스크롤 위치 기억), <a href="https://github.com/MoOx/pjax" rel="external nofollow noopener noreferrer" target="_blank">PJAX</a> (AJAX와 pushState를 이용하여 페이지를 처음부터 로딩하는 게 아니라 필요한 컨텐츠만 로딩), 각종 Analytic, 댓글 등등의 플러그인의 사용이 가능하다.<br>그리고 유지보수도 굉장히 활발히 이루어지고 있다.</p><p>테마를 바꾸고 만 하루만에 바로 통과되었다.<br>기존 테마를 내 맘대로 커스터마이징 하면서 뭔가 잘못 건드린 모양이다.<br><del>주 1회 매콤 치즈 돈까스를 실현하기 위해 블로그를 열심히 해야겠다.</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Static-Page-Blog-테마-선정&quot;&gt;&lt;a href=&quot;#Static-Page-Blog-테마-선정&quot; class=&quot;headerlink&quot; title=&quot;Static Page Blog 테마 선정&quot;&gt;&lt;/a&gt;Static Page Blog 테마 선정&lt;/h2&gt;&lt;p&gt;Static Page로 만들어진 블로그들은 테마가 굉장히 중요하다.&lt;br&gt;네이버나 티스토리에는 있는 기본적인 기능들이 없는 테마들이 상당히 많다. (검색, 카테고리, 태그, 페이지네이션 등등)&lt;br&gt;따라서 디자인만 보고 골랐다가 커스터마이징하느라 시간을 날리기 십상이기 때문에 디자인과 기능 사이에 어느정도 절충안을 가지고 골라야한다.  &lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="잡동사니" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"/>
    
    
      <category term="Hexo" scheme="https://perfectacle.github.io/tags/Hexo/"/>
    
      <category term="Theme" scheme="https://perfectacle.github.io/tags/Theme/"/>
    
      <category term="NexT" scheme="https://perfectacle.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>왜 한국은 미국 금리에 의존적일까?</title>
    <link href="https://perfectacle.github.io/2019/08/15/why-korea-depends-on-interest-rate-us/"/>
    <id>https://perfectacle.github.io/2019/08/15/why-korea-depends-on-interest-rate-us/</id>
    <published>2019-08-15T01:14:29.000Z</published>
    <updated>2019-08-22T05:54:34.771Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://youtu.be/0LYMTsj_eqc?t=3022" rel="external nofollow noopener noreferrer" target="_blank">EBS 다큐프라임 자본주의 제1부 돈은 빚이다</a>와<br><a href="https://www.youtube.com/channel/UClmxSq4_kJfLtyIY7TycFfw" rel="external nofollow noopener noreferrer" target="_blank">돌디</a> 님의 <a href="https://youtu.be/LzpNvyvTmIE" rel="external nofollow noopener noreferrer" target="_blank">금리</a>, <a href="https://youtu.be/jqeXqLJMYl0?t=590" rel="external nofollow noopener noreferrer" target="_blank">돈은 가짜다 - 저축만 해서 망하는 이유</a> 영상을 보면 좀 더 많은 인사이트를 쌓을 수 있다.</p><h2 id="왜-한국은-한국-금리에만-의존할-수-없는-걸까"><a href="#왜-한국은-한국-금리에만-의존할-수-없는-걸까" class="headerlink" title="왜 한국은 한국 금리에만 의존할 수 없는 걸까?"></a>왜 한국은 한국 금리에만 의존할 수 없는 걸까?</h2><p>그 이유는 바로 무역 때문이다.<br>대부분의 나라가 무역을 하기 때문에 그 나라의 금리에만 의존할 순 없을 것이다.<br>더군다나 우리 나라는 자원(석유, 나무, 철광석 등등)이 거의 없다.<br>대부분 외국에서 수입에 의존하기 때문이다.<br>이렇게 수출/수입을 할 때 쓰는 돈이 <code>기축통화</code>인데 우리나라의 통화는 기축통화가 아니기 때문에 우리나라의 금리에만 의존할 수가 없는 거다.</p><a id="more"></a><h3 id="기축통화-우리가-미국-금리에-의존할-수-밖에-없는-이유"><a href="#기축통화-우리가-미국-금리에-의존할-수-밖에-없는-이유" class="headerlink" title="기축통화 - 우리가 미국 금리에 의존할 수 밖에 없는 이유"></a>기축통화 - 우리가 미국 금리에 의존할 수 밖에 없는 이유</h3><p>기축통화는 <code>국제거래에 통용되는 결제 수단</code>으로서 가장 의미있는 돈이 기축통화인데, 현재 기축통화는 미국의 달러($)이다.  </p><p>그럼 어떻게 달러가 기축통화가 되었을까?<br>현재 미국이 경제대국이지만 과거에는 영국이 경제대국이었다.<br>그래서 2차 세계 대전 이전에는 영국의 파운드(£)가 기축통화였다.<br>하지만 2차 세계 대전 당시에 영국은 전쟁 자금을 마련하기 위해 미국으로부터 많은 돈을 빌렸고,<br>그 돈을 갚기 위해 영국은 많은 금을 미국에 지불하게 된다.<br>대부분 금을 제일 많이 가지고 있는 국가가 패권을 가지게 되고, 그로 인해 미국이 패권을 가지게 됨으로써 <code>1944년 미국 브레튼우즈 협정</code>에서 달러가 기축통화가 되었다.</p><h3 id="달러의-의미"><a href="#달러의-의미" class="headerlink" title="달러의 의미"></a>달러의 의미</h3><p><a href="/2019/08/15/money-is-debt#최초의-은행">돈은 빚이다</a>에서 말했다 싶이 금은 들고다니기 불편하므로 대부분의 사람이 금고에 금을 맡기고, 금 보관증으로 거래를 하기 시작했다.<br>기축통화가 된 달러도 마찬가지였다.<br>35 달러를 가져오면 금 1oz로 교환해주겠다고 <code>1944년 미국 브레튼우즈 협정</code>에서 정해졌다. (이를 <code>금 본위제 또는 금 태환제</code>라고 부른다.)</p><p>즉, <code>달러는 금 보관증</code>으로써 작용하기 시작했다.<br><img src="/images/why-korea-depends-on-interest-rate-us/dollar-in-past.jpeg" alt="TEN DOLLARS IN GOLD COIN이라는 문구를 주목해라."></p><p>하지만 그 이후에 베트남 전쟁으로 달러의 가치가 하락하기 시작했다.<br>달러의 가치가 하락했다는 것은 수요/공급 법칙에 의해 달러의 공급이 많아졌음을 의미한다.<br>즉, 공급이 많아졌다는 것은 중앙은행에서 달러를 많이 찍어냈음을 의미한다.<br>왜냐하면 전쟁을 하려면 많은 돈이 필요하기 때문이다.<br>그만한 금이 없음에도 불구하고 미국은 자신의 금고 안에 금이 얼마나 들어있는지는 미국 자신 밖에 모르기 때문에 <code>없는 금을 교환</code>해준다고 교환증(달러)을 마구 찍어댄 게 아닐까 싶다.</p><p>그래서 미국에 수출을 해서 달러를 벌어들인 각국은 달러의 가치를 점점 의심하기 시작한다.<br>그 결과 많은 국가가 <code>달러(금 보관증)</code>를 금으로 바꾸기 시작한다.<br>엎친데 덮친격으로 미국은 무역 적자(수출액 &lt; 수입액)였기 때문에 금은 점점 더 미국 밖으로 유출되기 시작한다.  </p><p>역사적으로 금을 가장 많이 가진 국가가 패권을 쥐기 때문에 금의 유출이 두려웠던 미국은 <code>1971년 닉슨 대통령</code>에 의해 금 본위제(달러를 금으로 교환)를 폐지하도록 한다.<br>왜냐하면 돈은 종이 쪼가리에 불과하기 때문에 중앙은행에서 찍어대기만 하면 되지만, 금은 실물이기 때문에 돈보다 생성(혹은 확보)해내기가 훨씬 어려웠기 때문이다.<br>물론 폐지할 때도 영구적으로 폐지한다고 하면 달러(금 보관증)를 소유한 나라의 반발이 심할 것이므로 미국의 경제가 살아날 때까지 임시 방편으로 폐지하는 것처럼 얘기했지만 그 이후 금 본위제는 부활하지 않고 있다.</p><p><img src="/images/why-korea-depends-on-interest-rate-us/dollar-in-present.jpg" alt="1971년 이후의 달러는 GOLD와 관련된 문구가 어디에도 적혀있지 않다."><br>이제 달러는 금으로부터 자유로워졌고, 단순히 종이 쪼가리에 불과하게 된다.<br>즉, 금의 보유량과 상관없이 이제 마구잡이로 찍어댈 수 있게 됐다.</p><h3 id="미국의-조폐공사"><a href="#미국의-조폐공사" class="headerlink" title="미국의 조폐공사"></a>미국의 조폐공사</h3><p>또한 달러의 조폐공사인 미국의 중앙은행(FRB, Federal Reserve Bank)은 한국과 달리 정부가 운영하는 기관이 아닌 <code>민간은행</code>이다.<br>따라서 민간은행에 의해 돈이 생산되다보니 완전 그들의 손아귀에 막강한 권력이 있는 것이다.<br>미국 정부마저도 중앙은행에 이자를 내고 돈을 대출받고 있다.  </p><p>어찌보면 굉장히 웃긴 일인데, 미국에서도 화폐 발행권을 민간은행에서 정부로 옮기려는 시도는 있었다.<br>케네디 대통령이 <code>암살</code>당한 해인 <code>1963년 6월</code>에 <code>대통령령 11110호(화폐의 발행권을 정부로 가져온다는 내용)</code>에 서명했다.<br>그로부터 5개월 후인 11월에 케네디 대통령은 암살 당하고, 그 이후 대통령을 맡게 된 존슨 대통령은 대통령령 11110호에 <code>서명한 것을 취소</code>했다.<br>음모론에 불과할지 모르겠지만, <code>그만큼 미국의 중앙은행이 가진 권력이 막강했기 때문에 이런 사태가 벌어졌다</code>라는 루머도 있다.</p><p>이렇게 달러는 종이 쪼가리에 불과하고(완전 종이 쪼가리까지는 아니고, 미국에 대한 신뢰도로써 사용되는 게 아닐까 싶다.), 그 달러 마저도 정부가 아닌 민간은행에서 발행하기 때문에<br>미국에 대한 의존도를 낮추자는 차원에서 다른 기축통화를 지정하자는 얘기도 있었지만 그만한 경제 규모를 가진 큰 나라가 없기 때문에 계속해서 달러가 기축통화로서 자리잡고 있는 게 아닐까 싶다.</p><h3 id="한국-금리는-미국-금리에-의존한다"><a href="#한국-금리는-미국-금리에-의존한다" class="headerlink" title="한국 금리는 미국 금리에 의존한다."></a>한국 금리는 미국 금리에 의존한다.</h3><p><a href="/2019/08/15/why-central-banks-creates-money/">왜 중앙은행은 화폐를 발행하는가? (feat. 인플레이션, 디플레이션)</a>에서 말했다 싶이 돈도 수요/공급 원칙을 따른다.<br>또한 금리(돈을 빌려주는 대가, 이자)에도 마찬가지로 수요/공급 원칙이 적용된다.  </p><p>돈을 빌리려는 사람이 많으면 공급 부족에 의해 금리는 올라간다.<br>경기가 좋으면 사람들은 많은 돈을 사용할테고, 그로 인해 돈도 빌려서 여기저기 사업도 번창하고, 투자도 많이 할 것이다.<br>이렇게 경기가 좋으면 금리는 올라가게 돼있다.</p><p>돈을 빌리려는 사람이 적으면 공급 과잉에 의해 금리는 내려간다.<br>경기가 안 좋으면 사람들의 소비 심리는 위축되고, 그로 인해 기업의 매출은 줄어들고, 기업은 매출이 줄어들었으니 인건비 절감의 목적으로 정리해고를 하고, 또 정리해고 당한 사람들은 돈을 벌지 못하니 소비 심리는 위축되고…<br>이런 사이클이 계속해서 반복된다.<br>정부 입장에서는 사람들이 소비를 하지 않으니 세금이 덜 걷히게 되니 돈을 쓰게 끔 만들어야한다.<br>돈이 있어야 쓰게 되는데 사람들은 돈이 없다보니 적은 금리로 대출해주는 것이다.<br>하지만 그럼에도 불구하고 사람들이 금리가 비싸다고 생각되면 돈을 많이 빌리지 않을테니 사람들이 돈을 많이 빌릴 때까지 계속해서 금리를 내린다.<br>0%까지 내리면 누구나 돈을 빌리고 갚지 않으면 되기 때문에 0.1%까지 낮추는 것으로 알고 있다.</p><p>이렇게 경기가 안 좋아지면 금리는 내려가고, 그러다 다시 경기가 좋아지면 금리를 올리고, 이런 싸이클이 계속해서 반복된다.  </p><p>하지만 이는 한 나라의 금리만 바라봤을 때의 얘기이고, 다른 나라의 금리까지 끼어들게 되면 상황은 좀 복잡해진다.  </p><table><thead><tr><th>은행명</th><th>이자</th><th>자본</th></tr></thead><tbody><tr><td>A</td><td>3%</td><td>건장</td></tr><tr><td>B</td><td>1%</td><td>부실</td></tr></tbody></table><p>당신이라면 어느 은행에 예금할 것인가? 이성적으로 판단해보면 당연히 A 은행에 맡길 것이다.<br>그럼 이 은행명을 국가로 바꿔보자.</p><table><thead><tr><th>국가</th><th>이자</th><th>자본</th></tr></thead><tbody><tr><td>미국</td><td>3%</td><td>건장</td></tr><tr><td>한국</td><td>1%</td><td>부실</td></tr></tbody></table><p>대부분 한국보다 미국이 훨씬 튼튼한 나라라고 생각한다.<br>더군다나 금리마저 높다면??<br>당장 한국에 투자했던 사람은 한국에 투자한 돈을 빼서 다시 미국에 투자할 것이다.<br>따라서 이런 자본의 유출을 막기 위해 경기의 상황과는 별개로 울며 겨자먹기로 금리를 조금씩 올려서 미국보다 금리를 높게 만들 수도 있을 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://youtu.be/0LYMTsj_eqc?t=3022&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;EBS 다큐프라임 자본주의 제1부 돈은 빚이다&lt;/a&gt;와&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/channel/UClmxSq4_kJfLtyIY7TycFfw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;돌디&lt;/a&gt; 님의 &lt;a href=&quot;https://youtu.be/LzpNvyvTmIE&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;금리&lt;/a&gt;, &lt;a href=&quot;https://youtu.be/jqeXqLJMYl0?t=590&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;돈은 가짜다 - 저축만 해서 망하는 이유&lt;/a&gt; 영상을 보면 좀 더 많은 인사이트를 쌓을 수 있다.&lt;/p&gt;&lt;h2 id=&quot;왜-한국은-한국-금리에만-의존할-수-없는-걸까&quot;&gt;&lt;a href=&quot;#왜-한국은-한국-금리에만-의존할-수-없는-걸까&quot; class=&quot;headerlink&quot; title=&quot;왜 한국은 한국 금리에만 의존할 수 없는 걸까?&quot;&gt;&lt;/a&gt;왜 한국은 한국 금리에만 의존할 수 없는 걸까?&lt;/h2&gt;&lt;p&gt;그 이유는 바로 무역 때문이다.&lt;br&gt;대부분의 나라가 무역을 하기 때문에 그 나라의 금리에만 의존할 순 없을 것이다.&lt;br&gt;더군다나 우리 나라는 자원(석유, 나무, 철광석 등등)이 거의 없다.&lt;br&gt;대부분 외국에서 수입에 의존하기 때문이다.&lt;br&gt;이렇게 수출/수입을 할 때 쓰는 돈이 &lt;code&gt;기축통화&lt;/code&gt;인데 우리나라의 통화는 기축통화가 아니기 때문에 우리나라의 금리에만 의존할 수가 없는 거다.&lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"/>
    
    
      <category term="자본주의" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"/>
    
      <category term="재테크" scheme="https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"/>
    
      <category term="금리" scheme="https://perfectacle.github.io/tags/%EA%B8%88%EB%A6%AC/"/>
    
      <category term="기축통화" scheme="https://perfectacle.github.io/tags/%EA%B8%B0%EC%B6%95%ED%86%B5%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>왜 중앙은행은 화폐를 발행하는가? (feat. 인플레이션, 디플레이션)</title>
    <link href="https://perfectacle.github.io/2019/08/15/why-central-banks-creates-money/"/>
    <id>https://perfectacle.github.io/2019/08/15/why-central-banks-creates-money/</id>
    <published>2019-08-14T16:56:31.000Z</published>
    <updated>2019-08-22T05:54:34.844Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/why-central-banks-creates-money/thumb.jpg" alt="돈 많이 벌고싶다..."></p><p><a href="https://youtu.be/0LYMTsj_eqc" rel="external nofollow noopener noreferrer" target="_blank">EBS 다큐프라임 자본주의 제1부 돈은 빚이다</a>를 보고 나면 더 많은 인사이트를 얻을 수 있다.</p><h2 id="물가는-왜-상승하는가-feat-인플레이션"><a href="#물가는-왜-상승하는가-feat-인플레이션" class="headerlink" title="물가는 왜 상승하는가? (feat. 인플레이션)"></a>물가는 왜 상승하는가? (feat. 인플레이션)</h2><p><img src="/images/why-central-banks-creates-money/demand-and-supply.jpg" alt="수요와 공급의 원칙을 알고 있는가?"></p><p>수요가 늘어나거나 공급이 줄어들면 가격이 올라간다.(공급 부족)<br>예를 들면 참외 농사가 흉년이 일어나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 5개로 확 줄어들은 상황이거나,<br>어느날 참외가 암을 치료해준다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1000명으로 늘어난 상황이다.</p><a id="more"></a><p>수요가 줄어들거나 공급이 늘어나면 가격은 줄어든다.(공급 과잉)<br>예를 들면 참외 농사가 풍년이 나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 1000개로 확 늘어난 상황이거나,<br>어느날 참외를 먹으면 암에 걸린다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1명으로 줄어들은 상황이다.</p><p>이렇게 특정 물건에 대해서 수요와 공급의 원칙에 의해 물가가 상승/하락하곤 한다.<br>하지만 이건 특정 물건에만 국한되는 게 아니라 돈에도 적용되는 원칙이다.</p><p>돈의 공급이 늘어나는 방법에는 두 가지 방법이 있다.</p><ol><li>중앙은행에서는 화폐를 발행할 수 있다.<br>돈을 찍어내는데 당연히 공급이 늘어날 것이다.</li><li>일반 시중에 있는 은행들(중앙은행도 마찬가지)은 빚을 생성(대출로 인해)해서 그 이자로 인해 이익을 창출한다.<br>은행은 대출해 줄 수록 이자를 많이 받을 수 있고, 그러면 그럴 수록 통화량은 증가한다.<br>즉, 새로운 빚이 생성됨과 동시에 새로운 돈이 생성되는 것이다.</li></ol><p>위와 같은 방법으로 인해 돈이 많아졌으니 돈에 대한 공급이 과잉 현상이 발생한다.<br>즉, 돈의 가치가 하락한다.</p><p>돈의 가치가 하락했는데 참외의 수요/공급 상황은 동일하다고 해보자.<br>그럼 더 많은 돈을 지불해야 참외 한 개를 살 수 있게 된다.<br>이렇게 통화량의 증가로 인해 화폐가치가 하락하고, 물가가 오르는 경제 현상을 <code>인플레이션(통화팽창)</code>이라고 한다.</p><p><img src="/images/why-central-banks-creates-money/korea-graphg.png" alt="출처: 한국은행"><br>우리나라 경제를 보면 꾸준하게 통화량도 증가했고, 그와 비슷한 추세로 물가도 같이 상승했음을 알 수 있다.</p><h2 id="중앙은행"><a href="#중앙은행" class="headerlink" title="중앙은행"></a>중앙은행</h2><p>중앙은행(우리나라의 중앙은행은 한국은행이다.)은 아래 권한들을 통해 통화량을 조절한다.</p><h3 id="이자율-통제"><a href="#이자율-통제" class="headerlink" title="이자율 통제"></a>이자율 통제</h3><p>이자율을 통제(올리고 내림)함으로써 어떻게 통화량을 조절할 수 있다는 걸까?</p><p>우선 경기가 안 좋다고 쳐보자.<br>그럼 사람들의 지갑은 무거워 질 것이고, 더더욱 경기는 안 좋아질 것이다.<br>이 때 사람들이 소비를 하게 끔 만드는 방법은 무엇일까?<br>바로 통화량을 늘려 사람들이 돈을 더 많이 가지게 끔 하면 돈을 많이 쓰게 될 것이다.<br>그러면 통화량을 늘려야하는데 이자율만 내려도 통화량은 자연스레 늘어난다.<br>이자율이 내려가면 사람들은 싼 이자에 돈을 빌릴 수 있으니 더 대출을 많이 하게 된다.<br>그럼 대출을 함으로써 새로운 돈이 생성되는 것이다. (통화량 증가)</p><p>반대로 경기가 좋다고 쳐보자.<br>경기가 좋으니 사람들의 지갑은 빵빵할 것이고, 이자율이 조금 높아져도 지갑이 빵빵하니 어느정도 납득할 것이다.<br>하지만 대부분의 사람들이 이자율이 높아지면 내야할 이자가 많기 때문에 전보다는 돈을 많이 빌리지 않게 된다.<br>또한 이자율이 비싸졌으니 비싼 이자를 감당하기 힘들어서 하루 빨리 빚을 갚으려고 할 것이다.<br>이럼으로써 빚은 적게 생성되거나 줄어들게 되다보니 통화량은 줄게 돼있다.</p><h3 id="화폐-발행"><a href="#화폐-발행" class="headerlink" title="화폐 발행"></a>화폐 발행</h3><p>말 그대로 돈을 찍어내는 것이다.<br>이자율 통제는 통화량을 늘릴 수도, 줄일 수도 있지만 화폐 발행은 통화량을 줄일 순 없다.</p><p>또한 양적 완화(quntitative easing)라는 단어도 있는데 이 단어의 뜻은 <code>중앙은행이 화폐를 찍어 통화량을 늘림으로써 경기방어와 신용경색(금융기관에서 돈이 제대로 공급되지 않아 기업들이 어려움을 겪는 현상)을 해소하는 정책</code>이라고 한다.<br>양적 완화는 이자율을 낮췄음에도 불구하고 경기가 회복되지 않는 등 효과가 없을 때 시행한다.</p><h2 id="중앙은행은-왜-화폐를-발행할까"><a href="#중앙은행은-왜-화폐를-발행할까" class="headerlink" title="중앙은행은 왜 화폐를 발행할까?"></a>중앙은행은 왜 화폐를 발행할까?</h2><p>우선 <code>경기가 안 좋아서 시중에 돈을 많이 풀려고</code>라고 생각할 수 있다.<br>하지만 이것보다 더 근본적인 무서운 이유가 존재한다.<br>그것은 <code>대출에는 이자 시스템이 존재하는데, 대출받은 돈 자체가 이자를 발생시키지 않기 때문</code>이다.</p><ol><li>중앙은행에서 여태까지 화폐를 100원만 발행했다고 쳐보자.<br>(통화량 100원)</li><li>100원을 A라는 사람에게 이자 10원과 함께 빌려줬다. (여기서 지급 준비율은 무시한다.)<br>(통화량: 100원, A의 자본: 100원)</li><li>A는 이자까지 갚기 위해 B라는 사람으로부터 보트를 10원에 산다.<br>(통화량: 100원, A의 자본: 90원, B의 자본: 10원)  </li><li>A가 보트를 타고 잡은 물고기를 B가 10원에 산다.<br>(통화량: 100원, A의 자본: 100원, B의 자본: 0원)</li></ol><p>위와 같은 상황에서 A는 아무리 열심히 일을 해도 이자 10원을 갚을 수 없다.<br>애초에 그 10원이란 돈은 존재하지 않기 때문이다.</p><ol><li>따라서 중앙은행에서 <code>이자 10원을 갚게 끔 해주기 위해 화폐를 발행</code>한다.<br>(통화량 110원, A의 자본: 100원, B의 자본: 0원)  </li><li>발행한 10원을 B에게 이자 1원과 함께 빌려준다.<br>(통화량 110원, A의 자본: 100원, B의 자본: 10원)  </li><li>다시 A가 보트를 타고 잡은 물고기를 B가 10원에 산다.<br>(통화량 110원, A의 자본: 110원, B의 자본: 0원)</li></ol><p>이렇게 <code>이자를 갚게 하기 위해 화폐를 발행</code>하고, 기존에 대출받은 사람이 아닌 다른 사람에게 대출해주고, <code>그 사람의 대출금을 내가 빼앗아와야</code> 이자까지 갚을 수 있다.<br>즉, 다른 사람의 대출금을 뺏어야하는 무서운 시스템이다.<br>또한 경기를 회복시키기 위해 화폐를 발행하는 것이 아닌 이자를 갚게 하기 위해서, 누군가 대출을 받게 하기 위해서 화폐를 발행하는 것 또한 정말 무섭다.</p><p>위와 같은 상황에서 B가 이자 11원까지 갚기 위해서는 중앙은행에서 또 화폐를 발행하고, B가 아닌 다른 누군가가 그 돈을 대출하고, 그 대출금을 뺏어와야 이자까지 갚을 수 있다.</p><p>결국 계속해서 누군가의 대출금을 뺏어와야 하는 시스템이고, 누군가의 대출금을 뺏어오지 못하는 가난하고 힘없는 자부터 파산을 하게 되는 아주 잔인한 시스템이다. 마치 폭탄 돌리기 같다…</p><h2 id="통화량이-줄어드는-경우도-있을까-feat-디플레이션"><a href="#통화량이-줄어드는-경우도-있을까-feat-디플레이션" class="headerlink" title="통화량이 줄어드는 경우도 있을까? (feat. 디플레이션)"></a>통화량이 줄어드는 경우도 있을까? (feat. 디플레이션)</h2><p>대부분의 경우에는 통화량이 계속해서 증가한다.<br>그러다가 폭탄 돌리기를 하다 시한폭탄이 터지듯, 누군가 빚을 갚지 못해 파산하는 경우에는 통화량이 줄어든다.</p><ol><li>A가 은행에 100원을 예금한다.<br>(통화량: 100원, 은행 자본: 100원)  </li><li>은행에서 지급 준비율 10%에 의해 10원만 남겨두고 90원을 B에게 대출해준다.<br>(통화량: 190원, 은행 자본: 10원)  </li><li>B가 빚을 갚지 못해 파산한다.<br>(통화량: 100원, 은행 자본: 10원)</li></ol><p>이렇게 누군가 빚을 갚지 못해 파산하는 경우에 통화량이 줄어들고 그에 따라 은행도 타격을 받고, 기존 예금주도 타격을 입는다.<br>이럴 때 <code>디플레이션(통화량의 축소로 물가가 하락하고, 경제활동이 침체되는 현상)</code>이 발생한다.<br>통화량이 축소됐으므로 수중에 갖고 있는 돈이 적다는 뜻이니 당연히 경제 활동은 침체되는 것이다.<br>기업이 위축되고, 생산과 투자를 줄이고 정리해고 하게 된다.<br>그럼 일자리가 줄어들고 돈을 벌기 힘들어진다.</p><p>하지만 무서운 점은 인플레이션 후에 디플레이션이 오는 건 <code>숙명</code>이라고 한다.<br>왜냐하면 경제 호황이 진정한 돈(생산을 통해서 번 돈 등등)이 아닌 빚으로 빌린 돈이기 때문이다.<br>그럼 그 빚이 계속해서 쌓이다가 누군가는 갚지 못하고, 그로 인해 통화량이 줄어들기 때문에 빚을 갚지 못하고, 계속해서 파산에 파산을 꼬리 물듯이 지속되면서 디플레이션이 오는 것이다.</p><p>이런 디플레이션이 오는 이유 중 하나는 갚을 능력이 되지 않는 사람에게까지 대출해주는 것이다.<br>당장 눈앞의 이익에 눈이 멀어 은행에서 나쁜 짓을 한 것이다.<br>그럼 그 사람들이 줄줄이 빚을 갚지 못해 파산할 것이다.<br>모기지 사태에서 이런 일이 벌어졌다는데 정확하게는 공부해봐야겠다.</p><p>물가가 감소되는 사례를 직접 경험하지 못해서(일본은 실제로 디플레이션이 일어난 적이 있다고 한다.) 맨날 물가는 오르기만 한다(인플레이션)고 불평불만 했는데, 오히려 내리는 것(디플레이션)보다 훨씬 나은 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/why-central-banks-creates-money/thumb.jpg&quot; alt=&quot;돈 많이 벌고싶다...&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://youtu.be/0LYMTsj_eqc&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;EBS 다큐프라임 자본주의 제1부 돈은 빚이다&lt;/a&gt;를 보고 나면 더 많은 인사이트를 얻을 수 있다.&lt;/p&gt;&lt;h2 id=&quot;물가는-왜-상승하는가-feat-인플레이션&quot;&gt;&lt;a href=&quot;#물가는-왜-상승하는가-feat-인플레이션&quot; class=&quot;headerlink&quot; title=&quot;물가는 왜 상승하는가? (feat. 인플레이션)&quot;&gt;&lt;/a&gt;물가는 왜 상승하는가? (feat. 인플레이션)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/why-central-banks-creates-money/demand-and-supply.jpg&quot; alt=&quot;수요와 공급의 원칙을 알고 있는가?&quot;&gt;&lt;/p&gt;&lt;p&gt;수요가 늘어나거나 공급이 줄어들면 가격이 올라간다.(공급 부족)&lt;br&gt;예를 들면 참외 농사가 흉년이 일어나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 5개로 확 줄어들은 상황이거나,&lt;br&gt;어느날 참외가 암을 치료해준다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1000명으로 늘어난 상황이다.&lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"/>
    
    
      <category term="자본주의" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"/>
    
      <category term="재테크" scheme="https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"/>
    
      <category term="인플레이션" scheme="https://perfectacle.github.io/tags/%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"/>
    
      <category term="디플레이션" scheme="https://perfectacle.github.io/tags/%EB%94%94%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"/>
    
      <category term="중앙은행" scheme="https://perfectacle.github.io/tags/%EC%A4%91%EC%95%99%EC%9D%80%ED%96%89/"/>
    
  </entry>
  
  <entry>
    <title>돈은 빚이다.</title>
    <link href="https://perfectacle.github.io/2019/08/15/money-is-debt/"/>
    <id>https://perfectacle.github.io/2019/08/15/money-is-debt/</id>
    <published>2019-08-14T15:08:49.000Z</published>
    <updated>2019-08-22T05:34:24.109Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/money-is-debt/thumb.png" alt="돈은 빚이다."></p><p><a href="https://youtu.be/0LYMTsj_eqc" rel="external nofollow noopener noreferrer" target="_blank">EBS 다큐프라임 자본주의 제1부 돈은 빚이다</a>를 보고 나면 더 많은 인사이트를 얻을 수 있다.</p><h2 id="돈은-어떻게-생성되는가"><a href="#돈은-어떻게-생성되는가" class="headerlink" title="돈은 어떻게 생성되는가?"></a>돈은 어떻게 생성되는가?</h2><p>개인이 돈을 만드는 가장 쉬운 방법은 돈을 버는 것이다.<br>좀 더 큰 관점에서 보면 돈 자체를 찍어내는 은행에서 돈을 만들어야 진정한 의미의 돈이 생성되는 것 같다.<br>하지만 이렇게 은행에서 찍어내는 돈은 실제 <code>통화량(시중에 유통되고 있는 화폐의 양)</code>의 극히 일부이다.<br>대부분의 돈은 <code>눈에 보이지 않는다.</code><br>즉 대부분의 돈은 <code>은행에 존재</code>한다.</p><a id="more"></a><h3 id="최초의-은행"><a href="#최초의-은행" class="headerlink" title="최초의 은행"></a>최초의 은행</h3><p>현재는 돈으로 거래를 하지만 과거 영국에선 금으로 거래를 했다.<br>사람들은 자신의 모든 금을 휴대하기 불편하고, 집에 보관하기도 불안하기 때문에 금 세공업자의 금고에 안전하게 보관해놓았다.<br>그 때는 심지어 보관하는데 보관료까지 냈다.<br>지금 생각해보면 은행에서 <code>너네 돈 안전하게 보관하고 있으니 보관료 내놔</code>하는 형태이다.<br>(언젠가 진짜 이런 세상이 올지도 모른다.)</p><p>그리고 사람들은 휴대하기 불편한 금 대신에 휴대하기 편한 <code>금 보관증</code>으로 거래하기 시작했다.<br>금 보관증만 갖고 있으면 금고로 가서 금으로 바꿀 수 있기 때문에 굳이 금으로 거래할 필요가 줄어든 것이다.<br>여기서 금 세공업자는 이런 생각을 하게 된다.<br><code>한 사람이 와서 자신의 모든 금을 찾는 일은 드물고, 모든 사람이 동시에 몰려오지도 않는다.</code><br>그래서 금고에 놀고있는 금들을 대출해주고 이자를 받아 수익을 창출하기 시작한다.</p><p>이런 소문이 흘러서 금고에 금을 맡긴 사람들에게까지 퍼져나갔다.<br>사람들은 자신의 허락도 없이 마음대로 금을 빌려주고, 이익을 얻는 금 세공업자에게 따지기 시작했다.<br>그러자 금 세공업자는 <code>대출로 얻은 이자의 일부를 주겠다</code>라고 금의 주인들과 딜을 하기 시작했다.<br>금의 주인들도 보관료를 내던 마당에서 오히려 이자를 준다니까 고마운 상황이었다.<br>금 세공업자도 조금은 아쉽지만 보관료만 받기 보다 좀 더 쏠쏠한 대출 이자의 일부를 취하는 쪽을 택했다.</p><p>그런데 얼마 지나지 않아 금 세공업자는 더욱 욕심을 내게 된다.<br><code>내 금고에 금이 얼마나 들어있는지는 나 밖에 모른다.</code>는 전제 하에 있지도 않은 금을 빌려주게 되었다.<br>물론 있지도 않은 금의 실물을 빌려줄 수 없으니 <code>금 보관증</code>을 마구 발행함으로써 있지도 않은 금을 만들게 된 것이다.<br>또한 실물 금을 찾는 사람들이 평균적으로 자신이 맡긴 금의 <code>10%</code>를 찾아간다는 사실에 의거하여 금고의 금보다 실제로 <code>10배</code>가 많은 금 보관증을 발행하였다.</p><p>시간이 지나자 이런 소문도 다시 흘러서 금 보관증을 갖고 있는 사람들의 귀에 들어갔다.<br>결국 금 세공업자를 의심한 부자들은 자신의 금을 모두 찾아갔고, 뒤늦게 금 보관증을 들고 온 사람들은 이미 금고는 텅 비었기 때문에 금을 받을 수 없었다.</p><p>이런 사태를 <code>뱅크런(Bankrun, 은행에 돈을 맡긴 사람들이 동시에 돈을 찾는 현상)</code>이라 부르며 현대의 우량한 은행들 조차 뱅크런을 맞으면 파산에 이르게 된다.</p><h3 id="현재의-은행"><a href="#현재의-은행" class="headerlink" title="현재의 은행"></a>현재의 은행</h3><p>최초의 은행과 마찬가지로 은행은 돈이 생기면 대출을 해주고 이자를 통해 수익을 얻어낸다.<br>그리고 그 이자의 일부를 예금자에게 돌려주는 형태도 마찬가지이다.</p><p>하지만 최초의 은행이 10배의 돈을 대출해 줄 수 있던 점과는 다른 점이 있는데 바로 <code>지급 준비율(은행은 예금액의 10%를 지급할 준비, 즉 보유하고 있어야한다.)</code>이다.<br>은행은 지급 준비율이 10%가 돼야한다는 토대를 마련한 게 최초의 은행에서 말한 <strong>사람들이 평균적으로 자신이 맡긴 금의 <code>10%</code>를 찾아간다</strong>는 사실을 바탕으로 만들어졌다. (우리나라의 평균 지급 준비율은 3.5%이다, 즉 더 많은 돈을 빌려줄 수 있다.)</p><p>이 지급 준비율 때문에 시중에는 없던 돈이 탄생한다.<br>간단하게 A가 은행에 100원을 예금했다고 생각해보자.<br>그럼 지급 준비율 10%에 의해 은행은 10원만 은행에 남겨두고 B에게 90원을 대출해준다.<br>이제 <code>통화량</code>은 190원이 된다.<br>여기서 90원의 없던 돈이 생겨났고, 이 돈을 <code>신용통화</code>라고 부른다.</p><p>간단한 계산을 통해 100원이란 돈이 얼만큼 불어나는지 계산해보자.</p><table><thead><tr><th>은행명</th><th>예금액</th><th>대출액</th><th>잔여 예금액</th></tr></thead><tbody><tr><td>A</td><td>100</td><td>90</td><td>10</td></tr><tr><td>B</td><td>90</td><td>81</td><td>9</td></tr><tr><td>C</td><td>81</td><td>72</td><td>9</td></tr><tr><td>D</td><td>72</td><td>64</td><td>8</td></tr><tr><td>E</td><td>64</td><td>57</td><td>7</td></tr><tr><td>F</td><td>57</td><td>51</td><td>6</td></tr><tr><td>G</td><td>51</td><td>45</td><td>6</td></tr><tr><td>H</td><td>45</td><td>40</td><td>5</td></tr><tr><td>I</td><td>40</td><td>36</td><td>4</td></tr><tr><td>J</td><td>36</td><td>32</td><td>4</td></tr><tr><td>K</td><td>32</td><td>28</td><td>4</td></tr><tr><td>L</td><td>28</td><td>25</td><td>3</td></tr><tr><td>M</td><td>25</td><td>22</td><td>3</td></tr><tr><td>N</td><td>22</td><td>19</td><td>3</td></tr><tr><td>O</td><td>19</td><td>17</td><td>2</td></tr><tr><td>P</td><td>17</td><td>15</td><td>2</td></tr><tr><td>Q</td><td>15</td><td>13</td><td>2</td></tr><tr><td>R</td><td>13</td><td>11</td><td>2</td></tr><tr><td>S</td><td>11</td><td>9</td><td>2</td></tr><tr><td>T</td><td>9</td><td>8</td><td>1</td></tr><tr><td>U</td><td>8</td><td>7</td><td>1</td></tr><tr><td>V</td><td>7</td><td>6</td><td>1</td></tr><tr><td>W</td><td>6</td><td>5</td><td>1</td></tr><tr><td>X</td><td>5</td><td>4</td><td>1</td></tr><tr><td>Y</td><td>4</td><td>3</td><td>1</td></tr><tr><td>Z</td><td>3</td><td>2</td><td>1</td></tr><tr><td>AA</td><td>2</td><td>1</td><td>1</td></tr><tr><td>AB</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>100 + 90 + 81 + 72 + 64 + 57 + 51 + 45 + 40 + 36 + 32 + 28 + 25 + 22 + 19 + 17 + 15 + 13 + 11 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 863원</p><p>정확한 계산인지는 모르겠으나 소수점까지 더하면 더 늘어날 것이다.<br>즉 원래 통화량은 100원이었는데 신용통화 763원이 추가되어 통화량은 863원이 됐다.<br>이것이 바로 통화량 대부분의 돈이 생성되는 과정이다.</p><p>지급 준비율이 낮아지면 더 많은 돈을 생성할 수 있다(통화량 증가).</p><h2 id="돈은-빚이다"><a href="#돈은-빚이다" class="headerlink" title="돈은 빚이다."></a>돈은 빚이다.</h2><p>은행은 지급 준비율을 제외한 모든 예금액을 대출해주려고 한다.<br>왜냐하면 이자를 통해 이익을 창출해내기 때문이다.<br>따라서 은행 입장에서는 어떻게든지 간에 대출을 해주고 싶어한다.<br>왜냐하면 은행에서 돈이 놀고 있으면 돈을 벌 수 없기 때문이다.</p><p>그럼 왜 돈은 빚인지 알아보자.</p><ol><li>A가 은행에 100원을 예금했다고 생각해보자.<br>(A 은행의 잔여 예금액 <code>100원</code>, 통화량 <code>100원</code>)</li><li>그럼 지급 준비율 10%에 의해 은행은 10원만 은행에 남겨두고 B에게 90원을 대출해준다.<br>(은행의 잔여 예금액 <code>10원</code>, 통화량 <code>190원</code>)</li></ol><p>위와 같이 통화량 90원은 신용통화로 B가 진 빚에 해당한다.<br>즉, 90원은 실제 은행에서 찍어낸 돈이 아닌 빚이다.<br>즉, 돈은 빚이 됐다.</p><p>위 상황에서 만약 A가 예금액 100원을 찾으려고 하면 어떻게 될까?<br>은행은 예금액을 가지고 있지 않으므로 파산하게 된다.<br>아무리 우량한 은행이라도 뱅크런이 발생하게 되면 파산하게 된다.<br>이런 뱅크런 사태는 금융위기 때 사람들이 한 번에 현금을 찾으러 오면서 발생한다고 알고 있다.<br>대부분 이런 뱅크런 사태는 일어나지 않기 때문에 사람들의 예금액은 은행에 존재하지 않고, 다 대출돼있다.<br>즉, 새로운 <code>빚</code>으로써 새로운 <code>돈</code>이 탄생하게 되는 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/money-is-debt/thumb.png&quot; alt=&quot;돈은 빚이다.&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://youtu.be/0LYMTsj_eqc&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;EBS 다큐프라임 자본주의 제1부 돈은 빚이다&lt;/a&gt;를 보고 나면 더 많은 인사이트를 얻을 수 있다.&lt;/p&gt;&lt;h2 id=&quot;돈은-어떻게-생성되는가&quot;&gt;&lt;a href=&quot;#돈은-어떻게-생성되는가&quot; class=&quot;headerlink&quot; title=&quot;돈은 어떻게 생성되는가?&quot;&gt;&lt;/a&gt;돈은 어떻게 생성되는가?&lt;/h2&gt;&lt;p&gt;개인이 돈을 만드는 가장 쉬운 방법은 돈을 버는 것이다.&lt;br&gt;좀 더 큰 관점에서 보면 돈 자체를 찍어내는 은행에서 돈을 만들어야 진정한 의미의 돈이 생성되는 것 같다.&lt;br&gt;하지만 이렇게 은행에서 찍어내는 돈은 실제 &lt;code&gt;통화량(시중에 유통되고 있는 화폐의 양)&lt;/code&gt;의 극히 일부이다.&lt;br&gt;대부분의 돈은 &lt;code&gt;눈에 보이지 않는다.&lt;/code&gt;&lt;br&gt;즉 대부분의 돈은 &lt;code&gt;은행에 존재&lt;/code&gt;한다.&lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"/>
    
    
      <category term="자본주의" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"/>
    
      <category term="재테크" scheme="https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"/>
    
  </entry>
  
  <entry>
    <title>(Java) 람다 캡처링과 final 제약조건</title>
    <link href="https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/"/>
    <id>https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/</id>
    <published>2019-06-30T05:18:57.000Z</published>
    <updated>2019-08-22T05:02:20.358Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java-8-lambda-capturing/thumb.png" alt=""></p><p>람다의 바디에서는 파라미터 말고 바디 외부에 있는 변수를 참조할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaCapturing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable r = () -&gt; System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable r2 = () -&gt; System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>이렇게 람다 시그니처의 <strong>파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수</strong>를 <strong>자유 변수(Free Variable)</strong>라고 부른다.<br>또한 람다 바디에서 <strong>자유 변수를 참조하는 행위</strong>를 유식한 말로 <strong>람다 캡처링(Lambda Capturing)</strong>이라고 부른다.</p><h2 id="람다-캡처링의-제약-조건"><a href="#람다-캡처링의-제약-조건" class="headerlink" title="람다 캡처링의 제약 조건"></a>람다 캡처링의 제약 조건</h2><p>지역 변수를 람다 캡처링 할 때 아래 두 가지 제약조건이 존재한다.</p><ol><li>지역변수는 final로 선언돼있어야한다.</li><li>final로 선언되지 않은 지역변수는 final처럼 동작해야한다.<br>즉, 값의 재할당이 일어나면 안 된다.  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaCapturing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 인스턴스 변수 a는 final로 선언돼있을 필요도, final처럼 재할당하면 안된다는 제약조건도 적용되지 않는다.</span></span><br><span class="line">            a = <span class="number">123</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 지역변수 b는 final로 선언돼있기 때문에 OK</span></span><br><span class="line">        <span class="keyword">final</span> Runnable r2 = () -&gt; System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 지역변수 c는 final로 선언돼있지 않지만 final을 선언한 것과 같이 변수에 값을 재할당하지 않았으므로 OK</span></span><br><span class="line">        <span class="keyword">final</span> Runnable r3 = () -&gt; System.out.println(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 지역변수 d는 final로 선언돼있지도 않고, 값의 재할당이 일어났으므로 final처럼 동작하지 않기 때문에 X</span></span><br><span class="line">        d = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">final</span> Runnable r4 = () -&gt; System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="왜"><a href="#왜" class="headerlink" title="왜??"></a>왜??</h2><p>왜 이런 제약조건이 생기게 돼었을까?<br>왜 인스턴스 변수에는 이런 제약조건이 없는 걸까?  </p><p>우선 JVM의 메모리 구조를 알아야한다.<br>JVM에서 지역 변수는 스택이라는 영역에 생성된다.<br>그리고 실제 메모리와는 달리 JVM에서 스택 영역은 쓰레드마다 별도의 스택이 생성된다.<br>따라서 지역 변수는 <strong>쓰레드끼리 공유가 안 된다.</strong><br>JVM에서 인스턴스 변수는 힙 영역에 생성된다.<br>인스턴스 변수는 <strong>쓰레드끼리 공유가 가능하다.</strong></p><p>람다는 별도의 쓰레드에서 실행이 가능하다.<br>따라서 원래 지역 변수가 있는 쓰레드는 사라져서 해당 지역변수가 사라졌는데도 불구하고,<br>람다가 실행 중인 쓰레드는 살아있을 가능성이 있다.<br>하지만 이 람다에서 사라진 쓰레드의 지역변수를 참조하고 있으면 어떻게 될까?<br>당연히 오류가 날 것이다. 하지만 우리의 예상과는 달리 오류는 나지 않는다.<br>또한 별도의 쓰레드에서 실행된다면 별도의 스택 영역을 가질테고, 그럼 다른 쓰레드의 스택에 있는 지역변수는 참조조차 할 수 없다.<br>왜 오류는 나지 않고, 어떻게 다른 쓰레드의 스택 영역에 있는 지역 변수를 참조할 수 있는 걸까?<br>이는 람다에서 지역 변수(해당 쓰레드의 스택)에 직접적으로 접근하는 게 아니라 변수를 자신(쓰레드)의 스택에 복사하기 때문이다.<br>그렇기 때문에 별도의 쓰레드의 스택에 있는 지역 변수와 동일한 값을 참조할 수 있는 거고, 원래 쓰레드가 사라져도 본인의 쓰레드에서 자신의 할 일을 착실히 수행할 수 있는 것이다.<br>하지만 위와 같이 변수를 복사해서 쓰는데 그 변수의 값이 중구난방으로 변경된다고 하면 해당 복사본을 믿고 쓸 수 있을까?<br>따라서 지역 변수에는 final이어야하거나 final 같이 동작해야한다는 제약 조건이 생긴 것이다.</p><p>그렇다면 인스턴스 변수는 왜 이런 조건이 없는 걸까?<br>이는 인스턴스 변수는 힙에 존재하고, 쓰레드끼리 공유도 가능하기 때문에 별도로 복사할 필요도 없고, 직접 힙에 접근해서 사용하면 되기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/java-8-lambda-capturing/thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;람다의 바디에서는 파라미터 말고 바디 외부에 있는 변수를 참조할 수 있다.&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LambdaCapturing&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Runnable r = () -&amp;gt; System.out.println(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Runnable r2 = () -&amp;gt; System.out.println(b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="Lambda" scheme="https://perfectacle.github.io/tags/Lambda/"/>
    
      <category term="Java8" scheme="https://perfectacle.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>어노테이션이 달린 빈의 자동 스캔 (Without Spring Boot)</title>
    <link href="https://perfectacle.github.io/2019/06/23/auto-scanning-annotation-based-bean/"/>
    <id>https://perfectacle.github.io/2019/06/23/auto-scanning-annotation-based-bean/</id>
    <published>2019-06-23T03:08:10.000Z</published>
    <updated>2019-08-22T02:27:36.598Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/auto-scanning-annotation-based-bean/thumb.png" alt=""></p><p>스프링 부트부터 접한 스프링 알못이라 스프링에 대해 공부를 하다보니 너무나 모르고 있는 게 많아서 정리해봤다.<br>되게 간단한 건데 스프링 부트부터 접하면 몰라도 코드 짜는데는 문제가 없지만 개인적으로는 알고 있으면 너무나 좋은 내용같다.</p><h2 id="어노테이션-없이-빈-설정"><a href="#어노테이션-없이-빈-설정" class="headerlink" title="어노테이션 없이 빈 설정"></a>어노테이션 없이 빈 설정</h2><p>스프링이 관리하는 객체인 빈으로 생성하기 위해서 아래와 같은 어노테이션이 필수<strong>인 줄 알았</strong>다.<br>@Component, @Configuration, @Bean, @Service, @Controller, @Repository</p><a id="more"></a><p>하지만 직접 코딩을 해보니 이 생각은 거짓이었다.</p><p>우선 느슨한 결합을 위해 인터페이스를 하나 선언한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>인터페이스의 구현체도 하나 만들어준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimonOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>해당 구현체를 의존성으로 갖는 다른 구현체도 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 스프링 4.3부터 생성자가 하나이면 @Autowired 어노테이션이 생략 가능하다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService orderSe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = orderSe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 의존성 주입이 제대로 됐는지 테스트하기 위한 용도의 getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 CoupangOrderService 빈이 제대로 생성되는지 테스트 코드를 작성해보자. (JUnit5를 사용하였다.)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;CoupangOrderService.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트를 실행하면 circular reference(순환 참조) 때문에 빈을 생성할 수 없는 오류가 난다.<br><code>Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;coupangOrderService&#39;: Requested bean is currently in creation: Is there an unresolvable circular reference?</code>  </p><p>CoupangOrderService는 OrderService 인터페이스를 의존성으로 받는데 그 구현체가 CoupangOrderService 자신 밖에 없기 때문이다.<br>(@ContextConfiguration(classes = {CoupangOrderService.class})에 의해 ApplicationContext에서는 CoupangOrderService 밖에 모르기 때문이다.)</p><p>그럼 ApplicationContext가 OrderService의 다른 구현체인 TimonOrderService까지 알게 해주자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;CoupangOrderService.class, TimonOrderService.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트는 성공한다.<br>우리는 빈에 대한 어노테이션을 인터페이스나 구현체 어디에도 사용을 하지 않았는데 빈의 생성도 잘 이뤄졌고, 의존성 주입도 아주 잘 되었다.<br>CoupangOrderService에서 OrderService를 의존성 주입 받는데 OrderService의 구현체는 CoupangOrderService와 TimonOrderService 두 개이다.<br>하지만 스프링에서는 똑똑하게 순환참조 이슈를 피하려고 본인을 제외하고 빈을 찾기 때문에 순환참조 오류가 안 났다.  </p><p>한 번 위 가설이 맞는지 검증해보자.<br>OrderService의 구현체를 하나 더 만들어보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeMakePriceOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트를 돌려보면 아래와 같이 CoupangOrderService에 OrderService를 주입하는데 TimonOrderService를 주입해야할지, WeMakePriceOrderService를 주입해야할지 모른다는 오류가 나온다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;CoupangOrderService.class, TimonOrderService.class, WeMakePriceOrderService.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;OrderService&#39; available: expected single matching bean but found 2: timonOrderService,weMakePriceOrderService</code></p><p>OrderService의 구현체는 세 개인데 당연스레 본인(CoupangOrderService)는 빼고 의존성 주입을 시도한 것이다.<br>그럼 위 테스트는 왜 실패한 것인가?<br>기본적으로 스프링은 아래와 같은 순서로 DI를 하게 된다.  </p><ol><li>빈의 타입으로 빈을 검색해서 주입한다.  </li><li>해당 빈의 타입이 두 개 이상이면 빈의 이름으로 검색해서 주입한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService orderSe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.otherService = orderSe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderService의 빈은 2개(CoupangOrderService 본인을 제외하고)라서 빈의 이름으로 검색을해야하는데 <strong>orderSe</strong>라는 이름의 빈은 없기 때문이다.<br>빈의 이름은 기본적으로 클래스 이름을 기반으로 생성된다. <del>(규칙은 나중에 찾아보는 걸로…)</del>  </p><p>이제 테스트가 성공하게 제대로 된 빈의 이름으로 바꿔주자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 스프링 4.3부터 생성자가 하나이면 @Autowired 어노테이션이 생략 가능하다.</span></span><br><span class="line">    <span class="comment">// 파라미터로 넘긴 변수 이름이 빈의 이름이 된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService timonOrderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = timonOrderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="빈-자동-스캔"><a href="#빈-자동-스캔" class="headerlink" title="빈 자동 스캔"></a>빈 자동 스캔</h2><p>우리가 생성한 빈이 많으면 많을 수록 @ContextConfiguration에 다 등록해주기도 부담이다.<br>이럴 때 쓰는 게 @Service, @Component, @Configuration, @Bean과 같은 어노테이션들이다.</p><p>우선 인터페이스와 구현체 어디다 쓰는 게 좋은지 모르니 다 붙여놓자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimonOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeMakePriceOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService timonOrderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = timonOrderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 빈을 자동으로 스캔해주는 빈을 만들어주자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"some.package"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>해당 패키지에 있는 @Service, @Component, @Configuration, @Bean 요런 어노테이션들이 붙은 빈들은 자동으로 스캔하고 생성해주는 어노테이션이다.<br><del>(자세한 건 나중에 또 알아보자 ㅠㅠ)</del></p><p>이제 테스트에서 Bean 클래스들을 한땀 한땀 넣어주는 부분을 수정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;ComponentScanConfig.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Config 파일 하나로 코드가 너무나 쾌적해졌다.<br>이렇게 빈을 자동으로 스캔하고 생성할 때는 <strong>@ComponentScan</strong> 어노테이션이 엄청 큰 도움이 된다.  </p><h2 id="어노테이션은-인터페이스에-구현체에"><a href="#어노테이션은-인터페이스에-구현체에" class="headerlink" title="어노테이션은 인터페이스에? 구현체에?"></a>어노테이션은 인터페이스에? 구현체에?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>어노테이션을 인터페이스에<strong>만</strong> 붙이면 구현체 타입으로 DI를 받을 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;ComponentScanConfig.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//    CoupangOrderService 타입의 빈은 @Service 어노테이션이 안 달려있어서 @ComponentScan에서 검색되지 못한다.    </span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private CoupangOrderService coupangOrderService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line"><span class="comment">//        OrderService 인터페이스에는 getOtherService() 메서드가 없다.</span></span><br><span class="line"><span class="comment">//        assertNotNull(coupangOrderService.getOtherService());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 이번엔 빈을 생성하지 못한다는 에러가 나온다.<br><code>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;example.domain.OrderService&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}</code><br>왜냐면 인터페이스만 @Service 어노테이션을 붙여서 빈으로 생성이 되는데 인터페이스는 객체로 생성이 불가능하기 때문에 위와 같은 오류가 나는 것이다.  </p><p>그럼 이번엔 구현체에만 @Service 어노테이션을 붙이면 어떻게 될까?  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService timonOrderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = timonOrderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트를 고쳐보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;ComponentScanConfig.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//    CoupangOrderService는 OrderService를 구현한 것이므로 OrderService 타입으로도 DI 받을 수 있다.</span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private OrderService coupangOrderService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 돌리면 또 순환참조 오류로 실패한다.<br><code>Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;coupangOrderService&#39;: Requested bean is currently in creation: Is there an unresolvable circular reference?</code></p><p>다른 OrderService 구현체에도 @Service 어노테이션을 붙여주자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimonOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeMakePriceOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트를 돌리면 정상적으로 돌아간다.</p><p>인터페이스에 어노테이션 안 붙여도 인터페이스 타입으로 느슨하게 결합해서 DI도 가능하고, 특정 구현체에 기능이 쓰고 싶다면 해당 구현체 타입으로 DI도 가능하고…<br>따라서 내가 봤을 때는 인터페이스에 어노테이션을 붙여놓는 건 딱히 의미가 없는 것 같다. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/auto-scanning-annotation-based-bean/thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;스프링 부트부터 접한 스프링 알못이라 스프링에 대해 공부를 하다보니 너무나 모르고 있는 게 많아서 정리해봤다.&lt;br&gt;되게 간단한 건데 스프링 부트부터 접하면 몰라도 코드 짜는데는 문제가 없지만 개인적으로는 알고 있으면 너무나 좋은 내용같다.&lt;/p&gt;&lt;h2 id=&quot;어노테이션-없이-빈-설정&quot;&gt;&lt;a href=&quot;#어노테이션-없이-빈-설정&quot; class=&quot;headerlink&quot; title=&quot;어노테이션 없이 빈 설정&quot;&gt;&lt;/a&gt;어노테이션 없이 빈 설정&lt;/h2&gt;&lt;p&gt;스프링이 관리하는 객체인 빈으로 생성하기 위해서 아래와 같은 어노테이션이 필수&lt;strong&gt;인 줄 알았&lt;/strong&gt;다.&lt;br&gt;@Component, @Configuration, @Bean, @Service, @Controller, @Repository&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end" scheme="https://perfectacle.github.io/categories/Back-end/"/>
    
      <category term="Spring" scheme="https://perfectacle.github.io/categories/Back-end/Spring/"/>
    
    
      <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
      <category term="Bean" scheme="https://perfectacle.github.io/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) 내 로컬에서는 잘 되는데...? (내로잘)</title>
    <link href="https://perfectacle.github.io/2019/06/11/aws-sg-trobuleshooting/"/>
    <id>https://perfectacle.github.io/2019/06/11/aws-sg-trobuleshooting/</id>
    <published>2019-06-11T13:28:23.000Z</published>
    <updated>2019-08-22T02:48:30.047Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/aws-sg-trobuleshooting/thumb.jpg" alt="미리보는 교훈: 남탓을 하지 말자"></p><p><img src="/images/aws-sg-trobuleshooting/reporter.png" alt="오늘도 어김없이 외부를 통해 장애가 제보되었다."><br><img src="/images/aws-sg-trobuleshooting/work-on-my-local.png" alt="하지만 내 로컬에서는 잘 됐다. (이럴 때 쓰는 말이 내로잘, 내 로컬에서는 잘 되는데...?)"><br>내 PC에서는 잘 되는데 버그 제보자가 직접 모바일 웹에서 안 되는 걸 보여줬다.<br>그리고 내 모바일에서도 해봤고, 다른 사람들의 모바일에서도 전부 안 됐다. (안드로이드, iOS에서 크롬, 사파리, 삼성 인터넷 가릴 것 없이 다 안 됐다.)  </p><p>PC에서는 잘 되고, 모바일에서는 안 된다… 나는 당연히 프론트 이슈로 여겼다.<br>혹시 서버 쪽 이슈일까봐 액세스 로그를 모니터링해보니 헬스 체크 이외에 로그가 안 찍히길래 자바스크립트 어딘가에서 오류가 나서 API 호출도 못 하는 거라고 확신했다.  </p><a id="more"></a><p>프론트 개발자 분께서 모바일 브라우저 디버깅을 위해 세팅도 다 했는데 브라우저의 콘솔을 보니 에러 로그가 안 찍히는 것이었다.<br><img src="/images/aws-sg-trobuleshooting/charles.png" alt="그리고 혹시나 싶어서 프론트 개발자 분께서 Charles까지 깔아서 확인도 해주셨는데 패킷도 날아가지 않았다.">  </p><p>귀신이 곡할 노릇이라 환경을 완전히 통일시키기 위해 도커로 띄워야하나… 이런 고민까지 하고 있던 찰나에<br>프론트 개발자 분께서 내가 접속한 와이파이(사내 와이파이)와 자신이 모바일로 접속한 와이파이(게스트용 와이파이)의 차이점을 발견하였다.<br>(사내 정책 때문에 모바일에서는 게스트용 와이파이를 쓰고 있었다.)  </p><p><img src="/images/aws-sg-trobuleshooting/security-group.png" alt="뭔가 촉이 와서 Security Group을 전부 오픈했더니 문제가 해결되었다.">  </p><h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p><img src="/images/aws-sg-trobuleshooting/why-work-why-not-work.png" alt=""><br>우선 상황은 이랬다.  </p><ul><li>초반에 상품 10개는 잘 불러온다. (왜 잘 불러와지지?)  </li><li>추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다. (왜 안 불러와지지?)</li></ul><p>계속 고뇌에 빠졌고, 결국 네트워크 지식이 부족한 탓에 이런 일이 일어났었다.</p><h3 id="초반에-상품-10개는-잘-불러온다"><a href="#초반에-상품-10개는-잘-불러온다" class="headerlink" title="초반에 상품 10개는 잘 불러온다."></a>초반에 상품 10개는 잘 불러온다.</h3><p>우선 프론트 엔드에서 렌더링을 빠르게 하려는 이유에서인지 SSR(Server Side Rendering)을 사용했다.<br><img src="/images/aws-sg-trobuleshooting/ssr.png" alt="출처: https://medium.com/walmartlabs/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8"><br>일반적인 CSR(Client Side Rendering)에서는 클라이언트 측에서 AJAX 방식으로 API를 호출했다면,<br>SSR은 클라이언트 측에서 렌더링이 되기 전에 필요한 데이터가 모두 갖춰진 상태로 서버에서 HTML 파일을 내려주는 형태이다.<br>즉, API 호출이 서버에서 일어난다. (이는 <strong>Server to Server</strong>로 API 호출이 일어남을 의미한다.)  </p><p><img src="/images/aws-sg-trobuleshooting/server-to-server-bad.png" alt="Server to Server를 위해서 Public IP를 쓰면 네트워크 밖을 나갔다 들어오기 때문에 레이턴시와 비용이 추가될 수 밖에 없다."><br><img src="/images/aws-sg-trobuleshooting/internal.png" alt="따라서 Server to Server를 위해서는 Internal ELB를 통해 Private IP로만 통신하고 있다."><br><img src="/images/aws-sg-trobuleshooting/internal-sg.png" alt="내부 통신을 위한 Internal ELB의 경우에는 동일한 VPC 내의 요청이라면 허용하도록 Security Group을 구성했다.">  </p><p>위와 같이 Security Group을 세팅하고, 초반에 불러오는 상품은 SSR의 특성상 Server to Server로 호출하기 때문에 API 호출이 성공했던 것이다.</p><h3 id="추가로-상품-10개를-더-불러오려고-하면-불러와지지-않는다"><a href="#추가로-상품-10개를-더-불러오려고-하면-불러와지지-않는다" class="headerlink" title="추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다."></a>추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다.</h3><p><img src="/images/aws-sg-trobuleshooting/inbound-mistake.png" alt="나는 이 경우도 Front 서버와 API 서버가 Server to Server로 통신하는 걸로 착각을 했다."><br><img src="/images/aws-sg-trobuleshooting/inbound-real.png" alt="하지만 Front 서버를 경유하지 않고 클라이언트(브라우저)에서 바로 API 서버를 호출하고 있었다."><br><img src="/images/aws-sg-trobuleshooting/public-elb-sg.png" alt="나는 API 서버의 Public ELB는 개발 환경에서만 접근한다고 생각하고 위와같이 구성했었다."><br>위와 같이 구성하니 개발환경이 아닌 경우(게스트 와이파이나 LTE 등등)에는 API 호출이 실패하는 것이었다.<br>이래서 내 로컬(사내 와이파이)에서는 잘 되는데, 버그 제보자의 모바일(게스트 와이파이)에서는 장애가 재현된 것이다.<br>즉, 초기 SSR로 호출하는 API(Server to Server 방식)을 제외하고는 제대로 API 호출이 안 되는 상황이었다.  </p><p>따라서 모든 IP에 대해서 API에 대한 접근을 허용할 수 밖에 없었다.<br>(추후에는 Front 서버를 통해서만 통신하게 끔 변경해야할 것이다.) </p><h2 id="오늘의-교훈은-뭘까-요"><a href="#오늘의-교훈은-뭘까-요" class="headerlink" title="오늘의 교훈은 뭘까~요?"></a>오늘의 교훈은 뭘까<del>~</del>요?</h2><p><img src="/images/aws-sg-trobuleshooting/pokemon.jpg" alt="피..피카츄!!"><br>오늘 느낀 점은 <strong>남탓</strong>을 하지 말자 이다.<br>나는 당연히 프론트 이슈일 줄 알고 뒷짐지고 있었다.<br>그러는 와중에 프론트 개발자 분은 모바일 디버깅 환경까지 세팅하고, Charles(패킷 캡쳐 도구)까지 깔아서 오류를 분석해주셨다.<br>심지어 이번 이슈의 핵심인 와이파이가 다르다는 점까지 발견해주셨다.<br>그동안 나는 뒷짐을 지고 있었다. <del>(그렇다고 일을 안 하고 있던 건 아니고…)</del><br>프론트 개발자 분께서는 충분히 화가 날 수도 있는 상황이었다.<br>그 분의 바쁜 시간을 본인의 이슈가 아닌데도 불구하고 열심히 삽질을 했으니 말이다.  </p><p>요즘 들어 이 이슈, 저 이슈에 관여를 하면서 <code>아... 내가 이 이슈까지 봐야할까? 내가 하고 있는 일이랑은 관련이 적어보이는데...</code>하고 소극적인 태도를 많이 보였다.<br>하지만 이번 일을 계기로 이런 생각을 고쳐먹어야겠다고 다짐했다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/aws-sg-trobuleshooting/thumb.jpg&quot; alt=&quot;미리보는 교훈: 남탓을 하지 말자&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/aws-sg-trobuleshooting/reporter.png&quot; alt=&quot;오늘도 어김없이 외부를 통해 장애가 제보되었다.&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/aws-sg-trobuleshooting/work-on-my-local.png&quot; alt=&quot;하지만 내 로컬에서는 잘 됐다. (이럴 때 쓰는 말이 내로잘, 내 로컬에서는 잘 되는데...?)&quot;&gt;&lt;br&gt;내 PC에서는 잘 되는데 버그 제보자가 직접 모바일 웹에서 안 되는 걸 보여줬다.&lt;br&gt;그리고 내 모바일에서도 해봤고, 다른 사람들의 모바일에서도 전부 안 됐다. (안드로이드, iOS에서 크롬, 사파리, 삼성 인터넷 가릴 것 없이 다 안 됐다.)  &lt;/p&gt;&lt;p&gt;PC에서는 잘 되고, 모바일에서는 안 된다… 나는 당연히 프론트 이슈로 여겼다.&lt;br&gt;혹시 서버 쪽 이슈일까봐 액세스 로그를 모니터링해보니 헬스 체크 이외에 로그가 안 찍히길래 자바스크립트 어딘가에서 오류가 나서 API 호출도 못 하는 거라고 확신했다.  &lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="AWS" scheme="https://perfectacle.github.io/tags/AWS/"/>
    
      <category term="Network" scheme="https://perfectacle.github.io/tags/Network/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) Thread Dump 분석 도전기</title>
    <link href="https://perfectacle.github.io/2019/06/11/thread-dump-analyze/"/>
    <id>https://perfectacle.github.io/2019/06/11/thread-dump-analyze/</id>
    <published>2019-06-10T16:19:36.000Z</published>
    <updated>2019-08-22T05:54:34.669Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/thread-dump-analyze/thumb.png" alt="쓰레드 덤프도 처음인지라 하면서 뭔가 두려웠다."></p><h2 id="사건의-시작"><a href="#사건의-시작" class="headerlink" title="사건의 시작"></a>사건의 시작</h2><p><img src="/images/thread-dump-analyze/alert.png" alt="평화로운 어느날, Alert Manager의 역습"><br>갑자기 Nginx가 Down 됐다는 알림이 와서 해당 서버로 접속해보니 Nginx 서비스는 정상적으로 떠있고…<br>curl도 때려보고, 브라우저에서 직접 URL로 접속해봤을 때 문제가 없었다.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># blackbox exporter configuration</span></span><br><span class="line"><span class="attr">modules:</span></span><br><span class="line"><span class="attr">  http_health:</span></span><br><span class="line"><span class="attr">    prober:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">      valid_status_codes:</span> <span class="string">[200]</span></span><br><span class="line"><span class="attr">      preferred_ip_protocol:</span> <span class="string">"ip4"</span></span><br><span class="line"><span class="attr">      ip_protocol_fallback:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>80포트에 대해서 http 요청을 보냈을 때 5초 이내에 200 OK가 안 오면 알람을 발생시키게 했는데 내가 테스트 해 본 바로는 아무런 문제도 없었다.<br>(일단 5초라는 관대한 시간으로 걸어놓은 것도 문제였고, 내가 간단히 메인 페이지만 몇 번 들락날락 해본 것도 문제였다.)</p><p>따라서 <code>나는 Alert Manager가 오작동하나 보다... 역시 내가 이 쪽 경험이 부족하다보니 뭔가 잘못 셋팅했나 보다.</code>하며 대수롭지 않게 넘겼다.</p><h2 id="불행의-시작"><a href="#불행의-시작" class="headerlink" title="불행의 시작"></a>불행의 시작</h2><p><img src="/images/thread-dump-analyze/begin-unlucky.png" alt="우리가 먼저 알아차리려고 모니터링 시스템을 열심히 구축했는데 또 외부에서 먼저 제보를 받게 되었다."></p><p>우선 열심히 구축해놓은 모니터링 시스템을 굴릴 수 없으니 EC2 인스턴스 및 JVM 메모리에 대한 지표를 살펴보았다.<br>우선 인스턴스의 CPU나 메모리는 문제가 없었고 JVM 메모리나 GC 쪽에도 문제가 없었다.</p><p><img src="/images/thread-dump-analyze/http-5xx.png" alt="내가 최초로 알림을 받기 시작한 23분 쯤부터 5xx가 점점 발생하기 시작했다."><br><img src="/images/thread-dump-analyze/thread-monitoring.png" alt="쓰레드를 점점 많이 쓰더니 가용 가능한 쓰레드를 전부 쓰고 있었다.">  </p><p><img src="/images/thread-dump-analyze/cto-jjam.png" alt="CTO 님께서는 짬에서 나오는 바이브를 물씬 풍겨주었다."><br>나는 쓰레드 쪽에 문제가 있으니 우선 쓰레드 덤프부터 뜨고 봐야하나? 이 생각이었는데 저 지표를 보자마자 저런 생각이 떠오른다는 건 역시 경험은 무시할 수가 없는 것 같다.</p><p><img src="/images/thread-dump-analyze/rds-cpu.png" alt="해당 시간대의 AWS RDS의 CPU 사용량을 보니 100%를 치고 있었다."></p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>우선 DB 쪽에 장애가 서버까지 전파된 걸 확인했으니 서버 쪽에서 어떤 쿼리를 수행하길래 저런 에러가 나오는지 봐야했다.<br>쓰레드 쪽에 문제가 있다고 판단했으니 우선 jstack으로 쓰레드 덤프를 뜨고 별도의 툴을 깔지 않고 온라인(<a href="https://fastthread.io/" rel="external nofollow noopener noreferrer" target="_blank">fastThread</a>)에서 쓰레드 덤프를 분석해봤다.  </p><p><img src="/images/thread-dump-analyze/thread-group.png" alt="http-nio-8080-exec-xxx 이런 쓰레드 118개나 TIMED_WAITING 상태였다."><br><img src="/images/thread-dump-analyze/http-nio-8080-exec-xxx.png" alt=""><br>나는 뭔가 어플리케이션 코드가 스택 트레이스에 찍혀있길 기대했지만 그런 건 없었다.<br>일단 쓰레드 네임을 보아하니 http 요청에 의한 것으로 판단되니 Nginx의 Access Log를 뒤져보면 뭔가 나오지 않을까 싶었다.  </p><p><img src="/images/thread-dump-analyze/nginx-access-log.png" alt="다른 요청들 사이에 껴서 혼자 8 ~ 9초 정도 처리 시간이 걸렸다."><br>파라미터에도 ALL 하나만 들어가있는 걸 보면 뭔가 전체 조회를 하는 구린 냄새가 나는 코드 같다.<br>눈여겨 볼 점은 처음 발생한 시점이다.<br>11시 20분에 저렇게 느린 요청들이 발생하기 시작했는데, 내가 알람을 받은 건 23분부터 받기 시작했다.<br>아마 5초라는 관대한 시간을 줬기 때문에 더 알람을 늦게 받게된 게 아닌가 싶다.  </p><p><img src="/images/thread-dump-analyze/nginx-access-log-2.png" alt="심지어는 60초까지 걸렸다."><br>이제는 유저가 못참고 페이지를 이탈해서 <a href="https://httpstatuses.com/499" rel="external nofollow noopener noreferrer" target="_blank">HTTP Status Code 499</a>도 나왔다.<br>동일한 API에서 계속해서 10초 이상이 걸리고, 점점 느려지는 걸 보니 해당 API의 문제가 맞다고 80% 정도는 확신을 했다.</p><p>실제로 해당 코드를 보니 페이징 처리나 조건문이 좀 부실했었고, 쿼리를 손 본 후에야 문제를 해결할 수 있었다. </p><h2 id="오늘의-교훈"><a href="#오늘의-교훈" class="headerlink" title="오늘의 교훈"></a>오늘의 교훈</h2><p><img src="/images/thread-dump-analyze/pokemon.jpg" alt="오늘의 교훈은 뭘까~~~요?"><br><del>피…피카츄!!</del><br>Alert Manger가 알림을 줬을 때 난 무시를 했다.<br>아니 무시한 건 아니지만 아주 간단하게만 테스트했다.<br>기계는 사람보다 정확하니 무시하지 말고 좀 더 면밀히 관찰하고 얼른 팀 내에 공유를 해야 앞으로 이런 사태가 발생하지 않을 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/thread-dump-analyze/thumb.png&quot; alt=&quot;쓰레드 덤프도 처음인지라 하면서 뭔가 두려웠다.&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;사건의-시작&quot;&gt;&lt;a href=&quot;#사건의-시작&quot; class=&quot;headerlink&quot; title=&quot;사건의 시작&quot;&gt;&lt;/a&gt;사건의 시작&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/thread-dump-analyze/alert.png&quot; alt=&quot;평화로운 어느날, Alert Manager의 역습&quot;&gt;&lt;br&gt;갑자기 Nginx가 Down 됐다는 알림이 와서 해당 서버로 접속해보니 Nginx 서비스는 정상적으로 떠있고…&lt;br&gt;curl도 때려보고, 브라우저에서 직접 URL로 접속해봤을 때 문제가 없었다.  &lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# blackbox exporter configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;modules:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  http_health:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    prober:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;http&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    timeout:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    http:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      method:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;GET&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      valid_status_codes:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;[200]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      preferred_ip_protocol:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;ip4&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      ip_protocol_fallback:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="Thread" scheme="https://perfectacle.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) 레디스 사망일기</title>
    <link href="https://perfectacle.github.io/2019/05/29/redis-monitoring/"/>
    <id>https://perfectacle.github.io/2019/05/29/redis-monitoring/</id>
    <published>2019-05-28T18:00:50.000Z</published>
    <updated>2019-08-22T05:54:34.803Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/redis-monitoring/thumb.png" alt="점점 산으로 가는 그래프..."></p><h2 id="사건의-발단"><a href="#사건의-발단" class="headerlink" title="사건의 발단"></a>사건의 발단</h2><p>사내에서 사용하는 어드민(이하 <strong>어드민 A</strong>)/외부에서 사용하는 어드민(이하 <strong>어드민 B</strong>)이 사망하는 사례가 속출하였다.<br>그 시점은 내가 새롭게 서버를 옮긴 이후부터 발생했다.<br>내가 서버를 옮긴 것과 이 일이 관련이 없다고 생각했지만,<br>우선 내가 서버를 옮긴 이후에 발생한 사건이기도 해서 부검을 통해 사인을 밝혀내는 게 우선이었다.</p><a id="more"></a><h2 id="왜-사망했나"><a href="#왜-사망했나" class="headerlink" title="왜 사망했나"></a>왜 사망했나</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.QueryTimeoutException: Redis command timed out; nested exception is com.lambdaworks.redis.RedisCommandTimeoutException: Command timed out</span><br><span class="line">at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:66)</span><br><span class="line">at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:41)</span><br></pre></td></tr></table></figure><p>elasticsearch에 저장된 에러 로그를 확인해본 결과 위와 같은 스택 트레이스를 남기고 전사하셨다.<br>즉, 레디스가 사망해서 레디스를 사용하는 어드민 서버도 사망한 것이었다.<br>다행인 것은 아예 프로세스 자체가 사망한 게 아니라 Hang에 걸린 상태여서 레디스를 재시작하는 것만으로 사건은 일단락 되었다.<br>하지만 머지않은 시점에 또 다시 사망하는 사례가 발생하였다.</p><h2 id="응급-처치"><a href="#응급-처치" class="headerlink" title="응급 처치"></a>응급 처치</h2><p><img src="/images/redis-monitoring/legacy-redis.png" alt=""><br>우선 어드민 A가 사용하는 레디스(이하 <strong>레디스 A</strong>)와 어드민 B가 사용하는 레디스(이하 <strong>레디스 B</strong>)가 같은 EC2 인스턴스 내에 존재하였다.<br>또한 메모리 1GB라는 소규모 서버에서 구동하다보니 인메모리 기반의 DB인 레디스에는 굉장히 협소하다고 생각했다.<br>하지만 우리가 사용하는 건 로그인 세션을 위해서만 사용하지, 그 이외의 것은 사용하지 않고 있어서 여전히 의아하긴 했다.<br>하지만 문제가 계속해서 발생하다보니 우선은 스케일업을 해야했다.  </p><p><img src="/images/redis-monitoring/new-redis.png" alt=""><br>그 중에 레디스 A보다 레디스 B가 더 자주 뻗어서 레디스 B를 새로운 서버로 옮기기로 했다.<br>트래픽이 그렇게 많지도 않은 어드민 서버의 로그인 세션만 저장하는데<br>메모리를 8GB씩이나 주는 건 약간 오버하는 경향이 없잖아 보였지만 일단 안정성을 챙기고자 좀 빵빵하게 주었다.</p><h2 id="진짜-이유를-찾아서"><a href="#진짜-이유를-찾아서" class="headerlink" title="진짜 이유를 찾아서"></a>진짜 이유를 찾아서</h2><p>나는 이미 8GB로 스케일업 했기 때문에 더이상 이런 사건이 발생하지 않을 것으로 예상했지만,<br>CTO 님께서는 좀 더 정확하게 원인을 분석하자고 하셨다.<br>나도 대충대충 넘어가다보면 영 찜찜하기도 해서 <del>내 역량도 그닥 올라갈 거 같지 않아서</del> 정확하게 원인을 분석해보는 게 좋을 것 같았다.  </p><p><img src="/images/redis-monitoring/monitoring.png" alt="어디서부터 어떻게 접근해야할지 몰랐기 때문에 우선 레디스를 모니터링하기로 했는데, 이미 사내에 구축한 모니터링 시스템(Exporter - Prometheus - Grafana)이 있기 때문에 이를 이용하기로 했다.">  </p><p>우선 모니터링하기 위해선 지표(Metric)을 수집해야한다.<br>그래서 가장 유명한 <a href="https://github.com/oliver006/redis_exporter" rel="external nofollow noopener noreferrer" target="_blank">Redis Exporter</a>를 찾아서 적용해보려고 했다.<br>해당 Exporter는 Redis의 <a href="https://redis.io/commands/INFO" rel="external nofollow noopener noreferrer" target="_blank">INFO</a> 커맨드의 출력 결과를 수집해서 <code>/metrics</code>라는 HTTP 엔드포인트로 노출하는 역할을 한다.<br>그럼 Prometheus에서 일정 주기마다 Pulling 해서 저장하고, 그 데이터를 기반으로 Grafana라는 대시보드를 통해 볼 수 있다.   </p><p>하지만 해당 Exporter는 <a href="https://github.com/oliver006/redis_exporter/issues/262" rel="external nofollow noopener noreferrer" target="_blank">Port를 옵션으로 받는 게 아니</a>라 <a href="https://github.com/oliver006/redis_exporter/blob/7a06cf8af9e28ad109018d067ff653edf08e664f/main.go#L46" rel="external nofollow noopener noreferrer" target="_blank">하드코딩</a> 돼있다.<br>Redis Exporter를 하나만 띄울 거라면 상관 없지만, 우리는 나중에 레디스 A도 업어와야하기 때문에 Redis Exporter를 하나 더 띄워야하는 경우였다.  </p><p><img src="/images/redis-monitoring/redis-exporter.png" alt=""><br>따라서 주객이 전도된 것 같지만 지표 수집을 위해서 기존에 Host OS에 띄워놓은 Redis를 Docker Container로 띄우고,<br>Redis Exporter도 Docker Container로 띄워서 각 컨테이너끼리 통신하게 끔 하였다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  admin-b-redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">redis:5.0.5-alpine</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">admin-b-redis</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">6380</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">  admin-b-redis-exporter:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">oliver006/redis_exporter:v1.0.0-alpine</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">admin-b-redis-exporter</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_ADDR=redis://admin-b-redis</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_EXPORTER_REDIS_ONLY_METRICS=true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9122</span><span class="string">:9121</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">on-failure</span></span><br></pre></td></tr></table></figure><p>또한 레디스 B 뿐만 아니라 기존 서버에서 레디스 A도 모니터링을 붙여놓았다.</p><p><img src="/images/redis-monitoring/legacy-monitoring.png" alt="레디스 A를 재시작 한 이후에 모니터링 해보니 점점 산으로 간다..."><br>레디스 A는 우리 사내에서 사용하는 어드민이 사용하는 레디스다.<br>계열사까지 합쳐도 전사 직원이 1,000명도 안 될텐데 생성된 키만 70,000개를 넘었다. (실제로 해당 어드민을 사용하는 유저는 100명도 안 되는데 말이다.)<br>이는 분명히 이상했지만, 명확하게 이렇게 생성된 원인을 파악할 수 없었다. (못난 나레기 ㅠㅠ…)  </p><p><img src="/images/redis-monitoring/legacy-monitoring-1-day.png" alt=""><br>우선 스프링 레디스 세션에 설정한 만료기간인 하루가 지나야 뭔가 볼 수 있을 것 같아 날이 밝기를 기다렸다.<br>그러자 위와 같이 그래프의 양상이 바뀌었다.  </p><p><img src="/images/redis-monitoring/expired-graph.png" alt="그래프의 양상이 바뀐 시점부터 분명 뭔가 만료는 되고 있고..."><br><img src="/images/redis-monitoring/command-call-graph.png" alt="하지만 주말 새벽 시간에도 꾸준히 뭔가 call이 일어나고 있다."></p><p>여기서 내린 추측은 <code>세션이 만료됨과 동시에 누군가 계속 세션을 생성해서 그래프가 현상유지가 되는 것</code>이라고 전제를 깔고 분석하기 시작했다.<br>그래서 우선 Nginx의 Access Log부터 까보기로 했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:32+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:35+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:40+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:50+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:00+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:02+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:05+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:10+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:20+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br></pre></td></tr></table></figure><p>ELB와 Consul은 Health Check Endpoint를 제대로 찌르고 있다.<br>하지만 <code>Go-http-client/1.1</code>라는 Agent는 계속해서 <code>/</code>을 찌르는데 이 때 바로 세션이 생성되는 것이다.<br>(추후에 <code>/login</code>으로 302 redirect 되지만 실제 세션 생성 시점은 그 이전이다.<br>비로그인 유저의 세션을 만드는 이유는 해당 세션을 가지고 동시 접속자 체크, 쇼핑몰 등등에서 비회원에게 장바구니 기능 제공 등등의 기능에서 사용이 가능하기 때문이다.<br>라고 <a href="https://www.facebook.com/groups/springkorea/permalink/1993894000722219/" rel="external nofollow noopener noreferrer" target="_blank">한국 스프링 사용자 모임에 질문</a>한 결과 알게 되었다.)  </p><p>내부 아이피를 직접 찌르고 있기 때문에 외부 크롤러나 봇에 의한 것이라는 전제는 일단 접어두었다. <del>(AWS 계정이 해킹당했을 거라는 끔찍한 상상은 하지 않았다.)</del><br>그리고 한 가지 든 의심이 서버의 헬스 체크를 해서 슬랙으로 알림을 주기 위해 사용한 <a href="https://github.com/prometheus/blackbox_exporter" rel="external nofollow noopener noreferrer" target="_blank">Blackbox Exporter</a>의 설정에 의해 Prometheus에서 위와 같이 헬스체크를 하는 게 아닐까 의심이 되었다.<br>그리고 <a href="https://github.com/prometheus/prometheus/issues/2440" rel="external nofollow noopener noreferrer" target="_blank">의심은 확신</a>으로 접어들기 시작했다.  </p><p>곧장 Prometheus에서 헬스 체크 엔드포인트를 어떻게 불러오는지 확인을 해보았다.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">  evaluation_interval:</span> <span class="number">1</span><span class="string">s</span></span><br></pre></td></tr></table></figure><p>내가 수집 주기를 <code>scrape_interval: 10s</code>로 설정해놨고, 아래는 172.12.1.189:80을 찌른 로그만 추려본 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br></pre></td></tr></table></figure><p>정확히 10초 주기로 172.12.1.189:80을 찔렀고, 점점 강한 확신으로 변해가고 있다.</p><p>Prometheus에서 Blackbox Exporter와 관련된 설정을 또 살펴보자.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'blackbox_exporter_http'</span></span><br><span class="line"><span class="attr">    metrics_path:</span> <span class="string">/probe</span></span><br><span class="line"><span class="attr">    params:</span></span><br><span class="line"><span class="attr">      module:</span> <span class="string">[http_2xx]</span></span><br><span class="line"><span class="attr">    consul_sd_configs:</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-001.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-002.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-003.dns:8500'</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__meta_consul_tags]</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">.*,blackbox_exporter_http,.*</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">keep</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__address__]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">__param_target</span> <span class="comment"># 여기가 중요</span></span><br><span class="line"><span class="attr">      - target_label:</span> <span class="string">'__address__'</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">'blackbox-exporter:9115'</span></span><br></pre></td></tr></table></figure><p>유동적으로 늘어나고 줄어드는 인스턴스에 대비하기 위해 consul을 사용하였다.<br>우선 consul에 등록된 태그 중에 <code>blackbox_exporter_http</code>란 값을 가지고 있는 서비스를 골라내고<br><code>__address__</code> 레이블에 설정된 값(<strong>ip:port</strong>)을 그대로 <code>__param_target</code>에 설정되는 것에서부터 문제가 시작됐다.<br>prometheus는 <code>__param_target</code>에 설정된 값을 토대로 헬스체크 한다는 것을 테스트를 통해 밝혔다.<br>이제는 완전한 확신을 했다.</p><p>우선 consul client가 설치된 어드민 A서버로 가서 consul에 어떤 service들을 등록하게 했는지 설정부터 살펴보았다.  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"services"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Nginx"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">80</span>,</span><br><span class="line">      <span class="attr">"check"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"Nginx Health Check"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Nginx Status"</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"http://localhost/health"</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8080"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8080</span>,</span><br><span class="line">      <span class="attr">"check"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"Server:8080 Health Check"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Server:8080 Status"</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"http://localhost:8080/health"</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8081"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8081</span>,</span><br><span class="line">      <span class="attr">"check"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"Server:8081 Health Check"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Server:8081 Status"</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"http://localhost:8081/health"</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또한 이제 보니 Nginx 말고 8080 및 8081 포트까지 찌르게 되어있었다.<br>(우리는 내부적으로 빠른 롤백을 위해 한 서버 인스턴스에 두 개의 어플리케이션 서버를 띄운 후 Nginx Upstream Server를 바꾸는 Blue/Green Deployment 전략을 사용 중이다.)<br>8080/8081 포트는 Nginx를 타지 않고 직접 프라이빗 IP를 찌르기 때문에 Access Log에 남지는 않았지만 세션도 생성됐을거라고 추측된다.  </p><p>우선 Prometheus에게 health check endpoint를 넘길 수 있게 끔 수정해야된다.  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"services"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Nginx"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">80</span>,</span><br><span class="line">      <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"health_check_endpoint"</span>: <span class="string">"health"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8080"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8080</span>,</span><br><span class="line">      <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"health_check_endpoint"</span>: <span class="string">"health"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8081"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8081</span>,</span><br><span class="line">      <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"health_check_endpoint"</span>: <span class="string">"health"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>meta.health_check_endpoint</code>를 사용하게 끔 Prometheus 설정 파일도 바꿔주자.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'blackbox_exporter_http'</span></span><br><span class="line"><span class="attr">    metrics_path:</span> <span class="string">/probe</span></span><br><span class="line"><span class="attr">    params:</span></span><br><span class="line"><span class="attr">      module:</span> <span class="string">[http_2xx]</span></span><br><span class="line"><span class="attr">    consul_sd_configs:</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-001.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-002.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-003.dns:8500'</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__meta_consul_tags]</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">.*,blackbox_exporter_http,.*</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">keep</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__address__,</span> <span class="string">__meta_consul_service_metadata_health_check_endpoint]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">__param_target</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">'(.*)(\/*);(.*)'</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">'$1/$3'</span></span><br><span class="line"><span class="attr">      - target_label:</span> <span class="string">'__address__'</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">'blackbox-exporter:9115'</span></span><br></pre></td></tr></table></figure><p>위와 같이 이제 설정을 바꾼 후 다시 Nginx의 Access log를 뒤져보았다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:57:52+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:57:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:02+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.000&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:12+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:15+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:19+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.005&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:22+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.003&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:32+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.003&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>Go-http-client/1.1</code>라는 Agent도 <code>/health</code>을 찌르기 시작했다.<br>그 이후에 이제 레디스 A를 모니터링 해봤다.  </p><p><img src="/images/redis-monitoring/legacy-monitoring-2.png" alt="그래프가 쭉쭉 떨어지는 걸 봐서 잘 해결된 것 같다."></p><h2 id="진짜-진짜로-죽은-이유"><a href="#진짜-진짜로-죽은-이유" class="headerlink" title="진짜 진짜로 죽은 이유"></a>진짜 진짜로 죽은 이유</h2><p>레디스 A와 같이 그래프가 현상유지만 됐으면 별 문제가 되지 않는다.<br>램은 1GB이지만, 실제로 사용량은 100MB도 되지 않았으므로 전혀 문제될 게 없다.<br>문제는 레디스 A가 아닌 레디스 B였다.<br>레디스 B는 어드민 B(외부에서 사용하는 어드민)이 사용하는 레디스이다.<br>해당 프로젝트는 세션의 만료기간을 Integer.MAX_VALUE(2³¹ − 1 = 2,147,483,647)로 잡아놓았다.<br>나는 해당 프로젝트의 개발에 참여하지 않아 잘 모르겠는데 아마 외부에서 사용하는 사람들이라면 매번 로그인하는 걸 번거롭게 생각해서 직접 요구사항이 들어오지 않았을까 싶다.<br><img src="/images/redis-monitoring/integer_max_value_to_year.png" alt="무려 68년동안이나 세션이 유지된다.">  </p><p>거의 평생동안 쓰레기 세션이 만들어진 채로 계속 유지가 된 거다.<br><img src="/images/redis-monitoring/forever-session-monitoring.png" alt="그 결과 500mb가 넘는 쓰레기 세션들이 만들어지고 있었다."><br>1GB 장비에서 500mb가 넘는 메모리는 엄청난 장애를 동반할 수 있다.<br>계속 유지되다가 버티지 못하고 레디스가 뻗고, 해당 레디스를 사용하는 서버도 뻗고, 다른 레디스 및 서버에도 영향을 미친 것으로 보인다.  </p><p><img src="/images/redis-monitoring/forever-session-garbage.png" alt=""><br>헬스 체크 엔드포인트를 변경한 이후에는 새로운 세션은 거의 만들어지지 않고 계속 현상 유지만 된 것이다.<br>500MB가 넘는 쓰레기 세션을 68년이 넘는 시간동안이나 끌고 가야하는 문제에 직면하게 되었다.<br>일단 로그인이 풀리겠지만 쓰레기 세션이 너무 많은 관계로 한 번 털고 가고(레디스 재시작), 세션의 만료기간도 좀 줄이기로 하였다.   </p><p><img src="/images/redis-monitoring/after-garbage-collection.png" alt=""><br>쓰레기 세션을 한 번 털고 나니 메모리 사용량이 확 줄어들었다.  </p><h2 id="이후-상황"><a href="#이후-상황" class="headerlink" title="이후 상황"></a>이후 상황</h2><p><img src="/images/redis-monitoring/admin-a-30-days.png" alt="어드민 A(세션 유지기가 1일)100MB를 치던 키가 쭉쭉 떨어지는 걸 볼 수 있다."><br>재밌는 건 중간에 줄어들다가 현상유지되는 구간이다.<br>이 구간은 내 실수로 두 대의 서버가 떠있는데 한 대의 서버의 헬스 체크 엔드포인트만 수정하고, 나머지 한대는 제대로 수정하지 않아서 현상 유지가 되었다.<br>(Consul 클라이언트 프로세스를 죽이고 다시 띄웠는데도 Consul 서버에서는 해당 노드와 서비스들이 좀비처럼 살아있었다 ㅠㅠ…)<br><img src="/images/redis-monitoring/admin-a-24-hours.png" alt="지금은 뭐 피크 타임 때도 2메가 쓸까 말까이다."><br><img src="/images/redis-monitoring/admin-b-30-days.png" alt="어드민 B(세션 유지기간 68년)의 경우에는 너무 쓰레기 세션이 많아서 한 번 털고 갔다."><br><img src="/images/redis-monitoring/admin-b-24-hours.png" alt="얘는 피크 때 그나마 6~7메가 정도를 쓰고 있다.">  </p><p>솔직히 말해서 스케일 아웃은 괜히했고, 애초에 로그인 세션만 사용하는데 비정상적으로 키가 많이 생성되고 용량 차지를 많이하는 것부터가 이상했다.<br>다음부터는 좀 더 조심히 일하고 현상 파악을 해야겠다. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/redis-monitoring/thumb.png&quot; alt=&quot;점점 산으로 가는 그래프...&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;사건의-발단&quot;&gt;&lt;a href=&quot;#사건의-발단&quot; class=&quot;headerlink&quot; title=&quot;사건의 발단&quot;&gt;&lt;/a&gt;사건의 발단&lt;/h2&gt;&lt;p&gt;사내에서 사용하는 어드민(이하 &lt;strong&gt;어드민 A&lt;/strong&gt;)/외부에서 사용하는 어드민(이하 &lt;strong&gt;어드민 B&lt;/strong&gt;)이 사망하는 사례가 속출하였다.&lt;br&gt;그 시점은 내가 새롭게 서버를 옮긴 이후부터 발생했다.&lt;br&gt;내가 서버를 옮긴 것과 이 일이 관련이 없다고 생각했지만,&lt;br&gt;우선 내가 서버를 옮긴 이후에 발생한 사건이기도 해서 부검을 통해 사인을 밝혀내는 게 우선이었다.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="Redis" scheme="https://perfectacle.github.io/tags/Redis/"/>
    
      <category term="Monitoring" scheme="https://perfectacle.github.io/tags/Monitoring/"/>
    
  </entry>
  
  <entry>
    <title>(JVM) Garbage Collection Advanced</title>
    <link href="https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/"/>
    <id>https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/</id>
    <published>2019-05-11T07:05:47.000Z</published>
    <updated>2019-08-22T05:34:24.104Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jvm-gc-advanced/thumb.jpeg" alt="출처: https://medium.com/@iacomini.riccardo/hadoop-namenode-garbage-collector-tuning-7f6a029e9012"></p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p><img src="/images/jvm-gc-advanced/optimizing-java.jpeg" alt=""><br>이 글은 이일웅 님께서 번역하신 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14796595" rel="external nofollow noopener noreferrer" target="_blank">자바 최적화</a>란 책을 읽던 도중 공부한 내용을 정리한 글입니다.<br>절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.<br>이 글을 읽어보시기 전에 <a href="/2019/05/07/jvm-gc-basic/">Garbage Collection Basic</a> 편을 읽어보시면 더 도움이 될 것입니다 :) </p><a id="more"></a><h2 id="Mark-and-Sweep-Algorithm"><a href="#Mark-and-Sweep-Algorithm" class="headerlink" title="Mark and Sweep Algorithm"></a>Mark and Sweep Algorithm</h2><p>Basic 편에서는 간단하게 Young/Old Generation과 Mark and Sweep 알고리듬에 대해서 간단하게 알아보았다.<br>해당 알고리듬을 사용하는 GC를 <strong>scavenge garbage collector</strong>라고도 부른다.<br>Mark and Sweep Algorith의 단점은 GC를 수행하는 동안 Stop the World(이하 STW)가 발생한다는 것이다.<br>![출처: <a href="https://www.youtube.com/watch?v=_cNXjmuhCCc]/images/jvm-gc-advanced/stop-the-world.png" rel="external nofollow noopener noreferrer" target="_blank">https://www.youtube.com/watch?v=_cNXjmuhCCc]/images/jvm-gc-advanced/stop-the-world.png</a>) </p><p>그럼 이제 해당 알고리듬을 사용하는 GC 알고리듬에는 뭐가 있는지 알아보자.</p><h3 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h3><p><strong>프로덕션에서 절대 사용하면 안 되는 GC이다.</strong> (싱글 코어 CPU를 사용하는 서버를 제외하고… <del>설마 아직도??</del>)<br>CPU 코어를 한 개만 사용하기 때문에, 해당 GC는 싱글 코어 환경에서만 적합하다. (쓰레드 간의 컨텍스트 스위칭도 적기 때문에…)<br>Young/Old Generation 모두 Mark and Sweep 알고리듬을 사용하여 GC를 수행한다.<br>Young Generation에서는 gc 수행 시간을 줄이고자 memory compaction을 수행하지 않고 survivor 영역을 전전긍긍하다 Old Generation으로 승진시켜버린다.<br>Old Generation은 survivor 영역처럼 별도의 메모리 영역이 없다보니 memory compaction도 하고, 메모리 사이즈도 크다보니 수행 시간이 길다. (그만큼 STW도 길다…)</p><p>-XX:+UseSerialGC 파라미터를 주고 실행하면 적용된다.</p><h3 id="ParallelGC-Young-ParallelOldGC-Old"><a href="#ParallelGC-Young-ParallelOldGC-Old" class="headerlink" title="ParallelGC(Young) / ParallelOldGC(Old)"></a>ParallelGC(Young) / ParallelOldGC(Old)</h3><p>Java 7<del>8의 기본 GC이며 <a href="#Serial-GC">Serial GC</a>의 멀티 코어 판이다.<br>‘Serial GC에서 하던 걸 다수의 코어(및 쓰레드)가 하다보니 더 빠르게 수행하겠구나</del>‘정도로 받아들이고 있다.</p><p>둘은 쌍쌍바 같은 녀석이라 -XX:+UseParallelGC 파라미터를 주면 자동으로 -XX:+UseParallelOldGC 파라미터가 활성화되고,<br>-XX:+UseParallelOldGC 파라미터를 주면 자동으로 -XX:+UseParallelGC 파라미터가 활성화된다.</p><h2 id="Tri-color-Marking-Algorithm"><a href="#Tri-color-Marking-Algorithm" class="headerlink" title="Tri-color Marking Algorithm"></a>Tri-color Marking Algorithm</h2><p>Tri-color Abstraction으로도 불리는 것 같으며 ‘자바 최적화’란 책에서는 ‘삼색 마킹 알고리즘’이라고 번역하였다.<br>Tri라는 접두사는 숫자 3을 의미하며, 총 3가지 색을 써서 마킹하는 알고리듬을 뜻한다.<br><a href="/2019/05/07/jvm-gc-basic/#Mark-and-Sweep-Algorithm">Mark and Sweep Algorithm</a>에서는 2가지 색(마킹되었거나, 마킹되지 않았거나)을 쓴 것과 차이점을 지닌다.<br>이 알고리듬은 동시성 알고리듬과 GC의 정확성을 증명했다는데, 즉 어플리케이션이 멈추지 않으면서 GC를 <strong>동시</strong>에 <strong>정확</strong>하게 쓰기 위해 나온 알고리듬 같다.  </p><p>먼저 알고리듬을 알아보기 전에 각각의 색에는 무엇이 있고, 어떤 역할을 하는지 알아보자.  </p><ol><li>회색(Grey)<br>해당 객체가 참조하고 있는 객체를 식별하지 않은, 즉 처리가 되지 않은 객체</li><li>검은색(Black)<br>해당 객체가 참조하고 있는 객체를 모두 식별한, 즉 모든 처리를 끝마친 객체</li><li>흰색(White)<br>해당 객체를 참조하고 있는 객체가 아무런 객체도 없는 객체, 수집 대상이 되는 객체</li></ol><p><img src="/images/jvm-gc-advanced/tri-color-marking-01.png" alt="Stack과 같은 GC Root(외부에서 힙 메모리에 대한 레퍼런스를 갖고 있는 메모리 풀?)에 있는 객체를 전부 회색으로 표시한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-02.png" alt="마킹 스레드가 회색 객체를 랜덤하게 돌아다니면서 해당 회색 객체가 참조하고 있는 객체를 전부 회색으로 마킹한 후 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-03.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으니 자신을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-04.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으므로 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-05.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으므로 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-06.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체는 회색으로 마킹하고 본인은 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-07.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체는 회색으로 마킹하고 본인은 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-08.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으므로 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-09.png" alt="회색 객체가 없을 때까지 위 작업을 반복하고 흰색 객체를 전부 수거해간다.">  </p><h3 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h3><p>Mark and Sweep Algorithm과 달리 Tri-color Marking Algorithm은 어플리케이션과 동시에 수행된다.<br>따라서 마킹하는 도중에 어플리케이션 스레드(책에선 Mutator라고 표기)에서 수정 사항이 반영되기 때문에 라이브 객체가 수집되는 현상이 발생될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aInstance.setSomeField(cInstance);</span><br></pre></td></tr></table></figure><p><img src="/images/jvm-gc-advanced/tri-color-marking-issue-01.png" alt="A라는 객체는 검은색으로 마킹돼있기 때문에 참조하는 객체에 대한 처리가 모두 끝난 객체이다.">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aInstance.setSomeField(cInstance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// blah blah...</span></span><br><span class="line"></span><br><span class="line">aInstance.setSomeField(bInstance);</span><br></pre></td></tr></table></figure><p><img src="/images/jvm-gc-advanced/tri-color-marking-issue-02.png" alt="A가 C에서 B를 바라보게 끔 변경되었다."><br>여기서 두 가지 문제점이 발생한다.  </p><ol><li>A는 검은색 객체로 모든 작업이 끝난 객체다.<br>또한 B는 흰색으로 마킹돼있다, 즉 수집의 대상이다.<br>라이브 객체를 수집하기 때문에 추후에 NPE(NullPointerException)이 발생할 가능성이 존재한다.</li><li>C는 회색 객체로 마킹돼있고, 나중에 검은색 객체로 바뀐다.<br>즉, C는 GC 루트로부터 아무도 참조하지 않는 객체가 된 죽은 객체인데도 불구하고 흰색으로 마킹되지 않는다.<br>따라서 수집 대상이 되지 않기 때문에 메모리 릭을 유발할 수 있다. (물론 다음 GC에서 수거해가겠지만…)<br>이렇게 아무도 참조하고 있지 않은데 혼자 남아있는 객체를 부유 가비지(Floating Garbage)라고 부른다.</li></ol><p>위와 같은 경우에는 애플리케이션 스레드가 객체를 변경했을 때 재마킹하게 끔하거나,<br>알고리듬을 깨버릴만한 모든 변경 사항을 큐 형태로 넣어놓고 GC의 main phase가 끝난 다음에 fixup phase에서 바로 잡는 방법 등등이 존재한다. </p><h3 id="CMS-Concurrent-Mark-Sweep-GC"><a href="#CMS-Concurrent-Mark-Sweep-GC" class="headerlink" title="CMS(Concurrent Mark Sweep) GC"></a>CMS(Concurrent Mark Sweep) GC</h3><p>CMS GC는 Tri-color Marking Algorithm을 사용하기 때문에 GC와 함께 어플리케이션을 돌릴 수 있다.<br>그렇다고 해서 아예 STW가 없는 건 아닌데 Parallel(Old)GC에 비하면 훨씬 짧다.<br>즉, 레이턴시에 엄청 민감한 경우에 적합한 GC라고 볼 수 있다.<br>절반은 GC 돌리고, 절반은 어플리케이션 스레드를 돌리는 것이다. (물론 평상시에는 100% 어플리케이션이 쓰겠지만…)<br>CMS GC는 Old Generation 전용 GC이고, 해당 GC를 사용하면 자동적으로 Young Generation 전용으로 ParNewGC를 사용한다.<br>(Java 8에서 -XX:+UseConcMarkSweepGC -XX:-UseParNewGC 이 조합이 Deprecate 되었다.<br>그냥 -XX:+UseConcMarkSweepGC만 사용하면 된다.)<br>ParNewGC에 대해선 좀 이따 간단히 설명하겠다.</p><p>CMS GC의 장점은 아래와 같다.</p><ol><li>어플리케이션 스레드가 오랫동안 멈추지 않는다. (짧게 짧게 쪼개서 멈춘다.)  </li></ol><p>CMS GC의 단점은 아래와 같다.  </p><ol><li>GC 풀 사이클 자체는 Parallel(Old)GC 보다 길다.  </li><li>GC가 도는 도중에는 어플리케이션 스레드가 절반만 돌기 때문에 처리율이 감소한다. </li><li>Mark and Sweep 알고리듬에 비해 하는 일도 많고 복잡하다보니 메모리, CPU를 더 많이 쓴다.  </li><li>CMS GC는 Old Generation의 메모리 Compaction을 수행하지 않으므로 단편화가 발생한다.</li></ol><p>역시 은총알은 없는 것 같다… ㅠㅠ</p><p>CMS GC는 어플리케이션 쓰레드와 같이 돌기 때문에 좀 복잡하게 동작한다.  </p><ol><li><p>초기 마킹(Initial Mark, <strong>STW 발생</strong>)<br><img src="/images/jvm-gc-advanced/cms-01.png" alt="GC Root나 Young Generation에서 참조하는 객체를 회색으로 마킹한다."><br>이렇게 마킹해놓으면 마킹 단계에서 다른 메모리 영역은 신경쓰지 않고 하나의 GC 풀에만 신경쓰면 된다.  </p></li><li><p>동시 마킹(Concurrent Mark)<br><img src="/images/jvm-gc-advanced/cms-02.png" alt="마킹 쓰레드와 어플리케이션 쓰레드가 동시에 돌기 때문에 객체 참조 간에 변경 사항이 발생한다.">  </p></li><li><p>동시 사전 정리(Concurrent Preclean)<br><img src="/images/jvm-gc-advanced/cms-03.png" alt="Old Generation 영역을 일정 공간으로 나누어 Card라 불리는 곳에 저장한다."><br>그리고 Initial Mark 이후에 참조 간에 변경이 생긴 곳을 Dirty Card라고 부른다.<br>자세한 내용은 <a href="http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html" rel="external nofollow noopener noreferrer" target="_blank">The JVM Write Barrier - Card Marking</a>을 참고하자.<br><img src="/images/jvm-gc-advanced/cms-04.png" alt="사전 정리를 해야 Dirty Card에서 일반 Card가 될 수 있다."><br>이 phase의 목적은 5단계(재마크, Final Remark) 시에 STW 시간을 줄이기 위함이다.</p></li><li><p>Abort 가능한 동시 사전 정리(Concurrent Abortable Precelan)<br>이 phase의 목적 역시 5단계(재마크, Final Remark) 시에 STW 시간을 줄이기 위함이다.<br>해당 phase는 이름부터 Abortable이 들어가기 때문에 아래와 같은 조건 의해 Abort 될 수 있다.<br>반복 횟수를 넘거나, 정해진 시간을 초과하거나, 사전 정리가 효과적으로 이루어졌거나 등등… (JVM 옵션으로 설정 가능한 것들도 있다.)  </p></li><li><p>재마크 (Final Remark, <strong>STW 발생</strong>)<br><img src="/images/jvm-gc-advanced/cms-05.png" alt="Old Generation의 모든 live object를 마킹한다.">  </p></li><li><p>동시 쓸어담기 (Concurrent Sweep)<br><img src="/images/jvm-gc-advanced/cms-06.png" alt="어플리케이션 스레드가 돌아감과 동시에 하얀색으로 마킹된 오브젝트를 전부 수거해간다.">  </p></li><li><p>동시 리셋 (Concurrent Reset)<br><img src="/images/jvm-gc-advanced/cms-07.png" alt="어플리케이션 스레드가 돌아감과 동시에 마킹했던 내용들을 리셋한다."></p></li></ol><h4 id="CMF-Concurrent-Mode-Failure"><a href="#CMF-Concurrent-Mode-Failure" class="headerlink" title="CMF(Concurrent Mode Failure)"></a>CMF(Concurrent Mode Failure)</h4><p>ParallelOldGC는 긴 STW를 가지는 대신에 CMS는 짧은 두 번의 STW만 있으므로 지연이 매우 적다.  </p><p>하지만 Old Generation을 GC하고 있는 와중에 동시에 Eden 영역도 차게 되는데, 이러다 Eden 영역이 꽉찬 경우에는 어떻게 될까?<br>Young Generation을 GC해야하는데 ParNewGC도 STW를 유발하는데 쓰레드 절반은 Minor GC, 쓰레드 절반은 Major GC를 수행하고 있기 때문에 Minor GC는 ParallelGC 보다 느리다.<br>또한 Minor GC 이후에 적당한 나이를 먹은 객체는 Old Generation으로 <a href="/2019/05/07/jvm-gc-basic/#Promotion">승진</a>시켜야하는데,<br>CMS GC는 메모리 컴팩션을 하지 않기 때문에 메모리 단편화가 발생하기 때문에 ParallelGC 보다 더 적은 객체를 Old Generation으로 승진시킨다.<br>(-XX:InitialTenuringThreshold와 -XX:MaxTenuringThreshold의 기본 값을 좀 높여서 사용하는 걸까…?)<br>또한 Old Generation으로 승진시킴과 동시에 Old Generation은 아직 GC 중이기도 하고해서 좀 더 긴밀한 조정을 하게되는데 이것도 ParNewGC와 ParallelGC와의 차이점이다.</p><p>또한 객체의 할당률이 급증해서 <a href="/2019/05/07/jvm-gc-basic/#Premature-Promotion">조기 승진</a>이 일어나기도 하고,<br>급기야 승진한 객체가 너무 많은 경우에는 Old Generation 조차 꽉차는 경우가 존재한다. (단편화로 인해 연속된 메모리 공간을 확보하지 못하는 것도 한 몫 한다.)<br>이런 경우에는 어쩔 수 없이 CMS GC에서 ParallelOldGC로 바뀌게 되고, STW가 발생한다.</p><p>CMF가 발생하지 않게 하려면, Old Generation이 꽉 차기 전에 얼른얼른 GC를 수행해야하는데<br>-XX:CMSInitiatingOccupancyFraction 파라미터로 정할 수 있고 기본값은 75이다. (Old Generation의 75%가 차면 GC 시작)</p><p>CMS는 내부적으로 사용 가능한 빈 공간을 ‘프리 리스트’라는 걸 통해 관리한다.<br>Concurrent Sweep 단계에서 Sweeper 쓰레드는 다음의 일을 한다.  </p><ol><li>여유 공간을 더 큰 덩어리로 만든다.  </li><li>단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉친다.</li></ol><p>하지만 Sweeper는 어플리케이션 쓰레드와 동시에 작동하므로 쓰레드가 적절히 동기화되지 않는 한 새로 할당된 블록이 잘못 수집될 가능성이 존재한다.<br>따라서 Sweeper 쓰레드는 프리 리스트를 잠근 후에 작업한다.</p><h3 id="G1-GC-Garbage-First-GC"><a href="#G1-GC-Garbage-First-GC" class="headerlink" title="G1 GC(Garbage First GC)"></a>G1 GC(Garbage First GC)</h3><p>G1 GC는 자바 6에 실험적으로 등장하여 자바 8u40 이후부터 쓸만큼의 성능 및 안정성을 발휘하기 시작했고, <strong>자바 9부터 기본 GC</strong>로 채택됐다. (자바 12가 나온 현재도 기본 GC이다.)<br>G1 GC는 처음부터 CMS를 대체할 목적으로 설계되었는데 CMS GC를 사용중인데 아무런 문제가 없는데 성급하게 바꾸는 행위는 하지 않는 게 좋다.<br>굳이 바꾸지 않아도 바꾸는 건 안정성을 떨어뜨리는 행위이며 조금이라도 처리율을 높이고 싶어서 올리고 싶다면 충분한 테스트를 거친 이후에 하자.</p><p><img src="/images/jvm-gc-advanced/g1-gc-01.png" alt="G1 GC는 Young(Eden/Survivor) Generation 및 Old Generation이 존재하는데 각 Generation이 연속된 메모리 공간일 필요가 없다는 게 큰 차이점이다. (물론 힙 메모리 자체로 봤을 때는 각 Region은 연속된 메모리 공간에 할당된다.)"><br>즉, Survivor 영역도 기존에는 2개였는데 G1 GC에서는 그러한 개념도 사라졌다.<br>또한 거대한 객체(Humongous Object)를 저장하는 ‘거대 영역(Humongous Region)’이라는 특수한 영역도 존재한다.(Humongous Object는 Old Generation에 바로 할당된다.)<br>Humongous Object라고 식별하는 기준은 리전 사이즈의 50%를 넘는 객체면 된다.   </p><p>G1 GC는 처음부터 CMS를 대체할 목적으로 중단 시간이 짧은 수집기로 설계했기 때문에 아래와 같은 특징이 있다.    </p><ol><li>수십 GB 이상의 힙에서도 짧은 STW를 지향한다.  </li><li>객체 할당과 Old Generation으로 승진이 많은 경우에도 메모리 Compaction을 하기 때문에 CMS처럼 Full GC가 돌지 않는다.  </li><li>짧은 STW와 예측 가능한 STW 시간  </li></ol><p>-XX:MaxGCPauseMillis라는 옵션으로 지정할 수 있는데 100(ms) 이하로 지정하면 이를 어길 가능성이 크다고 한다.</p><ol><li>Java 10부터 Full GC 시에 Multi Thread로 작동한다. (<a href="https://bugs.openjdk.java.net/browse/JDK-8172890" rel="external nofollow noopener noreferrer" target="_blank">JEP 307: Parallel Full GC for G1</a>)<br>참고로 CMS GC는 Full GC 시에 Single Thread로 동작하는 것으로 알고 있는데, 지금은 고쳐졌는지 모르겠다.<br>애초에 CMS GC를 대체할 목적으로 G1 GC 개발에 몰두했을 거 같기 때문에 안 고쳤을 것 같다…</li></ol><p>G1 GC는 힙을 ‘영역(Region)’이라는 것으로 구성한다. (일단 힙크기는 4GiB라고 가정해보자.)<br>영역의 크기 = 힙크기 / 2048 =&gt; 4096 / 2048 = 2(MiB)<br>만약 딱 나누어떨어지지 않는다면 크기 값게 가장 가까운 수치로 반올림하여 계산한다.<br>영역의 크기는 1, 2, 4, 8, 16, 32 MiB 중에 정해진다.  </p><h4 id="Why-G1"><a href="#Why-G1" class="headerlink" title="Why G1?"></a>Why G1?</h4><p>이름이 왜 G1(Garbage First)일까?<br>G1 GC는 살아있는 객체를 마킹한 후에 리전 별로 얼만큼을 살려둬야하는지 알 수 있다. (생존률?)<br>그 다음 G1 GC는 리전 중에 모든 객체가 죽은 리전(유효한 객체가 없는 리전, 즉 <strong>Garbage</strong>만 있는 Region)부터 회수를 한다.<br>메모리 회수를 먼저 하면 빈 공간 확보를 더 빨리 할 수 있다.<br>빈 공간 확보를 더 빨리 한다는 건 조기 승격이나 급격히 할당률이 늘어나는 경우를 방지할 수 있다.<br>이렇게 되면 Old Generation이 비교적 한가해지게 된다.</p><p>다른 컬렉터들과 달리 G1 GC는 죽어있는 객체만 있는 Region(Garbage)을 처음에(First) 수거하기 때문에 이런 이름이 붙게 됐다.  </p><h4 id="G1-GC는-어떻게-대용량-힙에서-낮은-중단-시간을-가질-수-있게-되었을까"><a href="#G1-GC는-어떻게-대용량-힙에서-낮은-중단-시간을-가질-수-있게-되었을까" class="headerlink" title="G1 GC는 어떻게 대용량 힙에서 낮은 중단 시간을 가질 수 있게 되었을까?"></a>G1 GC는 어떻게 대용량 힙에서 낮은 중단 시간을 가질 수 있게 되었을까?</h4><p>힙 용량이 커지면 커질 수록 객체의 갯수가 많아지고, 객체의 갯수가 많아지면 GC 수행시간이 길어지고, 그러다보면 STW 시간도 당연히 늘어나게 된다.<br>근데 G1 GC는 어떻게 그렇게 빨리 대용량 힙을 GC할 수 있는 걸까??</p><ol><li>GC 시에 전체 Heap에 대해서 GC를 수행해도 되지 않는다.<br>GC 해야하는 Region만 GC를 하면 되기 때문이다.<br>이 GC 해야만하는 Region을 뒤질 때도 좀 더 특수한 기법을 쓴다.<br>바로 Region 별로 RSet(Remembered Set)을 두고, 이 RSet만 뒤져서 추적을 하면 되기 때문이다.<br>RSet에는 외부에서 힙 영역 내부를 참조하는 레퍼런스를 관리하기 위한 정보들이 저장돼있다.  </li><li>Old Generation Compaction을 하는데 전체 Old Generation 대해서 Compaction을 하지 않아도 된다.<br>해당 Region에 대해서만 Compaction을 하면된다.  </li><li>Garbage를 먼저 수집해간다.<br>이는 G1 GC의 이름의 유래에서도 설명했는데 빈 공간을 먼저 확보하기 때문에 메모리의 여유 공간이 확보가 많이 된다.<br>여유 공간이 확보가 빨리 빨리 되니 그만큼 GC 빈도도 줄어들게 되는 것이다.</li></ol><h4 id="Evacuation"><a href="#Evacuation" class="headerlink" title="Evacuation"></a>Evacuation</h4><p>Minor GC 이후에 Survivor Space로 객체를 옮기거나 Old Generation으로 객체를 옮겨야한다.<br>이 때 G1 GC는 해당 객체를 기존의 Region 혹은 새 Region에 복사후에 메모리를 compact시킨다.<br>마치 전쟁통에 <strong>피난(Evacuation)</strong>가는 느낌 때문인지 이러한 행위를 Evacuation이라고 부른다.</p><p>Major GC 시에도 마찬가지다.<br>Old Generation Region에 있는 생존 객체를 다른 리전으로 피난(Evacuation)시킨 후 해당 메모리를 Compact한다.<br>하지만 Old Generation의 특수한 리전인 Humongous Region에 대해서는 Evacuation이 발생하지 않는다.<br>그냥 해당 리전의 객체(Humongous Object)가 더 이상 참조하는 객체가 없어서 사망하셨으면 바로 회수해간다.</p><h4 id="G1-GC-Cycle"><a href="#G1-GC-Cycle" class="headerlink" title="G1 GC Cycle"></a>G1 GC Cycle</h4><p><img src="/images/jvm-gc-advanced/g1-gc-cycle.png" alt="출처: https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180"><br>위 그림은 알고리듬의 Phase 및 STW가 발생하는 걸 표현한 것이다.  </p><p>모든 원은 STW가 발생함을 나타낸 것이고, 그 크기에 따라 시간이 달라진다고 생각하면 될 것 같다.<br>파란원은 Minor GC가 진행함에 따라 STW가 발생하는 것이고,<br>주황원은 Major GC가 진행하면서 객체를 마킹하느라고 생기는 STW이고,<br>빨간원은 Mixed Collection(Minor/Major GC)을 진행함에 따라 STW가 발생하는 것이다.  </p><p>Young Only Phase는 이름에서 보듯이 Young Only (Garbage Collection) Phase라고 이해하면 될 것 같다.<br>여기서 Major GC가 일어나긴 하지만 마킹만 하는 단계고, 메모리를 회수해가는 단계는 아니기 때문이다.<br>파란원이 Minor GC 때문에 생긴 STW이다.<br>이렇게 평화롭게 Minor GC만 수행하다가 -XX:InitiatingHeapOccupancyPercent에 지정한 값을 초과하는 순간 Major GC도 시작한다.<br>Major GC의 첫단계는 Initial Mark이며 Minro GC와 동시에 수행되며 둘 다 STW를 수반한다. (따라서 다른 파란원보다 크기가 크다.)<br>그 이후에 어플리케이션 쓰레드, Minor GC, Concurrent Mark가 동시에 수행되는데 Remark가 수행되는 순간 다른 작업은 멈추게 된다.<br>그리고 주황색 원에서 보다싶이 Remark가 수행되면서 STW가 발생한다. (일반 파란원보다 긴 시간이 필요하다.)<br>그 이후에 또 짜잘하게 Minor GC가 수행되다가 주황색 원에서 보다싶이 Cleanup을 수행한다.  </p><p>이제 Young Only Phase가 끝나고 Space Reclamation(공간 회수) Phase가 시작된다.<br>Space Reclamation Phase는 이름에서 보다싶이 Young Only Phase에서 마킹한 리전(Space)의 메모리를 수집(Reclamation)하는 단계이다.<br>Space Reclamation Phase에서는 Mixed Collection(Minor/Major GC)이 수행되는데 이는 빨간원으로 표시했다.<br>Mark 단계가 없어서인지 Space Reclamation Phase에서는 STW 빈도가 훨씬 줄어든 모습을 볼 수 있다.</p><p>Space Reclamation Phase가 끝나면 다시 Young Only Phase로 돌아가서 Minor GC만 메모리를 수집하게 된다.<br>이렇게 G1 GC는 Young Only Phase와 Space Reclamation Phase를 번갈아 수행하는 싸이클을 갖고 있다.  </p><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p>이제부터는 각 GC 및 단계를 좀 더 면밀히 관찰해보자.<br>아래 나오는 모든 그림의 출처는 <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" rel="external nofollow noopener noreferrer" target="_blank">Getting Started with the G1 Garbage Collector - Oracle</a>이다.</p><h5 id="Minor-GC-Young-Generation"><a href="#Minor-GC-Young-Generation" class="headerlink" title="Minor GC (Young Generation)"></a>Minor GC (Young Generation)</h5><p>Minor GC는 기존 GC들과 크게 다르지 않다.<br>물론 멀티 쓰레드에서 병렬로 돌아간다.<br><img src="/images/jvm-gc-advanced/g1-gc-02.png" alt="연속되지 않은 메모리 공간에 Young Genration이 Region 단위로 메모리에 할당돼있다."><br><img src="/images/jvm-gc-advanced/g1-gc-03.png" alt="live object가 suvivor region이나 old generation으로 evacuation(피난, copy or move)된다."><br>이 단계에서 STW가 발생하고, Eden과 Survivor의 사이즈는 다음 Minor GC를 위해 재계산 된다.<br><img src="/images/jvm-gc-advanced/g1-gc-04.png" alt="Minor GC를 모두 마친 후의 모습이다.">  </p><h5 id="Major-GC-Old-Generation"><a href="#Major-GC-Old-Generation" class="headerlink" title="Major GC (Old Generation)"></a>Major GC (Old Generation)</h5><p><img src="/images/jvm-gc-advanced/g1-gc-05.png" alt="Initial Mark는 STW를 발생시킨다."><br>Initial Mark는 Survivor Region에서 Old Region을 참조하는 게 있는지 파악해서 Mark하는 단계이다.<br>Survivor Region에 의존적이기 때문에 Survivor Region은 깔끔한 상태여야하고,<br>Survivor Region이 깔끔하려면 Minor GC가 전부 끝난 상태여야한다.<br>따라서 Initial Mark가 Minor GC에 의존적이다.  </p><p><img src="/images/jvm-gc-advanced/g1-gc-06.png" alt="X 표시한 Region은 모든 객체가 사망한 Empty Region이다."><br>Concurrent Mark 단계에서는 Old Generation 내에 생존해있는 모든 객체를 마크하고 다닌다.<br>STW가 없기 때문에 어플리케이션 쓰레드와 동시에 돌고, 종종 Minor GC한테 인터럽트 당한다.  </p><p><img src="/images/jvm-gc-advanced/g1-gc-07.png" alt="Concurrent Mark에서 X 표시 친 Empty Region을 바로 회수해버린다."><br>Remark Phase 역시 STW를 수반한다.<br>또한 Concurrent Mark 단계에서 깔짝깔짝 마킹하던 걸 완전히 끝내버린다.<br>그리고 SATB(snapshot-at-the-beginning) 기법을 쓰기 때문에 CMS GC보다 더 빠르다.<br>여기서 SATB는 <code>수집 사이클을 시작할 때 접근 가능하거나 그 이후에 할당된 객체를 라이브 객체로 간주하는 기법</code>이다.</p><p><img src="/images/jvm-gc-advanced/g1-gc-08.png" alt="Old Generation에서도 evacuation(피난, 살아있는 객체를 copy or move)이 발생한다."><br>이 단계는 STW를 수반하지 않는다.<br>Remark에서 제일 수집하기 쉬운 Empty Region을 수집해갔으니 이제 그 다음으로 수집하기 쉬운 영역을 수집해갈 차례다.<br>Empty Region 다음으로 수집하기 쉬운 Region은 생존률이 제일 낮은 Region이고 생존률이 낮은 순으로 순차적으로 수거해가는 것이다.<br>먼저 해당 region을 피난(copy or move)시키고, 수집해간다.<br>G1 GC는 이렇게 Garbage의 수집을 우선(First)해서 계속해서 여유 공간을 신속하게 확보해둔다.  </p><p>또한 Cleanup 단계에서는 아래와 같은 일을 한다. </p><ul><li>Performs accounting on live objects and completely free regions. (STW 발생)<br>살아있는 객체와 완전히 비어있는 region을 계산함(번역이 맞는지 확인해주십시오 ㅠㅠ)</li><li>RSet을 정리(STW 발생)</li><li>빈 리전을 정리하고나서 Free List에 추가(Concurrent)</li></ul><p><img src="/images/jvm-gc-advanced/g1-gc-09.png" alt="Major GC 이후 깔끔하게 정리된 Old Generation의 모습이다."></p><h2 id="Epsilon-Collector"><a href="#Epsilon-Collector" class="headerlink" title="Epsilon Collector"></a>Epsilon Collector</h2><p>이 컬렉터는 GC를 전혀 수행하지 않는 컬렉터이다.<br>따라서 <strong>실서버 운영 환경에서는 절대 절대 쓰면 안된다.</strong>  </p><p>다음의 경우에 적합하다.  </p><ul><li>성능 테스트 전용<br>정확한 성능 테스트를 해야하는데 GC가 돌아감에 의해 영향을 미칠 수도 있기 때문에<br>이마저도 없앤 후에 성능 테스트를 하고 싶을 때 사용한다.<br><a href="https://openjdk.java.net/projects/code-tools/jmh/" rel="external nofollow noopener noreferrer" target="_blank">JMH</a>란 툴로 마이크로벤치마킹 할 때 이런 GC가 영향을 미치는 테스트도 있는 모양이다.</li><li>할당률이 낮거나 0인 자바 앱 등등<br>존재하기나 할까… 싶다.</li><li>회귀 테스트(정확히 뭔지 모르겠음)<br>변경된 코드 때문에 메모리 할당률이 급격히 달라지지 않았나 확인할 때 유용하다고 한다.</li></ul><p>혹시나 사용하고 싶다면 <code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code> 옵션을 주자.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>은총알은 없는 것 같습니다.<br>모든 GC에는 각자 장단점이 있으니 충분하고 검증된 테스트를 통해 본인의 상황에 맞는 GC를 고르는 역량을 길러야합니다. (이러고 작성자는 무조건 G1 GC를 디폴트로 쓰고 있습니다 ㅠㅠ)<br>또한 작성자의 역량 부족으로 인해 <a href="https://wiki.openjdk.java.net/display/zgc/Main" rel="external nofollow noopener noreferrer" target="_blank">Z GC</a>에 대해서는 다루지 못했습니다.<br>또한 Hotspot VM 계열의 GC만 다루었습니다. (제가 OpenJDK만 사용하고 있고, 다 다루기에는 이해하기도 힘들기도 하고 많기도 해서 ㅠㅠ…)<br>혹시나 다른 VM 계열의 GC(셰난도아(Shenandoah), C4, IBM J9)가 궁금하신 분은 이일웅 님께서 번역하신 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14796595" rel="external nofollow noopener noreferrer" target="_blank">자바 최적화</a>란 책을 참고하시면 좋을 것 같습니다.<br>다시 한 번 거듭 말씀드리지만 절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.</p><h2 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h2><ul><li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep" rel="external nofollow noopener noreferrer" target="_blank">Concurrent Mark and Sweep | Plumbr</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" rel="external nofollow noopener noreferrer" target="_blank">Concurrent Mark Sweep (CMS) Collector - Oracle</a>  </li><li><a href="https://d2.naver.com/helloworld/1329" rel="external nofollow noopener noreferrer" target="_blank">Java Garbage Collection - Naver D2</a>  </li><li><a href="https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99" rel="external nofollow noopener noreferrer" target="_blank">쓰레기 수집 (컴퓨터 과학) - 위키피디아</a></li><li><a href="http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html" rel="external nofollow noopener noreferrer" target="_blank">The JVM Write Barrier - Card Marking</a> </li><li><a href="https://docs.oracle.com/en/java/javase/12/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" rel="external nofollow noopener noreferrer" target="_blank">Java 12 HotSpot VM Options - Oracle</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573" rel="external nofollow noopener noreferrer" target="_blank">Java 12 Garbage-First Garbage Collector - Oracle</a>  </li><li><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" rel="external nofollow noopener noreferrer" target="_blank">Getting Started with the G1 Garbage Collector - Oracle</a>  </li><li><a href="https://imp51.tistory.com/entry/G1-GC-Garbage-First-Garbage-Collector-Tuning" rel="external nofollow noopener noreferrer" target="_blank">JVM 튜닝</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jvm-gc-advanced/thumb.jpeg&quot; alt=&quot;출처: https://medium.com/@iacomini.riccardo/hadoop-namenode-garbage-collector-tuning-7f6a029e9012&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/jvm-gc-advanced/optimizing-java.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;이 글은 이일웅 님께서 번역하신 &lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=14796595&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;자바 최적화&lt;/a&gt;란 책을 읽던 도중 공부한 내용을 정리한 글입니다.&lt;br&gt;절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.&lt;br&gt;이 글을 읽어보시기 전에 &lt;a href=&quot;/2019/05/07/jvm-gc-basic/&quot;&gt;Garbage Collection Basic&lt;/a&gt; 편을 읽어보시면 더 도움이 될 것입니다 :) &lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://perfectacle.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>(JVM) Garbage Collection Basic</title>
    <link href="https://perfectacle.github.io/2019/05/07/jvm-gc-basic/"/>
    <id>https://perfectacle.github.io/2019/05/07/jvm-gc-basic/</id>
    <published>2019-05-06T16:43:52.000Z</published>
    <updated>2019-08-22T05:34:24.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jvm-gc-basic/thumb.png" alt="PermGen은 자바 8에서 Metaspcae로 대체됐다. 이미지 출처: https://help.sap.com/">  </p><h2 id="읽기-전-주의사항-그림을-보는-법"><a href="#읽기-전-주의사항-그림을-보는-법" class="headerlink" title="읽기 전 주의사항(그림을 보는 법)"></a>읽기 전 주의사항(그림을 보는 법)</h2><p>그림을 그리다보니 Stack에 있는 동그라미 모양과 힙 메모리에 있는 동그라미 모양이 동일한 그림들이 많이 있습니다.<br>이건 <strong>둘이 동일한 메모리를 의미하는 게 아니라 그냥 스택에서 힙을 참조</strong>한다는 걸 그린 건데,<br>사실 둘의 모양을 다르게 그려야하는데 아무 생각없이 복붙해서 그리다보니 이렇게 그리게 되었고…<br>되돌리기에는 너무 많이 그림을 그려놔서(히스토리 추적이 안 되게 막 그려서…) 귀챠니즘으로 인해 그림을 수정하지 않았습니다.<br>이 점 참고하셔서 보시길 바랍니다!</p><a id="more"></a><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p><img src="/images/jvm-gc-basic/optimizing-java.jpeg" alt=""><br>이 글은 이일웅 님께서 번역하신 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14796595" rel="external nofollow noopener noreferrer" target="_blank">자바 최적화</a>란 책을 읽던 도중 공부한 내용을 정리한 글입니다.<br>절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다. </p><p>자바는 C언어와 달리 프로그래머가 일일이 쓰지 않는 메모리(가비지)를 회수할 필요가 없게 끔 가비지 컬렉터가 알아서 열일한다.<br>자바의 모든 가비지 컬렉션에는 Stop the World(어플리케이션 스레드를 모두 멈추기 때문에 어플리케이션이 멈추게 된다.)가 발생하고 GC 쓰레드만 열일하게 된다.<br><img src="/images/jvm-gc-basic/stop-the-world.png" alt="죠죠의 기묘한 모험이 떠오르는 건 왜일까... 출처: https://www.youtube.com/watch?v=_cNXjmuhCCc"><br>저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사상이 자바의 핵심이다.</p><blockquote><p>자바는 블루 컬러(주로 생산직에 종사하는 육체 노동자) 언어입니다.<br>  박사 학위 논문 주제가 아니라 일을 하려고 만든 언어죠.<br>  — 제임스 고슬링(자바의 아버지) —</p></blockquote><p>즉, 일일이 메모리 해제하는 걸 ‘박사 학위 논문 주제’ 급의 어려운 일이라고 자바에서 여기는 것이다.<br>이런 어려운 일은 우리가 할테니 너희는 일을 해라!(비즈니스 로직이나 짜라!) 이런 뉘앙스 같다.</p><p>GC는 아래 두 가지 원칙을 준수해야한다. (프로그래머가 일일이 메모리 해제하다간 이런 유형의 휴먼 에러가 발생한다는 걸 보여준다.)</p><ul><li>반드시 모든 가비지(쓰지 않는 메모리)를 수집(free)해야한다.<br>메모리만 엄~청 빵빵하다면 가비지가 많더라도 굳이 메모리 해제할 필요가 없다.<br>사실 GC도 메모리가 부족할 때만 수행한다.</li><li>살아있는 객체(접근 가능한 객체)는 절대로 수집해선 안 된다.<br>C언어에서는 살아있는 객체(접근 가능한 객체)를 해제하면 Dangling pointer가 만들어지고, 어플리케이션이 뻗거나 해당 메모리에 다른 데이터가 할당돼서 해당 데이터를 더럽히는 등의 버그가 발생하게 된다.<br>자바에서는 살아있는 객체를 수집해가면 나중에 참조하는 쪽에서 NPE(NullPointerException) 등등이 발생할 가능성이 높다.</li></ul><h2 id="Mark-and-Sweep-Algorithm"><a href="#Mark-and-Sweep-Algorithm" class="headerlink" title="Mark and Sweep Algorithm"></a>Mark and Sweep Algorithm</h2><p>자바의 GC 알고리듬의 기본은 Mark(살아있는 객체를 표시) and Sweep(쓸어담기) 알고리듬이다.</p><p><img src="/images/jvm-gc-basic/mark-and-sweep-01.png" alt="GC 루트(스택 프레임, 전역 객체 등등과 같이 메모리 풀 외부에서 내부를 가리키는 포인터)로부터 살아있는 객체(접근 가능한 객체)를 찾는다."><br><img src="/images/jvm-gc-basic/mark-and-sweep-02.png" alt="살아있는 객체를 찾으면 mark bit를 true(혹은 1)로 세팅한다."><br><img src="/images/jvm-gc-basic/mark-and-sweep-03.png" alt="모든 객체에 대해 마크가 끝났으면 이제 mark bit가 false(혹은 0)인 객체를 찾는다."><br><img src="/images/jvm-gc-basic/mark-and-sweep-04.png" alt="mark bit가 false(혹은 0)인 객체는 죽은 객체(접근 불가능한 객체)이므로 가비지 컬렉터가 수거해간다."></p><h2 id="Weak-Generational-가설"><a href="#Weak-Generational-가설" class="headerlink" title="Weak Generational 가설"></a>Weak Generational 가설</h2><blockquote><p>JVM 및 유사 소프트웨어에서 객체 수명은 이원적 분포 양상을 보인다.<br>대부분의 객체는 아주 짧은 시간만 살아있지만, 나머지 객체는 기대 수명이 훨씬 길다.</p></blockquote><p>이 법칙은 사람들이 실제 실험과 경험을 토대로 얻어냈다.<br>따라서 GC의 대상인 힙은 아래 두 가지가 핵심이라는 결론이 나왔다.</p><ul><li>젊은 객체를 빠르게 수집할 수 있도록 설계해야한다.</li><li>늙은 객체와 단명 객체를 떼어놓는 게 가장 좋다.</li></ul><p>Hotspot VM은 Weak Generational 가설을 활용해 아래와 같은 규칙을 만들었다.</p><ul><li>객체마다 generational count(객체가 지금까지 무사통과한 가비지 컬렉션 횟수)를 센다.</li><li>새로운 객체는 Young Generation이라는 공간에 생성된다.</li><li>장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역(Old Generation 또는 Tenured Generation)에 보관된다.</li></ul><p>또한 Weak Generational 가설 중에 <strong>‘늙은 객체가 젊은 객체를 참조할 일은 거의 없다.’</strong>는 내용도 있는데 아예 없는 건 아니므로<br>Hotspot VM에서는 카드 테이블(JVM이 관리하는 바이트 배열로 각 요소는 Old Generation 공간의 512 바이트 영역을 가리킨다.)이라는 자료구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록한다.<br>따라서 Young Generation의 GC가 수행될 때 늙은 객체가 젊은 객체를 참조하는지도 확인해봐야한다.<br>하지만 이 때는 늙은 객체를 전부 뒤져보는 게 아니라 카드 테이블만 뒤져보면 돼서 GC의 수행 속도를 높여준다.</p><p><img src="/images/jvm-gc-basic/c-01.png" alt="또한 메모리의 raw address를 가지고 데이터에 접근(역참조) 가능한 C언어 같은 언어는 이렇게 이분법적으로 메모리 영역을 나눈 구조와 맞지 않는다."><br><img src="/images/jvm-gc-basic/c-02.png" alt="Young Generation에서 Old Generation으로 이동한 데이터는 메모리의 raw address도 바뀔텐데, 해당 raw address로 역참조를 했을 때 메모리 재할당으로 인해 다른 값이 튀어나올 가능성이 높기 때문이다."><br>다행히 자바는 메모리의 raw address를 사용하지도 않고, offset 연산자(. 연산자)만으로 필드나 메서드에 액세스 할 수 있기 때문에 이런 문제로부터 자유롭다.</p><h2 id="Young-Generation"><a href="#Young-Generation" class="headerlink" title="Young Generation"></a>Young Generation</h2><p>Weak Generational 가설에 따라 단명하는 젊은 객체들만 모아놓은 공간이다.<br>대부분의 객체가 Young Generation에서 사망하시고, 새로 생성된 객체가 할당되기 때문에 GC가 자주 일어나는 영역이다.<br>GC가 일어나는 동안 Stop the World가 발생하는데 이 빈도가 매우 잦기 때문에 Young Generation의 GC는 수행 시간이 짧아야한다.<br>수행 시간이 짧으려면 수거해가는 객체의 수를 줄이면 되고, 객체의 수를 줄이려면 영역의 사이즈를 적당히 줄이면 된다.<br>수행 시간이 짧은 GC이기 때문에 Minor GC라고 부르는 게 아닐까?</p><p>Young Generation 사이즈를 지정하는 JVM flag는 -XX:NewSize와 -XX:MaxNewSize이며<br>-XX:NewRatio 속성을 통해 Old Generation 사이즈와 Young Generation 사이즈의 비율을 정할 수 있다.<br>예를 들어 -XX:NewRatio=3으로 지정하면 1:3=Young:Old 라고 보면 된다.<br>(Young은 힙 메모리의 1/4를 먹고, Old는 힙 메모리의 3/4를 먹게 되는 것이다.)  </p><blockquote><p>The parameters NewSize and MaxNewSize bound the young generation size from below and above.<br>Setting these to the same value fixes the young generation,<br>just as setting -Xms and -Xmx to the same value fixes the total heap size.<br>This is useful for tuning the young generation at a finer granularity than the integral multiples allowed by NewRatio.<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html</a></p></blockquote><p>-XX:NewRatio 파라미터보다는 -XX:NewSize와 -XX:MaxNewSize의 사이즈를 동일하게 설정하는 게 튜닝하는데 더 좋다고 한다.<br>아마 동일하게 설정하는 이유는 해당 영역의 사이즈가 동적으로 줄어들고 늘어나게 되면, GC에도 영향을 미치고 기타 Ratio 관련 설정을 재계산해야되기 때문에 성능에 영향을 미치지 않기 때문 아닐까…?</p><p>또한 Young Generation의 GC는 자주 일어나기 때문에 수행 시간이 매우 짧아야하니 적어도 Old Generation의 사이즈보다 적게 할당하는 게 일반적이라고 한다.<br>다만 객체의 수명이 긴 객체들이 많거나 새로운 객체의 할당이 별로 없는 객체의 경우는 Young Generation의 사이즈를 좀 더 과감하게 줄이는 등 케이스 바이 케이스로 사이즈를 정해야할 것 같다.<br>이 모든 결정은 추측이 아닌 모니터링을 통해 할당 비율이라던지 기타 등등의 데이터들을 수치화해서 정확한 데이터 기반으로 의사 결정을 내려야할 것이다. <del>(말이 쉽지 ㅠㅠ 어떻게 하는지도 모른다…)</del></p><h3 id="Eden-Space"><a href="#Eden-Space" class="headerlink" title="Eden Space"></a>Eden Space</h3><p>Young Generation의 일부분이다.<br><img src="/images/jvm-gc-basic/eden-space-01.png" alt="새롭게 생성된 객체의 용량이 Eden Space의 용량보다 큰 경우를 제외하고는 Eden 영역에 할당된다."><br><img src="/images/jvm-gc-basic/eden-space-02.png" alt="그러다가 새롭게 할당할 객체의 메모리 확보를 하지 못한 경우, 즉 Eden 영역이 꽉 찬 경우에 Minor GC를 수행하게 된다."><br><img src="/images/jvm-gc-basic/eden-space-03.png" alt="이 때 GC를 수행하게 되면 메모리 단편화가 생기게 되고 이로 인해 객체를 할당할 전체적인 용량은 확보됐지만 연속된 메모리 공간이 없게 된다."><br>OS 레벨에서는 연속된 메모리 공간에 할당하지 않고 쪼개서 할당해도 되긴 하지만 할당하는 데도 오랜 시간이 걸리고, 데이터를 불러올 때도 순차적인 접근이 아니기 때문에 오래 걸리게 된다.<br>또한 JVM의 메모리 할당은 <a href="#알아두면-좋을-상식">알아두면 좋을 상식</a>에도 나오다시피 bump-the-pointer라는 기술을 써서 저렇게 중간에 메모리를 할당하는 일은 없다.<br><img src="/images/jvm-gc-basic/eden-space-04.png" alt="아니면 GC 이후에 메모리 Compaction을 수행해야하기 때문에 오버헤드가 발생할 수 밖에 없다.">  </p><h3 id="Survivor-Space"><a href="#Survivor-Space" class="headerlink" title="Survivor Space"></a>Survivor Space</h3><p>위에서 언급한 Eden 영역에서 GC로 인해 생기는 오버헤드를 줄이고자 생긴 영역이다.<br>이 영역 또한 Young Generaion의 일부이다.<br>Survivor 영역은 동일한 사이즈의 두 개의 영역으로 구분되는데 각각의 이름은 from과 to이다.<br>(VisualVM 같은 모니터링 툴에는 S0, S1으로 표시되곤 한다.)<br><img src="/images/jvm-gc-basic/survivor-space-01.png" alt="Eden 영역에서 생존한 객체들이 Survivor 영역의 연속된 메모리 공간으로 넘어오게 되고"><br><img src="/images/jvm-gc-basic/survivor-space-02.png" alt="Eden 영역은 싹 비우게 됨으로써 Eden 영역의 제일 처음부터 할당하면 되므로 Eden 영역의 메모리 단편화 문제를 해결했다.">  </p><p>또한 -XX:SurvivorRatio 속성을 통해 Eden Space 사이즈와 Survivor Generation 사이즈의 비율을 정할 수 있다.<br>예를 들어 -XX:SurvivorRatio=6으로 지정하면 1:6=Survivor:Eden 라고 보면 된다.<br>(Suivovr는 Young Generation의 1/7를 먹고, Eden은 Young Generation의 6/7를 먹게 되는 것이다.)<br>즉, 두 Survivor 영역의 합보다 Eden 영역의 메모리가 더 크다.<br>(생존해서 Survivor 영역에 존재하는 객체보다 새롭게 생성돼서 Eden 영역에 할당되는 객체가 훨씬 많으므로…)</p><blockquote><p>You can use the parameter SurvivorRatio can be used to tune the size of the survivor spaces, but this is often not important for performance.<br>  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html</a></p></blockquote><p>퍼포먼스에 영향을 주는 경우는 드물다고 적혀있지 않으니 굳이 쓸 필요는 없을 것 같다.</p><h4 id="Survivor-Space는-왜-2개일까"><a href="#Survivor-Space는-왜-2개일까" class="headerlink" title="Survivor Space는 왜 2개일까?"></a>Survivor Space는 왜 2개일까?</h4><p><img src="/images/jvm-gc-basic/survivor-space-03.png" alt="그 이유는 Minor GC의 대상이 Eden에만 국한되는 게 아니라 Survivor 영역까지 Minor GC를 하기 때문이다."><br><img src="/images/jvm-gc-basic/survivor-space-04.png" alt="Survivor 영역을 Minor GC를 수행하면 어떻게 될까? Eden 영역만 존재할 때와 마찬가지로 Survivor 영역에도 메모리 단편화가 존재하게 된다.">  </p><p><a href="#알아두면-좋을-상식">알아두면 좋을 상식</a>에도 나오다시피 bump-the-pointer라는 기술을 써서 중간에 빈 공간이 있더라도 해당 공간에 할당하지 않는다.<br>그럼 Survivor Space의 단편화를 없애려면 어떻게 하면 될까?<br><img src="/images/jvm-gc-basic/survivor-space-05.png" alt="Eden 영역에서 Survivor 영역을 만든 것과 같이 새로운 영역을 추가하면 된다!"><br>따라서 새롭게 영역을 추가하다보니 Survivor Space가 두 개가 된 거다.</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>그럼 이제 Young Generation에서 일어나는 Minor GC에 대해서 알아보자.<br>(물론 JVM 플래그를 어떻게 주느냐에 따라서 Minor GC의 알고리듬이 달라질 수 있고, 여기서 설명하는 Minor GC의 알고리듬은 아주 간단하고 기본적인 수준에서 설명하고 있다.)</p><p><img src="/images/jvm-gc-basic/minor-gc-01.png" alt="새롭게 생성된 객체는 전부 Eden Space에 할당된다. 이 때 객체의 generational count는 0이다."><br><img src="/images/jvm-gc-basic/minor-gc-02.png" alt="새롭게 생성된 객체를 또 할당하려는데 Eden Space에 할당할 공간이 없으면 Minor GC를 수행하게 된다. 이제부터 Stop the World의 시작이다."><br><img src="/images/jvm-gc-basic/minor-gc-03.png" alt="Eden 영역에 할당된 객체를 순회하면서 GC 루트로부터 접근 가능한 객체만 mark를 한다."><br><img src="/images/jvm-gc-basic/minor-gc-04.png" alt="생존한 모든 객체(mark 당한 객체)는 Survivor Space로 복사한다."><br><img src="/images/jvm-gc-basic/minor-gc-05.png" alt="GC로부터 살아남은 객체는 이제 generational count가 1로 증가한다. (이렇게 generational count를 1씩 늘리는 프로세스를 aging이라고 부른다... 나이를 먹어가는 ㅠㅠ)"><br><img src="/images/jvm-gc-basic/minor-gc-06.png" alt="Eden Space를 비운다. (Sweep) 이제 Stop the World가 끝났다."><br><img src="/images/jvm-gc-basic/minor-gc-07.png" alt="이제 Eden Space의 공간 확보가 됐으니 새롭게 생성된 객체를 Eden Space에 할당한다."><br><img src="/images/jvm-gc-basic/minor-gc-08.png" alt="새롭게 생성된 객체를 또 할당하려는데 Eden Space에 할당할 공간이 없으면 Minor GC를 수행하게 된다. (Stop the World의 시작)"><br><img src="/images/jvm-gc-basic/minor-gc-09.png" alt="이번에는 Eden 영역과 더불어 Survivor Space에 할당된 객체를 순회하면서 GC 루트로부터 접근 가능한 객체만 mark를 한다."><br><img src="/images/jvm-gc-basic/minor-gc-10.png" alt="Survivor Space에서 생존하지 못한(mark 당하지 않은) 모든 객체를 수거해간다. (Sweep)"><br><img src="/images/jvm-gc-basic/minor-gc-11.png" alt="이 때 Survivor Space에서 생존한 객체는 generational count가 2로 증가한다."><br><img src="/images/jvm-gc-basic/minor-gc-12.png" alt="Eden Space에서 mark된(생존한) 객체는 Survivor Space로 복사된다."><br><img src="/images/jvm-gc-basic/minor-gc-13.png" alt="이 때 Eden에서 복사되는 객체는 generational count가 1로 증가한다."><br><img src="/images/jvm-gc-basic/minor-gc-14.png" alt="이제 Eden Space를 비워준다, Sweep. (Stop the World의 끝)"><br><img src="/images/jvm-gc-basic/minor-gc-15.png" alt="이제 새로운 객체를 할당하면 된다."><br><img src="/images/jvm-gc-basic/minor-gc-16.png" alt="위 과정들을 반복하다가 또 Eden Space가 꽉 차서 GC를 수행하게 됐다고 가정하자. (Stop the world의 시작)"><br><img src="/images/jvm-gc-basic/minor-gc-17.png" alt="모든 과정을 마치고 이제 Eden Space에서 생존한 객체들을 Survivor Space로 옮기려고 했더니 Survivor Space에 연속된 메모리 공간을 확보하지 못해서 더 이상 메모리 할당이 불가능하다고 가정해보자."><br><img src="/images/jvm-gc-basic/minor-gc-18.png" alt="이 때 From Survivor Space에서 생존한 모든 객체들을 To Survivor Space의 연속된 공간에 먼저 옮기고, 그 후에 Eden Space에서 생존한 객체를 To Survivor Space의 연속된 공간에 옮긴다."><br>To Survivor Space에 Eden Space에 있는 내용보다 From Survivor Space에 있는 내용을 먼저 복사하는 이유는<br>generational count가 적은 객체(Eden Space에 거주중인 객체들)보다 generational count가 높은 객체(From Survivor Space에 거주중인 객체들)의<br>수명이 더 길 가능성이 높기 때문이다. (Weak Generational 가설에 의해…)<br>수명이 더 길 가능성이 높은 메모리를 먼저 배치하는 이유는 메모리의 단편화를 줄이기 위함이다.<br><img src="/images/jvm-gc-basic/minor-gc-19.png" alt="생존한 모든 객체를 옮겼으므로 From Survivor Space와 Eden Space를 비운다."><br><img src="/images/jvm-gc-basic/minor-gc-20.png" alt="기존 From Survivor Space의 역할을 To Survivor Space가 대신하게 됐으므로 둘의 이름을 바꾼다. (Stop the World의 끝)"><br><img src="/images/jvm-gc-basic/minor-gc-21.png" alt="GC가 끝났으므로 새로운 객체를 Eden Space에 할당한다."><br><img src="/images/jvm-gc-basic/minor-gc-22.png" alt="위 과정을 반복하다가 생존을 반복한 From Survivor Space에 있는 객체가 적당히 나이를 먹었다고 가정해보자."><br><img src="/images/jvm-gc-basic/minor-gc-23.png" alt="그럼 해당 객체는 Promotion(승진)을 한다."><br><img src="/images/jvm-gc-basic/minor-gc-24.png" alt="그러다 다시 Minor GC를 해야되게 됐다."><br><img src="/images/jvm-gc-basic/minor-gc-25.png" alt="이 경우에는 흔치 않게 Old Generation에서 Young Generation을 참조하고 있어서 GC 로직이 복잡해보이는데 간단하게 카드 테이블에 저장된 객체만 추가로 검사해서 Old Generation에서 Young Generation으로 참조 중인 객체를 쉽고 빠르게 찾을 수 있다.">  </p><h4 id="Promotion"><a href="#Promotion" class="headerlink" title="Promotion"></a>Promotion</h4><p>아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다.<br><img src="promotion-01.png" alt="Promotion(승진)은 Young Generation에서 적당히 나이를 먹어서(GC로 부터 살아남아서 계속해서 generational count가 늘어나서 적당한 generational count가 됐음을 의미)"><br><img src="promotion-02.png" alt="이제 Old Generation으로 갈 나이가 됐으니 Old Generation으로 이동하는 걸 의미한다."><br>generational count가 어느정도 있으려면<del>(짬밥을 어느정도 먹었으려면)</del> 당연히 Survivor Space에 있는 객체가 이동됨을 의미한다.</p><p>적당한 나이는 -XX:InitialTenuringThreshold와 -XX:MaxTenuringThreshold 파라미터로 정할 수 있다.<br>(Old 영역으로 승진하는 객체의 갯수나 비율이 많아지면 자동으로 TenuringThreshold를 늘리는 원리인지 뭔지 잘 모르겠다…)    </p><h4 id="Premature-Promotion"><a href="#Premature-Promotion" class="headerlink" title="Premature Promotion"></a>Premature Promotion</h4><p>적당한 나이(TenuringThreshold)를 먹지 않았는데 어쩔 수 없이 Old Generation으로 이동하는 행위를 premature promotion(조기 승진)이라고 부른다.<br>아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다.<br><img src="/images/jvm-gc-basic/premature-promotion-01.png" alt="주로 메모리 할당이 잦다보니 Survivor Space에 적당한 공간이 없어서"><br><img src="/images/jvm-gc-basic/premature-promotion-02.png" alt="나이를 먹지 않았음에도 Old Generation으로 옮겨지는 경우도 Premature Promotion이고,"><br><img src="/images/jvm-gc-basic/premature-promotion-03.png" alt="새롭게 할당될 객체의 용량이 Eden Space의 용량보다 큰 경우에는"><br><img src="/images/jvm-gc-basic/premature-promotion-04.png" alt="바로 Old Generation에 할당되게 되는데 이 경우에도 Premature Promotion이고,"><br><img src="/images/jvm-gc-basic/premature-promotion-04.png" alt="원래 같으면 Eden Space의 내용이 From Survivor Space 영역의 바로 아래 공간에 할당되면 되는데, -XX:TargetSurvivorRatio(기본값 50)에 의해 할당되지 못하는 경우가 있다."><br>-XX:TargetSurvivorRatio는 Minor GC 이후의 From Survivor Space의 사용률(%)을 제한하는 옵션이다.<br><img src="/images/jvm-gc-basic/premature-promotion-06.png" alt="적당한 나이가 되지 않은 어린 객체가 Old Generation으로 이동하는 것도 Premature Promotion이다."></p><p>이 premature promotion의 경우에는 Old Generation에 놓기 때문에 Major GC 혹은 Full GC가 일어나기 전에는 회수해가지 않으며<br>적당한 나이를 먹지 않고 와서 단명할 가능성이 높음에도 불구하고 쓸데없이 Old Generation을 차지하고 있기 때문에<br>Major GC 혹은 Full GC의 발생 빈도를 늘려 어플리케이션 전반에 영향을 미치기 때문에 적절하게 Young Generation과 관련된 사이즈를 정하는 게 중요하다.</p><h2 id="Old-Generation"><a href="#Old-Generation" class="headerlink" title="Old Generation"></a>Old Generation</h2><p>객체가 적당한 나이를 먹거나 조기 승진을 통해 넘어온 객체들이 존재하는 영역이다.<br>Tenure Generation이라고도 부른다.<br>해당 영역에 존재하는 객체들을 Young Generation에 있는 객체들보다 회수당할 가능성이 적다는 게 Weak Generational 가설이다.<br>또한 대부분의 객체가 Young Generation에서 사망하시기 때문에 Old Generation으로 오는 객체는 Young Generation에 할당되는 객체의 비율에 비해 현저히 낮다.</p><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>Major GC 역시 Old Generation이 꽉 찼을 때 수행된다.<br>기본적으로 Old Generation은 메모리 할당률이 낮기 때문에 GC가 일어나는 빈도가 적다.<br>또한 대부분 Old Generation은 Young Generation 보다 용량을 크게 잡기 때문에 객체의 갯수도 많아서 GC 시간이 길다.<br>GC의 시간이 길다는 것은 그만큼 Stop the World, 어플리케이션이 멈추는 시간도 길다는 의미고 그런 의미에서 Major GC(주요한 GC)라고 이름을 붙인 게 아닐까 싶다.<br>또한 Old Generation은 Young Generation과 같이 Survivor Space가 존재하는 게 아니기 때문에 메모리 단편화도 신경써야하고 관리해야할 객체도 많다보니 훨씬 알고리듬이 복잡해진다.<br>이에 대해선 다음에 글을 써볼 예정이다.</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>Minor GC + Major GC를 Full GC라고 부른다.<br>정확히 언제 일어나는지 모르겠지만 Old Generation GC에 대해 좀 더 자세히 공부하고 다시 작성해야겠다.</p><h2 id="Permanent-Generation"><a href="#Permanent-Generation" class="headerlink" title="Permanent Generation"></a>Permanent Generation</h2><p>JVM의 Method Area를 Hotspot VM에서 Permanent Generation(줄여서 PermGen)으로 부르기 시작하면서 다른 VM에서도 PermGen이라고 부르는 것 같다.<br>PermGen은 자바 8에서 사라졌다.<br>PermGen에는 클래스의 메타데이터, 메서드의 메타데이터, 상수풀, static 변수 등등이 들어간다.<br>PermGen은 이름만 들어보면 Permanent(영구적인)가 들어가다보니 영구히 존재하는 데이터들만 저장될 거 같은데 필수는 아니지만 GC가 수행되기도 한다.<br>GC가 수행된다는 관점에서인지 이 영역을 힙 메모리로 보는 사람도 있는데 나는 클래스의 인스턴스가 저장되는 것도 아니고<br>-Xmx, -Xms와는 별개로 사이즈가 지정되다보니 힙메모리가 아니라고 생각하고 있다.<br>-XX:PermSize와 -XX:MaxPermSize로 사이즈를 지정할 수 있고, GC를 수행하지 않는다면 용량이 부족해질 수 있고 아래와 같은 OOME가 난다.<br><code>java.lang.OutOfMemoryError: PermGen space</code><br>이러한 에러가 나는 이유는 여러가지가 있는데 대표적으로 다음과 같다.</p><ul><li>collection을 static으로 만들고 계속해서 요소를 추가하는 경우(이런 실수를 범하면 절대 안된다.)</li><li>서버를 재시작하지 않고 변경 내역을 바로바로 반영해주는 HotDeploy를 계속해서 사용하다보면 Class와 Method의 메타데이터가 계속해서 쌓이게 되는데<br>서버를 주기적으로 재시작해주지 않고, 계속해서 HotDeploy 하는 경우(실서버에서 이런 경우는 거의 없을 것이다.)</li></ul><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>자바 8부터 PermGen의 역할을 Metadata 영역에서 맡기 시작했고 Native 영역으로 옮겨졌다. (즉 OS에서 관리한다는 의미)<br>PermGen 중에 일부만 Metadata 영역에서 맡기 시작했고, 상수풀이나 static 변수는 Heap 메모리로 옮겨져왔다.<br>즉, 개발자가 실수하기 쉽거나 변경이 잦은 내용들은 힙 메모리로 끌고와서 GC의 대상이 되게 하고, 정말 변경이 될 가능성이 적은 내용들만 Native 영역으로 옮겨버렸다.<br>문제는 Native 영역은 dump를 떠도 안 나와서 분석하기 힘들다는데 이럴 일은 아마 거의 없을 것이다…<br>Metadata에 대한 관리는 OS에서 함으로 믿고 맡겨도 된다고 생각하지만(개발자가 직접하는 것보다 낫지 않을까?),<br>혹시 이 쪽을 튜닝해야하거나 OOME(java.lang.OutOfMemoryError: Metadata space)가 발생한 경우에는 -XX:MetaspaceSize와 -XX:MaxMetaspaceSize 파라미터를 사용해보자.</p><h2 id="OutOfMemoryException"><a href="#OutOfMemoryException" class="headerlink" title="OutOfMemoryException"></a>OutOfMemoryException</h2><p>주로 OOME라고 줄여부르며 메모리 공간이 부족해서 나는 예외로 어플리케이션 자체가 뻗는 현상이 발생한다.<br>이 예외가 발생했을 때는 메모리 릭(메모리 결함)이 발생한 경우이고 Heap 메모리나 PermGen(Metaspace) 등등의 영역이 부족할 때 발생하는데<br>어떤 메모리가 부족한 건지, 아니면 왜 이 오류가 났는지 Stacktrace를 찍고 사망한다.</p><p>여기서는 힙 메모리가 부족해서 OOME가 발생한 경우의 원인에 대해서만 설명하겠다.<br>우선 메모리가 부족하면 가비지 컬렉터는 힙메모리의 가비지 컬렉션을 수행한다.<br>가비지 컬렉션을 수행했음에도 불구하고 새로운 객체를 더이상 할당할 수 없는 경우에 OOME가 발생하게 된다.<br>이 때는 아주 급한 경우에는 일단 -Xmx와 -Xms로 메모리를 늘리고 보고,<br><img src="/images/jvm-gc-basic/mat.png" alt="">  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=<span class="variable">$&#123;PATH&#125;</span>/<span class="variable">$&#123;FILE_NAME&#125;</span>.hprof</span><br></pre></td></tr></table></figure><p>위 두가지 설정을 주고 실행해서 재발하면 힙덤프를 생성하거나 아니면<br>jmap 등등으로 살아있는 서버의 힙덤프를 떠서 어디서 메모리 릭이 발생했는지 Eclipse MAT 등등으로 분석하거나</p><p><img src="/images/jvm-gc-basic/visual-vm.png" alt="">  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.port=<span class="variable">$&#123;JMX_PORT&#125;</span></span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span></span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span></span><br><span class="line">-Dcom.sun.management.jmxremote.rmi.port=<span class="variable">$&#123;RMI_PORT&#125;</span></span><br><span class="line">-Djava.rmi.server.hostname=<span class="variable">$&#123;HOST_NAME&#125;</span></span><br></pre></td></tr></table></figure><p>위 설정 등등을 줘서 VisualVM으로 서버에 실제로 떠있는 어플리케이션 등등을 모니터링하는 방법이 있다.</p><h2 id="알아두면-좋을-상식"><a href="#알아두면-좋을-상식" class="headerlink" title="알아두면 좋을 상식"></a>알아두면 좋을 상식</h2><ul><li>Hotspot VM의 GC는 Arena라는 메모리 영역에서 작동한다.</li><li>Hotspot VM은 시작 시 메모리를 유저 공간에 할당/관리한다.<br>따라서 힙 메모리를 관리할 때 시스템 콜을 하지 않으므로 커널 공간으로 컨텍스트 스위칭을 하지 않아서 성능 향상에 도움이 된다.</li><li>Hotspot VM은 할당된 메모리 가장 마지막의 다음 영역을 가리켜 연속된 빈 공간에 효율적으로 빠르게 할당하는 bump-the-pointer라는 기술을 사용했다.</li><li>Hotspot VM은 멀티 스레드 환경에서 객체를 할당할 때 스레드 간의 경합 등등의 문제를 줄이고자 TLAB(Thread Local Allocation Buffer)를 사용했다.<br>Eden Space를 여러 버퍼로 나누어 각 어플리케이션 스레드에게 할당함으로써 자기 자신이 사용해야 할 버퍼를 바로 찾게되고, 리소스를 공유해서 생기는 문제를 없애버렸다.<br>만약 본인에게 할당된 TLAB가 부족할 경우에는 크기를 동적으로 조정한다.</li></ul><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>해당 글을 읽고 <a href="/2019/05/11/jvm-gc-advanced/">Garbage Collection Advanced</a> 편을 읽어보시면 GC에 대해 더 깊게 이해하실 수 있을 겁니다 :)</p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://d2.naver.com/helloworld/1329" rel="external nofollow noopener noreferrer" target="_blank">Naver D2 - Java Garbage Collection</a>  </li><li><a href="https://d2.naver.com/helloworld/1230" rel="external nofollow noopener noreferrer" target="_blank">Naver D2 - JVM Internal</a>  </li><li><a href="https://www.youtube.com/watch?v=DoJr5QQYsl8" rel="external nofollow noopener noreferrer" target="_blank">The JVM and Java Garbage Collection - OLL Live (Recorded Webcast Event)</a>  </li><li><a href="https://starplatina.tistory.com/entry/JDK8%EC%97%90%EC%84%A0-PermGen%EC%9D%B4-%EC%99%84%EC%A0%84%ED%9E%88-%EC%82%AC%EB%9D%BC%EC%A7%80%EA%B3%A0-Metaspace%EA%B0%80-%EC%9D%B4%EB%A5%BC-%EB%8C%80%EC%8B%A0-%ED%95%A8" rel="external nofollow noopener noreferrer" target="_blank">JDK8에선 PermGen이 완전히 사라지고 Metaspace가 이를 대신 함.</a>  </li><li><a href="https://brunch.co.kr/@heracul/1" rel="external nofollow noopener noreferrer" target="_blank">JDK8 적용 후, 심각한 성능저하가 발생한다면?</a></li><li><a href="https://yckwon2nd.blogspot.com/2015/03/java8-permanent.html" rel="external nofollow noopener noreferrer" target="_blank">JAVA8 Permanent 영역은 어디로 가는가</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html" rel="external nofollow noopener noreferrer" target="_blank">Understand the OutOfMemoryError Exception - Oracle Docs</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">Sizing the Generations - Oracle Docs</a>  </li><li><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc" rel="external nofollow noopener noreferrer" target="_blank">Minor GC vs Major GC vs Full GC</a>  </li><li><a href="https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection/" rel="external nofollow noopener noreferrer" target="_blank">Useful JVM Flags – Part 5 (Young Generation Garbage Collection)</a></li><li><a href="http://www.herongyang.com/Java-GC/Serial-TargetSurvivorRatio-Second-Tenuring-Condition.html" rel="external nofollow noopener noreferrer" target="_blank">“-XX:TargetSurvivorRatio” - Second Tenuring Condition</a>  </li></ul><p>그 외 더 많은 거 같은데 기억이 잘 나지 않는다…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jvm-gc-basic/thumb.png&quot; alt=&quot;PermGen은 자바 8에서 Metaspcae로 대체됐다. 이미지 출처: https://help.sap.com/&quot;&gt;  &lt;/p&gt;&lt;h2 id=&quot;읽기-전-주의사항-그림을-보는-법&quot;&gt;&lt;a href=&quot;#읽기-전-주의사항-그림을-보는-법&quot; class=&quot;headerlink&quot; title=&quot;읽기 전 주의사항(그림을 보는 법)&quot;&gt;&lt;/a&gt;읽기 전 주의사항(그림을 보는 법)&lt;/h2&gt;&lt;p&gt;그림을 그리다보니 Stack에 있는 동그라미 모양과 힙 메모리에 있는 동그라미 모양이 동일한 그림들이 많이 있습니다.&lt;br&gt;이건 &lt;strong&gt;둘이 동일한 메모리를 의미하는 게 아니라 그냥 스택에서 힙을 참조&lt;/strong&gt;한다는 걸 그린 건데,&lt;br&gt;사실 둘의 모양을 다르게 그려야하는데 아무 생각없이 복붙해서 그리다보니 이렇게 그리게 되었고…&lt;br&gt;되돌리기에는 너무 많이 그림을 그려놔서(히스토리 추적이 안 되게 막 그려서…) 귀챠니즘으로 인해 그림을 수정하지 않았습니다.&lt;br&gt;이 점 참고하셔서 보시길 바랍니다!&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://perfectacle.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>(삽질기) SSH 터널링을 통해 원격지에 존재하는 도커 컨테이너 안의 JMX 모니터링하기</title>
    <link href="https://perfectacle.github.io/2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/"/>
    <id>https://perfectacle.github.io/2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/</id>
    <published>2019-05-04T23:36:13.000Z</published>
    <updated>2019-08-22T05:15:57.055Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/thumb.png" alt="네가 알던 로컬호스트가 아냐! (로컬호스트처럼 보이지만 실제론 원격지에 있는 서버에 붙었음을 의미)"></p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>JMX를 모니터링 하려면 <a href="https://visualvm.github.io/" rel="external nofollow noopener noreferrer" target="_blank">VisualVM</a>이나 JDK에 기본적으로 내장돼있는 <a href="http://openjdk.java.net/tools/svc/jconsole/" rel="external nofollow noopener noreferrer" target="_blank">JConsole</a>을 사용해야한다.</p><h2 id="로컬에서-JMX-모니터링하기"><a href="#로컬에서-JMX-모니터링하기" class="headerlink" title="로컬에서 JMX 모니터링하기"></a>로컬에서 JMX 모니터링하기</h2><p>우선 로컬에 어플리케이션을 띄우고 JMX 모니터링하기란 참 쉽다.<br>우선 자바 어플리케이션을 띄워보자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar air.jar</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="01.png" alt="그리고 모니터링 툴을 보면 바로 해당 어플리케이션이 잡혀있다."></p><h2 id="도커-컨테이너-안의-JMX-모니터링-하기"><a href="#도커-컨테이너-안의-JMX-모니터링-하기" class="headerlink" title="도커 컨테이너 안의 JMX 모니터링 하기"></a>도커 컨테이너 안의 JMX 모니터링 하기</h2><p>우선 도커 이미지 파일부터 만들어야한다.  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jdk-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY build/libs/air.jar .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD (java \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.port=9090 \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.rmi.port=9090 \</span></span><br><span class="line"><span class="bash">          -Djava.rmi.server.hostname=localhost \</span></span><br><span class="line"><span class="bash">          -jar air.jar)</span></span><br></pre></td></tr></table></figure><p>jmxremote.port와 jmxremote.rmi.port를 달리 해도 되는데 그럼 docker container의 port 2개를 host os port 2개랑 바인딩해야한다.<br>그냥 둘을 하나로 통일하면 하나만 바인딩하면 되기 때문에 굳이 두 개로 해야할 필요성을 느끼진 못했다.<br>java.rmi.server.hostname에 로컬의 사설 IP(private ip)를 넣어도 되는데 굳이 귀찮게 그렇게 할 필요성도 느끼지 못했다.<br>또한 SSH Tunneling을 거치게 됐을 때 서버의 사설 IP를 적었을 때는 접속이 불가능했으므로 <strong>무조건 localhost라고 적어주자.</strong> </p><p>해당 이미지를 빌드하고 이제 이미지를 container로 띄워보자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JMX를 모니터링 하는 것이기 때문에 어플리케이션의 포트는 바인딩하지 않았다.</span></span><br><span class="line"><span class="comment"># JMX remote port(9090)와 다른 포트를 Host OS에 매핑하면 모니터링이 불가능하다.</span></span><br><span class="line"><span class="comment"># 9091:9090 이렇게 하면 못 붙는다 무조건 9090:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.</span></span><br><span class="line"><span class="comment"># 혹시 jmx remote port와 jmx remote rmi port를 다르게 했다면 두 포트를 모두 바인딩 시켜줘야한다.</span></span><br><span class="line"><span class="comment"># jmx remote port가 9090이고 jmx remote rmi port가 9091이라면 -p 9090:9090 -p 9091:9091 이렇게 해줘야한다.</span></span><br><span class="line">docker run -p 9090:9090 air</span><br></pre></td></tr></table></figure><p>Host OS에 자바 어플리케이션이 뜬 게 아니라 컨테이너 안에서 뜬 거고, HostOS는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다.<br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/02.png" alt="좌측 상단의 해당 버튼을 클릭해주자."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/03.png" alt="localhost와 jmx remote port를 입력해주고 적당히 보기 쉬운 이름으로 Display name에 채워주고 스크린샷을 따라서 작성한 후에 OK 버튼을 눌러주자."><br>만약 jmx remote port와 jmx remote rmi port를 다르게 했더라도 입력하는 포트는 jmx remote port를 입력해줘야한다.<br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/04.png" alt="성공적으로 불러와졌다."><br>아쉽지만 도커 컨테이너로 띄우게 되면 쓰레드 덤프는 떠지지만 힙 덤프는 안 떠진다.<br><strong>혹시 도커 컨테이너로 띄웠을 때도 힙 덤프를 뜨게 하려면 어떻게 해야하는지 댓글에 남겨주시면 정말 감사하겠습니다.</strong></p><h2 id="SSH-Tunneling을-통해-원격지의-JMX-모니터링하기"><a href="#SSH-Tunneling을-통해-원격지의-JMX-모니터링하기" class="headerlink" title="SSH Tunneling을 통해 원격지의 JMX 모니터링하기"></a>SSH Tunneling을 통해 원격지의 JMX 모니터링하기</h2><p>서버를 퍼블릭 존에 두는 건 매우 위험하다. (크래커가 직접 SSH로 붙을 가능성이 존재하거나 각종 공격에 직접적으로 노출되기 때문에…)<br>따라서 프라이빗 존에 둬야하는데 VPN을 쓸 경제적 여력이 안 되는 가난한 환경이나 VPN을 적용하지 않은 환경에서는 매우 귀찮아진다.<br><del>(우리 회사가 가난하다는 게 아니다.)</del><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/aws-bastion-host.png" alt="따라서 퍼블릭 존에 Bastion Host를 두고 해당 Host를 경유해 프라이빗 존에 있는 서버에 접근하게 된다."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/aws-ssh-local-port-forwading.png" alt="이런 환경에서는 Bastion Host를 거쳐 SSH Tunneling의 일종인 Local Port Forwading을 해야한다."><br>기본적인 명령어는 위 사진에서 보는 바와 같고 명령어의 예시를 들어보겠다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JMX remote port(9090)와 다른 포트를 Localhost에 매핑하면 모니터링이 불가능하다.</span></span><br><span class="line"><span class="comment"># 9091:$&#123;application_server_ip&#125;:9090 이렇게 하면 못 붙는다.</span></span><br><span class="line"><span class="comment"># 무조건 9090:$&#123;application_server_ip&#125;:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.</span></span><br><span class="line">ssh -N -L 9090:<span class="variable">$&#123;application_server_ip&#125;</span>:9090 -i ~/.ssh/key.pem ec2-user@&#123;bastion_host_ip&#125;</span><br></pre></td></tr></table></figure><p>이번에도 역시 Host OS에 자바 어플리케이션이 뜬 게 아니라 원격지의 도커 컨테이너 안에서 뜬 거고, Localhost에는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다.<br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/02.png" alt="좌측 상단의 해당 버튼을 클릭해주자."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/05.png" alt="localhost와 jmx remote port를 입력해주고 적당히 보기 쉬운 이름으로 Display name에 채워주고 스크린샷을 따라서 작성한 후에 OK 버튼을 눌러주자."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/06.png" alt="정상적으로 접속됐다."></p><p>JMX remote port(9090)와 다른 포트를 매핑하는 바람에 몇 시간을 삽질했는지 모르겠다…<br><strong>혹시 이거보다 더 간단하게 연결하는 방법이 있다면 댓글로 남겨주시면 정말 감사하겠습니다.</strong></p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://stackoverflow.com/questions/1609961/visualvm-over-ssh" rel="external nofollow noopener noreferrer" target="_blank">VisualVM over ssh</a>  </li><li><a href="https://www.popit.kr/docker-jmx-profiling-tip/" rel="external nofollow noopener noreferrer" target="_blank">Docker 안에 숨어 있는 Web application JMX profiling Tip</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/thumb.png&quot; alt=&quot;네가 알던 로컬호스트가 아냐! (로컬호스트처럼 보이지만 실제론 원격지에 있는 서버에 붙었음을 의미)&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;JMX를 모니터링 하려면 &lt;a href=&quot;https://visualvm.github.io/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;VisualVM&lt;/a&gt;이나 JDK에 기본적으로 내장돼있는 &lt;a href=&quot;http://openjdk.java.net/tools/svc/jconsole/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;JConsole&lt;/a&gt;을 사용해야한다.&lt;/p&gt;&lt;h2 id=&quot;로컬에서-JMX-모니터링하기&quot;&gt;&lt;a href=&quot;#로컬에서-JMX-모니터링하기&quot; class=&quot;headerlink&quot; title=&quot;로컬에서 JMX 모니터링하기&quot;&gt;&lt;/a&gt;로컬에서 JMX 모니터링하기&lt;/h2&gt;&lt;p&gt;우선 로컬에 어플리케이션을 띄우고 JMX 모니터링하기란 참 쉽다.&lt;br&gt;우선 자바 어플리케이션을 띄워보자.  &lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -jar air.jar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="JMX" scheme="https://perfectacle.github.io/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) Hibernate MultipleBagFetchException 정복하기</title>
    <link href="https://perfectacle.github.io/2019/05/01/hibernate-multiple-bag-fetch-exception/"/>
    <id>https://perfectacle.github.io/2019/05/01/hibernate-multiple-bag-fetch-exception/</id>
    <published>2019-05-01T11:04:41.000Z</published>
    <updated>2019-08-22T04:55:48.521Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hibernate-multiple-bag-fetch-exception/thumb.jpg" alt="이미지 출처: https://pgr21.com/pb/pb.php?id=humor&amp;no=166185"></p><h2 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h2><p>Spring Data JPA를 이용하다보면 종종 <code>org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags</code>이란 메세지를 보게 된다.<br>우선 어떤 상황에 나타나는지 한 번 살펴보자.  </p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Daughter&gt; daughters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Son&gt; sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> List&lt;Daughter&gt; daughters, <span class="keyword">final</span> List&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> List&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> List&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엄마가 있고, 아들/딸들이 있는데 아들/딸들을 EAGER로 fetch해 올 때 발생한다.<br><strong>(즉, OneToMany, ManyToMany인 Bag 두 개 이상을 EAGER로 fetch할 때 발생한다.)</strong><br>EAGER로 땡겨오면 N+1 쿼리 문제가 존재하기 때문에 fetchType을 전부 LAZY로 바꾼 후 한 방 쿼리로 불러와도 문제는 재발한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MotherRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Mother</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@EntityGraph</span>(attributePaths = &#123;<span class="string">"daughters"</span>, <span class="string">"sons"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;Mother&gt; <span class="title">findAllWithChildrenBy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bag"><a href="#Bag" class="headerlink" title="Bag"></a>Bag</h2><p>우선 MultipleBagFetchException 파일을 둘러보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exception used to indicate that a query is attempting to simultaneously fetch multiple</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.hibernate.type.BagType bags&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>여러 BagType을 동시에 fetch 해 올 때 발생하는 예외라고 한다.<br>그럼 Bag이 뭘까…?  </p><blockquote><p>A generalization of the notion of a set is that of a multiset or bag, which is similar to a set but allows repeated (“equal”) values (duplicates).<br>  <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</a></p></blockquote><blockquote><p>A Bag is a java collection that stores elements without caring about the sequencing, but allow duplicate elements in the list.<br>  A bag is a random grouping of the objects in the list.<br>  <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</a></p></blockquote><blockquote><p>A <bag> is an unordered collection, which can contain duplicated elements.<br>  That means if you persist a bag with some order of elements, you cannot expect the same order retains when the collection is retrieved.<br>  There is not a “bag” concept in Java collections framework, so we just use a java.util.List corresponds to a <bag>.<br>  <a href="https://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate</a></bag></bag></p></blockquote><p>즉, Bag(Multiset)은 Set과 같이 순서가 없고, List와 같이 중복을 허용하는 자료구조이다.<br>하지만 자바 컬렉션 프레임워크에서는 Bag이 없기 때문에 하이버네이트에서는 List를 Bag으로써 사용하고 있는 것이다.</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>우선 두 Bag을 Set으로 바꾸면 우리가 원하는대로 한 방 쿼리로 날아간다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Daughter&gt; daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Son&gt; sons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Set&lt;Daughter&gt; daughters, <span class="keyword">final</span> Set&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> Set&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> Set&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실무에서 급하면 딱 이 수준까지만 하면 끝이고 이제 왜 Multiple Bag을 Fetch해 올 수 없는지 알아보자.  </p><p>우선 두 Bag 중 하나만 Set으로 바꾼 후 결과를 보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Daughter&gt; daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Son&gt; sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Set&lt;Daughter&gt; daughters, <span class="keyword">final</span> List&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> Set&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> List&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 MotherRepository#findAllWithChildrenBy() 메서드를 통해 호출하면 아래와 같은 결과를 볼 수 있다.<br>일단 날아간 쿼리는 아래와 같다. (혹시나 join 했을 때 자식들이 없을까봐 엄마라도 불러오려고 기본적으로 outer join을 하고 있다.)  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    mother0_.id <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">    daughters1_.id <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">    sons2_.id <span class="keyword">as</span> id1_2_2_,</span><br><span class="line">    daughters1_.mother_id <span class="keyword">as</span> mother_i2_0_1_,</span><br><span class="line">    daughters1_.mother_id <span class="keyword">as</span> mother_i2_0_0__,</span><br><span class="line">    daughters1_.id <span class="keyword">as</span> id1_0_0__,</span><br><span class="line">    sons2_.mother_id <span class="keyword">as</span> mother_i2_2_2_,</span><br><span class="line">    sons2_.mother_id <span class="keyword">as</span> mother_i2_2_1__,</span><br><span class="line">    sons2_.id <span class="keyword">as</span> id1_2_1__ </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    mother mother0_ </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">    daughter daughters1_ </span><br><span class="line">        <span class="keyword">on</span> mother0_.id=daughters1_.mother_id </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">    son sons2_ </span><br><span class="line">        <span class="keyword">on</span> mother0_.id=sons2_.mother_id</span><br></pre></td></tr></table></figure><p><img src="/images/hibernate-multiple-bag-fetch-exception/01.png" alt="주목할 부분은 파란색으로 쳐놓은 부분이다."><br>Set으로 저장한 딸들은 중복없이 잘 불러와졌고, List(Bag)로 저장한 아들들은 중복있이 잘 불러와졌다.<br>(List라고 무조건 중복이 발생하는 건 아니다. 단일 List(Bag)만 Fetch 해오면 중복없이 잘 불러온다.)  </p><p>이 결과를 Row로 표시해보자면 다음과 같다.  </p><table><thead><tr><th>mother.id</th><th>daughter.id</th><th>son.id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td></tr><tr><td>1</td><td>1</td><td>3</td></tr><tr><td>1</td><td>2</td><td>1</td></tr><tr><td>1</td><td>2</td><td>2</td></tr><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>3</td><td>1</td></tr><tr><td>1</td><td>3</td><td>2</td></tr><tr><td>1</td><td>3</td><td>3</td></tr></tbody></table><p>만약 daughters 마저도 중복도 보장이 안 되고, 순서도 보장이 안 됐다면 어떤 기준을 가지고 Row를 매핑할 수 있을까?<br>(뭐, 물론 이 경우에는 될 수도 있겠지만 좀 더 엔터티의 관계가 복잡한 경우에는 매핑이 불가능하거나 너무 복잡해지는 거 아닐까?)<br>그렇기 때문에 Multiple Bag은 Fetch가 안 되는 게 아닐까 싶다.</p><p>실제로 List로 저장한 데이터를 하이버네이트에서는 BagType으로 취급하고 있고, Set으로 저장한 데이터는 SetType으로 취급하고 있다.<br>ListType 클래스도 있긴 한데 언제 어떻게 써야하는지는 잘 모르겠다 ㅠㅠ…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hibernate-multiple-bag-fetch-exception/thumb.jpg&quot; alt=&quot;이미지 출처: https://pgr21.com/pb/pb.php?id=humor&amp;amp;no=166185&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;Trouble&quot;&gt;&lt;a href=&quot;#Trouble&quot; class=&quot;headerlink&quot; title=&quot;Trouble&quot;&gt;&lt;/a&gt;Trouble&lt;/h2&gt;&lt;p&gt;Spring Data JPA를 이용하다보면 종종 &lt;code&gt;org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags&lt;/code&gt;이란 메세지를 보게 된다.&lt;br&gt;우선 어떤 상황에 나타나는지 한 번 살펴보자.  &lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="Hibernate" scheme="https://perfectacle.github.io/tags/Hibernate/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://perfectacle.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>(삽질기) Spring Data JPA에서 Entity Manager 관련 삽질기</title>
    <link href="https://perfectacle.github.io/2019/05/01/jpa-entity-manager-with-test/"/>
    <id>https://perfectacle.github.io/2019/05/01/jpa-entity-manager-with-test/</id>
    <published>2019-05-01T08:26:48.000Z</published>
    <updated>2019-08-22T05:15:57.041Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jpa-entity-manager-with-test/thumb.png" alt="이미지 출처: http://bemil.chosun.com/nbrd/bbs/view.html?b_bbs_id=10044&amp;pn=0&amp;num=128739"></p><p>오랜만에 Spring Data JPA를 가지고 뭔가 뻘뻘 대보고 있었다.<br>하지만 내 의도대로 동작하지 않았다.<br>아래 코드를 보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SomeEntityRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.save(<span class="keyword">new</span> SomeEntity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>우선 테스트를 돌릴 때마다 DB를 초기화했다. (인메모리 DB인 H2를 사용했다.)<br>따라서 테스트 할 데이터를 setup 메서드를 통해 데이터를 DB에 밀어넣고 있었다.<br>그리고 테스트 케이스에서 해당 엔터티를 불러오는 간단한 코드인데 나는 select 쿼리가 날아갈 줄 알았다.<br>하지만 insert 쿼리만 날아가고, 이거 가지고 코드를 이리저리 바꿔보며 온갖 삽질을 한 것 같다.  </p><p>왜 select 쿼리가 찍히지 않을까… 한 2시간 가까이를 이거 때문에 계속 삽질하고 있었다.<br>그리고 스프링 관련 커뮤니티에 질문하려고 <code>아마 SomeEntity 엔터티가 생성되면서 ID 값이 어딘가에 저장돼서 동일한...</code>까지 딱 치고 있는데<br><strong>어딘가 저장</strong>에 딱 꽂혀서 아! 맞다! 하고 그동안 JPA를 안 쓴 지 오래돼서 까먹었구나… 하고 한참동안 너무 허무했었다.  </p><p>답은 JPA의 동작 방식에 있었다.<br>기본적으로 JPA는 select 쿼리를 DB에 날리기 전에 엔터티 매니저를 뒤짐으로써 성능을 향상시킨다.<br>바로 save 메서드 당시에 엔터티 매니저에 해당 엔터티를 저장한 것이다.<br>엔터티 매니저에 없는 다른 ID를 조회하거나 @Id 어노테이션이 붙지 않은 다른 필드를 조건에 줄 경우에는 실제로 select 쿼리가 날아갔다.</p><p>그럼 setup 메서드와 test 메서드에서 사용하는 엔터티 매니저가 동일하다는 것을 어떻게 알 수 있을까?<br>기본적으로 엔터티 매니저는 thread safe하지 않아서 thread 별로 한 개의 엔터티 매니저 생성을 권장하는 것으로 알고 있다.<br>따라서 Spring Data JPA에서도 그렇게 하지 않았을까…?  </p><p>아래 테스트 코드를 통해 내가 생각한 가설이 맞는 거 같다. (멀티 스레드 환경에서 돌려본 건 아니긴 하지만…)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SomeEntityRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SomeEntity entity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        entity = <span class="keyword">new</span> SomeEntity();</span><br><span class="line">        </span><br><span class="line">        assertFalse(em.contains(entity));</span><br><span class="line"></span><br><span class="line">        repository.save(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(Long.valueOf(<span class="number">1L</span>), entity.getId());</span><br><span class="line">        assertTrue(em.contains(entity));</span><br><span class="line"></span><br><span class="line">        repository.findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본에 충실해야겠다 ㅠㅠ…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jpa-entity-manager-with-test/thumb.png&quot; alt=&quot;이미지 출처: http://bemil.chosun.com/nbrd/bbs/view.html?b_bbs_id=10044&amp;amp;pn=0&amp;amp;num=128739&quot;&gt;&lt;/p&gt;&lt;p&gt;오랜만에 Spring Data JPA를 가지고 뭔가 뻘뻘 대보고 있었다.&lt;br&gt;하지만 내 의도대로 동작하지 않았다.&lt;br&gt;아래 코드를 보자.  &lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@RunWith&lt;/span&gt;(SpringRunner.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@DataJpaTest&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MotherTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SomeEntityRepository repository;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Before&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        repository.save(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SomeEntity());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        repository.findById(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
      <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) 생애 첫 Heap 메모리 분석기 (feat. Eclipse MAT)</title>
    <link href="https://perfectacle.github.io/2019/04/28/heap-memory-analytics-with-eclipse-mat/"/>
    <id>https://perfectacle.github.io/2019/04/28/heap-memory-analytics-with-eclipse-mat/</id>
    <published>2019-04-28T14:25:38.000Z</published>
    <updated>2019-08-22T04:55:48.509Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/heap-memory-analytics-with-eclipse-mat/thumb.png" alt=""></p><p>어느 날 서비스가 갑자기 다운되는 사례가 발생했다.<br>다행히 서버를 이중화시켜놓아서 장애가 발생하진 않았지만 그래도 왜 다운된 건지 원인 분석을 해야했다.<br>나의 실수로 인해 WAS 로그는 제대로 남겨져있지 않았고, CTO 님께서 힙 덤프 같은 거라도 떠져있나 보라고 하셔서 지푸라기라도 잪는 심정으로 기대를 했는데 희망을 저버리지 않았다. </p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError \</span><br><span class="line">-XX:HeapDumpPath=./jvm.hprof</span><br></pre></td></tr></table></figure><p>위 옵션으로 인해 OOME(Out of Memory Exception) 발생 시 힙 덤프를 뜨게 해놓았는데 다행히 힙 덤프가 존재했다.  </p><p>여기서 힙 덤프는 힙 메모리의 내용을 그대로 떠놓은 파일이다.<br>따라서 힙 메모리에 어떤 객체들로 가득 채워져있었는지 분석할 수 있게 되었다.<br><strong>여기서 흥분해서 서버에서 vi 등등을 이용해 힙 덤프 파일을 열면 안 된다. (용량이 큰 로그 및 다른 파일도 물론 서버에서 절대 열면 안 된다.)</strong><br>여는 순간 힙 메모리 사이즈만큼 <strong>서버의 메모리를 사용하게 돼서 서버가 다운</strong>될 수도 있다.<br>무조건 scp 등등의 명령어를 통해 로컬로 복사한 후에 열어보는 습관을 가지자.</p><h2 id="Eclipse-Memory-Analyzer-MAT"><a href="#Eclipse-Memory-Analyzer-MAT" class="headerlink" title="Eclipse Memory Analyzer (MAT)"></a><a href="https://www.eclipse.org/mat/" rel="external nofollow noopener noreferrer" target="_blank">Eclipse Memory Analyzer (MAT)</a></h2><p><a href="https://spoqa.github.io/2012/02/06/eclipse-mat.html" rel="external nofollow noopener noreferrer" target="_blank">Eclipse Memory Analyzer 소개</a>와 <a href="https://d2.naver.com/helloworld/1326256" rel="external nofollow noopener noreferrer" target="_blank">하나의 메모리 누수를 잡기까지</a>에서 힙 덤프를 분석하는데 Eclipse MAT를 사용했다길래 나도 한 번 사용해보았다.<br><a href="https://www.eclipse.org/mat/downloads.php" rel="external nofollow noopener noreferrer" target="_blank">다운로드</a> 페이지에서 OS에 맞는 어플리케이션을 받으면 되는데 나는 MacOSX 버전을 다운받았다.  </p><p><img src="/images/heap-memory-analytics-with-eclipse-mat/01.png" alt="식별되지 않은 개발자가 만든 앱이라고 실행되지 않는다... 역시 보안에 빡센 애플"><br><img src="/images/heap-memory-analytics-with-eclipse-mat/02.png" alt="Security &amp; Privacy의 General 탭에서 빨간색 표시친 곳에서 Open Anyway를 누르자."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/03.png" alt="그럼 MAT를 열 수 있게 된다."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/04.png" alt="함정카드 발동... 아직도 열 수가 없다."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/05.png" alt="MAT를 Applications 디렉토리로 옮긴 후에 열어보자."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/06.png" alt="드디어 정상적으로 열렸다 ㅠㅠ... 이제 빨간색 표시친 Open a Heap Dump를 통해 로컬로 복사한 힙 덤프 파일을 열어보자."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/07.png" alt="Heap Dump 파싱이 끝난 후 Leak Suspects Report를 체크 후 finish를 누르자."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/08.png" alt="Leak Suspects Report를 보니 com.mysql.jdbc.JDBC42ResultSet 클래스의 인스턴스가 1.8GB나 존재했다.">  </p><p>일단 툴의 사용방법도 잘 몰라서 무작정 메세지를 가지고 검색해보았다.<br>우선 최대한 일반적인 메세지만 뽑아서 <code>One instance of &quot;com.mysql.jdbc.JDBC42ResultSet&quot; loaded by</code>를 통해 구글링을 하니<br><a href="https://bugs.mysql.com/bug.php?id=90240" rel="external nofollow noopener noreferrer" target="_blank">MySQL Bugs: #90240: Possible memory leak in JDBC42PreparedStatement</a>란 글이 눈에 띄었다.<br>메모리 릭? 버그? 그럼 우리가 쓰고 있는 MySQL 관련된 무언가에서 버그가 존재한다는 것인가?란 생각이 들었다.  </p><blockquote><p>Please try with MySQL connector 5.1.45 or 5.1.44 versions and let us know if memory leak happening.</p></blockquote><p>위와 같이 답변이 달린 걸 보고 음… 역시 MySQL 버그인가 보구나… MySQL connector 버전을 올려보자~ 하고 gradle의 디펜던시를 보니 해당 버전보다도 높았다.<br>그래서 뭐지? 하고 답변을 끝까지 쭉 봤더니</p><blockquote><p>It was an application error loading too many rows in memory, nothing to do with the connector.</p></blockquote><p>어플리케이션에서 너무 많은 row를 로딩해서 생긴 문제라고 했다.<br>CTO 님께 말씀드려보니 CTO 님도 보시더니 아마도 저 문제가 맞을 거라고 하셨다.<br>그리고 우리가 저렇게 Row를 많이 불러올만한 쿼리를 쓰는 게 주문 내역 등등을 엑셀로 다운로드 받는 기능에서 날 거라고 말씀해주셨다.<br>따라서 해당 소스코드를 분석해봤는데 카운트 쿼리를 통해 사전에 너무 많은 Row를 불러오는 걸 방지하고 있었다.<br>그럼 어디서 이렇게 많은 Row를 불러오는 쿼리를 사용하지…? 도무지 이해가 가지 않았다.<br>그래서 다른 시니어 개발자 분의 도움을 받아 MAT의 간단한 사용 방법을 익혔다.  </p><h2 id="분석-및-해결"><a href="#분석-및-해결" class="headerlink" title="분석 및 해결"></a>분석 및 해결</h2><p><img src="/images/heap-memory-analytics-with-eclipse-mat/09.png" alt="Leak Suspects Report에서 Details를 클릭하자."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/10.png" alt="그럼 위와 같은 정보를 발견할 수 있는데 위 정보를 토대로 대략 120만 Row의 데이터를 불러왔다는 걸 알 수 있다."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/11.png" alt="최상위 Object를 클릭해서 List objects &gt; with outgoing references를 클릭하자."><br>incoming이면 해당 object를 참조하는 object를, outgoing이면 해당 object가 참조하고 있는 object를 포함해서 보여준다.<br>자세한 설명은 <a href="https://dzone.com/articles/eclipse-mat-incoming-outgoing-references" rel="external nofollow noopener noreferrer" target="_blank">Eclipse MAT — Incoming, Outgoing References</a>를 참고하자.  </p><p><img src="/images/heap-memory-analytics-with-eclipse-mat/12.png" alt="해당 Object에서 참조 중인 수많은 Row 데이터들을 볼 수 있다."><br><img src="/images/heap-memory-analytics-with-eclipse-mat/13.png" alt="임의의 Row를 까봤는데 metadata라는 의미심장한 필드가 보이고 그 안에 완벽하진 않지만 쿼리문이나 테이블 이름 등등의 정보를 볼 수 있다."><br>다른 Row들도 까봤더니 모두 동일한 필드 및 테이블에서 데이터를 가지고 오고 있었다.<br>이를 통해 해당 테이블의 모든 Row를 가져오는 거라고 의심했고 해당 테이블을 실제로 보니 대략 120만 Row의 데이터가 있었다.<br>실제로 소스코드도 보았더니 해당 테이블을 토대로 엑셀을 다운로드 받는 기능이 어딘가에 <del>숨겨져</del>있었고 제대로 조건문이 걸려있지 않았다.<br>또한 Nginx의 Access log를 보니 힙 덤프가 떠지기 바로 직전에 해당 API를 호출한 이력도 있었다.</p><p>결국 해당 쿼리문에 조건을 추가해서 배포함으로써 해당 이슈는 일단락 짓게 되었다.<br>어찌보면 별 거 아니고, 내가 로그를 제대로 남겼더라면 힙덤프까지 안 봤을지도 몰랐겠지만<br>내가 로그를 남기지 않는 실수로 인해 힙 덤프를 분석해볼 수 있는 값진 기회가 주어졌다. <del>(절대로 노린 건 아니다.)</del><br>앞으로 이런 일이 있으면 안 되겠지만, 이런 일을 경험해보지 않고서 더 좋은 개발자로 다가가긴 힘든 것 같다.<br>역시 소프트웨어는 개발도 중요하지만 그 후에 유지보수를 해나가는 경험 또한 매우 중요한 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/heap-memory-analytics-with-eclipse-mat/thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;어느 날 서비스가 갑자기 다운되는 사례가 발생했다.&lt;br&gt;다행히 서버를 이중화시켜놓아서 장애가 발생하진 않았지만 그래도 왜 다운된 건지 원인 분석을 해야했다.&lt;br&gt;나의 실수로 인해 WAS 로그는 제대로 남겨져있지 않았고, CTO 님께서 힙 덤프 같은 거라도 떠져있나 보라고 하셔서 지푸라기라도 잪는 심정으로 기대를 했는데 희망을 저버리지 않았다. &lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="Heap" scheme="https://perfectacle.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) Nginx upstream에 AWS ELB DNS를 걸 때 주의사항</title>
    <link href="https://perfectacle.github.io/2019/04/28/nginx-proxy-aws-elb/"/>
    <id>https://perfectacle.github.io/2019/04/28/nginx-proxy-aws-elb/</id>
    <published>2019-04-28T12:53:56.000Z</published>
    <updated>2019-08-22T05:54:34.646Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nginx-proxy-aws-elb/thumb.png" alt="ALB는 Cross-Zone Load Balancing 옵션이 무조건 활성화돼있다."><br>얼마 전에 서버를 새롭게 이전했다.<br>기존에 있던 local의 upstream server 대신에 새로운 서버로 업스트림을 걸어놨다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>LB에 바로 도메인을 붙여도 되지만 롤백을 최대한 빨리하기 위해 기존 서버에서 LB로 업스트림 걸어놓았다.</p><ol><li>만약 새로운 서버에서 문제가 생겼다고 가정  </li><li>이 때 LB에 바로 도메인을 달아놓았다면…<br>2-1. 기존의 서버로 다시 도메인 변경<br>2-2. DNS 캐시가 날아갈 때까지 유저에게 장애 발생<br>2-3. 클라이언트의 설정에 따라서 DNS 캐시가 언제 날아갈지 모르는 상황… (과연 일반 유저들이 브라우저의 DNS 캐시 지우는 방법을 알고 있을까?)</li><li>이 때 기존 서버는 내비두고 LB로 업스트림을 걸어놓았다면…<br>3-1. 기존 로컬 서버를 업스트림 서버로 변경<br>3-2. nginx -s reload<br>3-3. 수 초 이내로 원래 서버로 원복</li></ol><h2 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h2><p>하지만 문제는 며칠 후 발생했다.<br>ELB의 DNS로 접속하면 잘 되는데 기존 서버 도메인으로 접속하면(LB를 upstream으로 걸어놓은) 1분 가까운 시간이 흐른 후에 502 Bad Gateway가 나는 것이었다.<br>우선 급한 마음에 <code>nginx -s reload</code> 명령어를 입력했더니 다시 또 정상 동작하는 것이었다.<br>Nginx의 Access Log까지는 정상적으로 남은 걸 보니 LB를 찾지 못해서 일정 시간동안 기다리다가 502를 뱉었던 것 같았다.<br>나는 딱히 설정을 바꾼 것도 없는데… 잘 동작하니 귀신이 곡할 노릇이었다.  </p><h2 id="ELB-동작-방식"><a href="#ELB-동작-방식" class="headerlink" title="ELB 동작 방식"></a>ELB 동작 방식</h2><p><a href="https://aws.amazon.com/articles/best-practices-in-evaluating-elastic-load-balancing/" rel="external nofollow noopener noreferrer" target="_blank">Best Practices in Evaluating Elastic Load Balancing</a>을 보면 다음과 같은 구문이 나온다.</p><blockquote><p>The controller will also monitor the load balancers and manage the capacity that is used to handle the client requests.<br>  The Elastic Load Balancing service will update the Domain Name System (DNS) record of the load balancer when it scales so that the new resources have their respective IP addresses registered in DNS.<br>  The DNS record that is created includes a Time-to-Live (TTL) setting of 60 seconds, with the expectation that clients will re-lookup the DNS at least every 60 seconds.<br>  컨트롤러는 로드 밸런서를 모니터링하고 클라이언트의 요청을 핸들링하는 capacity를 관리한다.<br>  Elastic Load Balancing은 스케일링할 때 로드 밸런서의 DNS 레코드를 업데이트한다. (새로운 리소스의 IP는 DNS에 등록된다.)<br>  DNS 레코드의 TTL은 60초로 세팅돼있고, 60초가 지나면 클라이언트는 다시 lookup한다.</p></blockquote><p>ELB는 트래픽에 따라서 알아서 스케일링되는 모양이다.<br>또한 TTL은 60초이다.<br>따라서 ELB의 아이피 주소는 매우 유동적이다. (늘어났다가 줄어들었다가… 혹은 LB가 다운되면 새로 생성한다던지…)</p><h2 id="Nginx-동작-방식"><a href="#Nginx-동작-방식" class="headerlink" title="Nginx 동작 방식"></a>Nginx 동작 방식</h2><p><a href="https://www.nginx.com/blog/dns-service-discovery-nginx-plus/" rel="external nofollow noopener noreferrer" target="_blank">Using DNS for Service Discovery with NGINX and NGINX Plus</a>  </p><blockquote><p>NGINX caches the DNS records until the next restart or configuration reload, ignoring the records’ TTL values.<br>  NGINX는 restart나 reload가 발생할 때까지 DNS record를 캐시하고 record의 TTL을 무시한다.</p></blockquote><p>즉, ELB의 TTL인 60초는 무시되고, 설정파일을 읽을 당시에 DNS Lookup이 진행되기 때문에 ELB Scaling이 진행된 후에는 정상 동작하리란 보장을 할 수 없다.<br>설정파일을 읽을 당시에 DNS Lookup을 통해 얻어온 LB의 IP 주소가 트래픽 감소에 의해 더 이상 유효하지 않은 IP 주소가 됐을 가능성이 높기 때문이다.  </p><h1 id="Shooting"><a href="#Shooting" class="headerlink" title="Shooting"></a>Shooting</h1><p><a href="https://www.nginx.com/blog/dns-service-discovery-nginx-plus/" rel="external nofollow noopener noreferrer" target="_blank">Using DNS for Service Discovery with NGINX and NGINX Plus</a></p><blockquote><p>When you use a variable to specify the domain name in the proxy_pass directive, NGINX re‑resolves the domain name when its TTL expires.<br>  You must include the resolver directive to explicitly specify the name server (NGINX does not refer to /etc/resolv.conf).<br>  By including the valid parameter to the resolver directive, you can tell NGINX to ignore the TTL and re‑resolve names at a specified frequency instead.<br>  proxy_pass directive의 domain name에 변수를 명시할 경우, NGINX는 domain name의 TTL이 만료됐을 때 다시 resolve한다.<br>  resolver directive에 name server를 꼭 명시해줘야한다. (NGINX는 /etc/resolv.conf 파일을 참조하지 않는다.)<br>  resolver directive에 valid parameter를 명시하면 TTL을 무시하고 valid parameter의 주기로 다시 resolve한다.</p></blockquote><p>우리가 해야할 일은 이제 다음과 같다.</p><ol><li><code>/etc/resolv.conf</code> 파일을 참조하여 resolver directive에 name server를 명시해준다.  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br><span class="line"><span class="comment"># ; generated by /usr/sbin/dhclient-script</span></span><br><span class="line"><span class="comment"># search ap-northeast-2.compute.internal</span></span><br><span class="line"><span class="comment"># options timeout:2 attempts:5</span></span><br><span class="line"><span class="comment"># nameserver 10.12.0.2</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        resolver 10.12.0.2;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>resolver directive에 valid parameter에 ELB DNS의 TTL인 60보다 작은 값을 세팅한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        resolver 10.12.0.2 valid=30s;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>proxy_pass directive의 domain name에 변수를 명시한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        resolver 10.12.0.2 valid=30s;</span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="built_in">set</span> <span class="variable">$elb</span>-dns elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">            proxy_pass http://<span class="variable">$elb</span>-dns;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>nginx -s reload</code>를 통해 다운타임 없이 설정파일을 재적용한다.</p></li></ol><h2 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h2><ul><li><a href="https://aws.amazon.com/articles/best-practices-in-evaluating-elastic-load-balancing/" rel="external nofollow noopener noreferrer" target="_blank">Best Practices in Evaluating Elastic Load Balancing</a></li><li><a href="https://stackoverflow.com/questions/3821333/amazon-ec2-elastic-load-balancer-does-its-ip-ever-change" rel="external nofollow noopener noreferrer" target="_blank">Amazon EC2 Elastic Load Balancer: Does its IP ever Change?</a></li><li><a href="https://medium.com/@circlee7/nginx-proxy-pass-%EC%9D%98-aws-elb-%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95-f0c4b792ef71" rel="external nofollow noopener noreferrer" target="_blank">Nginx proxy_pass 의 AWS ELB 연결 문제</a></li><li><a href="http://tech.kkung.net/blog/nginx-with-elb/" rel="external nofollow noopener noreferrer" target="_blank">Nginx를 ELB Reverse Proxy로 사용할때 주의 점</a></li><li><a href="https://serverfault.com/questions/560632/some-nginx-reverse-proxy-configs-stops-working-once-a-day" rel="external nofollow noopener noreferrer" target="_blank">Some nginx reverse proxy configs stops working once a day</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/nginx-proxy-aws-elb/thumb.png&quot; alt=&quot;ALB는 Cross-Zone Load Balancing 옵션이 무조건 활성화돼있다.&quot;&gt;&lt;br&gt;얼마 전에 서버를 새롭게 이전했다.&lt;br&gt;기존에 있던 local의 upstream server 대신에 새로운 서버로 업스트림을 걸어놨다.  &lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    server &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        location / &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="AWS" scheme="https://perfectacle.github.io/tags/AWS/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="ELB" scheme="https://perfectacle.github.io/tags/ELB/"/>
    
      <category term="Nginx" scheme="https://perfectacle.github.io/tags/Nginx/"/>
    
      <category term="Proxy" scheme="https://perfectacle.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>무중단 배포란...?</title>
    <link href="https://perfectacle.github.io/2019/04/21/non-stop-deployment/"/>
    <id>https://perfectacle.github.io/2019/04/21/non-stop-deployment/</id>
    <published>2019-04-21T14:03:23.000Z</published>
    <updated>2019-08-22T05:54:34.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/non-stop-deployment/thumbs.jpg" alt=""></p><p>실제로 우리가 간단하게 서버를 배포하는 시나리오를 생각해보자.</p><ol><li>80포트(혹은 다른 포트)에 우리의 서버를 띄운다.</li><li>새롭게 배포할 내용이 있다고 하면 포트가 충돌나면 안 되기 때문에 서버를 다운시킨다.  </li><li>(옵션) 유저의 이탈을 방지하고자 공사중 이미지를 띄운다.  </li><li>80포트(혹은 다른 포트)에 새롭게 배포할 서버를 띄운다.</li></ol><a id="more"></a><p>만약 서버가 뜨는데 30초가 걸린다고 하면 최소 30+@초만큼 다운타임(유저에게 서비스가 불가능한 시간)이 발생한다.<br>현대의 어플리케이션이라면 유저에게 최상의 경험을 제공해주기위해 이런 다운타임이 없는 무중단 배포를 지원해야한다.  </p><h3 id="필요-조건"><a href="#필요-조건" class="headerlink" title="필요 조건"></a>필요 조건</h3><p><strong>두 대 이상의 서버(혹은 서버 어플리케이션을 두 개)를 서비스해야한다.</strong><br>다운타임이 발생하지 않으려면 실제 서비스 중인 서버와 새롭게 배포한 서버가 동시에 존재해야한다.<br>비용을 줄이려면 배포할 때만 새롭게 서버를 띄우고 배포가 완료된 후에 기존 서버는 죽이면 된다.</p><h3 id="Rolling-Deployment"><a href="#Rolling-Deployment" class="headerlink" title="Rolling Deployment"></a>Rolling Deployment</h3><p><img src="/images/non-stop-deployment/elb-basic.png" alt="SPOF를 피하려면 어플리케이션 서버는 물론이고 로드 밸런서도 이중화해야한다."><br>HA(High Availability)을 위해 프로덕션 환경은 2대 이상의 서버로 구성한다.<br>이런 환경에서 무중단 배포하기 가장 간단한 방법이 바로 Rolling 배포이다.<br>시나리오는 다음과 같다.  </p><ol><li>서버 1을 로드 밸런서에서 뺀다.  </li><li>서버 1에 배포한다.  </li><li>서버 1을 다시 로드 밸런서에 넣는다.  </li><li>서버 2를 로드 밸런서에서 뺀다.  </li><li>서버 2에 배포한다.  </li><li>서버 2를 다시 로드 밸런서에 넣는다.</li></ol><p>위와 같이 하면 다운타임 없이 배포가 가능하다.<br>배포해야할 서버가 너무 많다면 1대씩 배포하면 너무 느리니 N대 단위로 배포하기도 한다.<br>하지만 배포가 끝나기 전까지는 누구는 이전 버전을 서비스 받고, 누구는 신규 버전을 서비스 받는 등의 문제가 존재한다.<br>또한 1대에 배포하는 거보다 최소 2배 이상 느리다. (아무리 못해도 2번 이상의 배포가 진행되기 때문에)</p><h3 id="Canary-Deployment"><a href="#Canary-Deployment" class="headerlink" title="Canary Deployment"></a>Canary Deployment</h3><p><img src="/images/non-stop-deployment/canary.png" alt=""><br>광부들이 광산에서 유독가스가 나오는 것을 알아내기 위해서 가스에 민감한 카나리아(조류)를 광산 안에서 키웠다고 해서 유래된 배포이다.<br>소수의 유저(혹은 사내)만 사용하는 환경(Canary 환경)에 신규 버전을 배포하고 문제가 없다고 판단됐을 때 다른 모든 서버에 배포한다.<br>Canary 환경은 뭐 QA Phase가 될 수도 있고, 랜덤하게 유저를 Canary 환경으로 라우팅시킬 수도 있고 구현하기 나름이다.  </p><h3 id="Blue-Green-Deployment"><a href="#Blue-Green-Deployment" class="headerlink" title="Blue/Green Deployment"></a>Blue/Green Deployment</h3><p><img src="/images/non-stop-deployment/thumbs.jpg" alt=""><br><strong>실제로 서비스 중인 환경(Blue)</strong>과 <strong>새롭게 배포할 환경(Green)</strong>을 세트로 준비해서 배포하는 방식을 말한다.<br>장점으로는 새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠르다. (배포할 서버가 N대라 하더라도 N대의 Green 서버에 동시에 배포하면 되기 때문에)<br>또한 언제나 Green 환경이 떠있기 때문에 만약에 잘못된 버전으로 배포를 했을 경우에 신속하게 롤백이 가능하다. (수 백대의 서버에 거의 수 초 이내에 롤백이 가능함.)<br>물론 언제나 Green 환경이 떠있어야하기 때문에 비용이 두 배로 든다는 단점도 있다.<br>또한 Green 환경에서 Scheduler와 같은 배치성 Job이 도는 경우에 레거시 버전으로 돌기 때문에 장애가 발생할 가능성도 존재한다.<br>(이럴 때는 배포를 연속적으로 두 번 해서 Blue와 Green의 버전을 일치시키는 것 이외에는 딱히 떠오르지 않는다 ㅠㅠ…)</p><p>이렇게 설명하면 이해가 잘 안 가니 그림과 함께 이해해보자.<br>(그림에서는 Nginx를 프록시 서버로 사용했지만 Apache 등등을 사용해도 무방하다.<br>또한 하나의 서버에 두 대의 어플리케이션을 띄우는 걸로 설명했지만 별도의 서버에 하나의 어플리케이션만 각각 띄워서 구성해도 된다.)</p><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p><img src="/images/non-stop-deployment/blue-green-02.png" alt="젠킨스와 같은 CI를 사용해서 Green 환경에 배포를 완료한다."></p><p><img src="/images/non-stop-deployment/blue-green-03.jpg" alt="Nginx와 같은 프록시 서버에서 80포트로 들어오면 Green 환경으로 라우팅하도록 설정한다.">  </p><h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><p><img src="/images/non-stop-deployment/blue-green-04.jpg" alt="만약에 새로 배포한 Blue 환경에서 버그가 발생했다고 가정해보자.">  </p><p><img src="/images/non-stop-deployment/blue-green-05.jpg" alt="이 때 프록시 서버에서 80포트의 라우팅을 Green 환경으로만 옮겨서 Blue와 Green을 바꾸기만 하면 롤백이 끝난다.">  </p><p><img src="/images/non-stop-deployment/blue-green-06.jpg" alt="물론 Green 환경이 사망해계신 상태에서는 롤백이 불가능하다."></p><p>더 자세한 설명은 <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html" rel="external nofollow noopener noreferrer" target="_blank">Martin Fowler가 쓴 블로그 글</a>을 참고하자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/non-stop-deployment/thumbs.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;실제로 우리가 간단하게 서버를 배포하는 시나리오를 생각해보자.&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;80포트(혹은 다른 포트)에 우리의 서버를 띄운다.&lt;/li&gt;
&lt;li&gt;새롭게 배포할 내용이 있다고 하면 포트가 충돌나면 안 되기 때문에 서버를 다운시킨다.  &lt;/li&gt;
&lt;li&gt;(옵션) 유저의 이탈을 방지하고자 공사중 이미지를 띄운다.  &lt;/li&gt;
&lt;li&gt;80포트(혹은 다른 포트)에 새롭게 배포할 서버를 띄운다.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Middle-end" scheme="https://perfectacle.github.io/categories/Middle-end/"/>
    
      <category term="DevOps" scheme="https://perfectacle.github.io/categories/Middle-end/DevOps/"/>
    
    
      <category term="Deployment" scheme="https://perfectacle.github.io/tags/Deployment/"/>
    
  </entry>
  
  <entry>
    <title>(Docker) Spring Boot Application Image 최적화하기</title>
    <link href="https://perfectacle.github.io/2019/04/16/spring-boot-docker-image-optimization/"/>
    <id>https://perfectacle.github.io/2019/04/16/spring-boot-docker-image-optimization/</id>
    <published>2019-04-15T18:19:58.000Z</published>
    <updated>2019-08-22T05:54:34.575Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/spring-boot-docker-image-optimization/thumb.png" alt=""></p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>이 글에서 Docker와 Spring Boot, Gradle에 대한 기본적인 지식은 있다고 판단하고 설명한다.<br>프로젝트는 <a href="https://github.com/perfectacle/spring-boot-docker-demo" rel="external nofollow noopener noreferrer" target="_blank">spring-boot-docker-demo 저장소</a>에서 단계별로 브랜치를 확인해보면 된다.<br>이해를 돕기 위해 docker image tag 단위로 branch를 땄다.</p><a id="more"></a><p>프로젝트의 build.gradle은 아래와 같다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.1.4.RELEASE'</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">archivesBaseName = <span class="string">'demo'</span></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'11'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">    testImplementation <span class="string">'io.projectreactor:reactor-test'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="가장-간단한-Spring-Boot-Docker-Image-만들기"><a href="#가장-간단한-Spring-Boot-Docker-Image-만들기" class="headerlink" title="가장 간단한 Spring Boot Docker Image 만들기"></a>가장 간단한 Spring Boot Docker Image 만들기</h2><p>이 상태에서 gradle wrapper를 이용해 build를 수행해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>그렇다면 build/libs 디렉토리에 <strong>demo-0.0.1-SNAPSHOT.jar</strong>란 파일이 만들어진다.<br>(build.gradle의 archivesBaseName과 version 값에 의해 위와 같은 이름으로 생성된다.)</p><p>이제 실행 가능한 jar 파일이 생성됐으니 Docker 이미지를 만들어서 해당 jar 파일을 실행하게 만들어보기 위해서 Dockerfile을 생성하자.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY build/libs/demo-0.0.1-SNAPSHOT.jar .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java -jar demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure><p>이제 이미지를 빌드해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t $&#123;imageName&#125;:$&#123;tagName&#125; .</span></span><br><span class="line"><span class="comment"># 예제에서는 이해를 돕기 위해 임의로 이미지와 태그 이름을 임의로 설정함.</span></span><br><span class="line"><span class="comment"># perfectacle은 글쓴이의 docker hub 아이디이므로 본인의 docker hub 아이디를 입력해야 docker hub repository 충돌이 일어나지 않는다.</span></span><br><span class="line"></span><br><span class="line">docker build -t perfectacle/spring-boot-demo:basic .</span><br></pre></td></tr></table></figure><p>이제 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run --rm -d -p $&#123;hostPort&#125;:$&#123;containerPort&#125; --name $&#123;containerName&#125; $&#123;imageName&#125;:$&#123;tagName&#125;</span></span><br><span class="line"><span class="comment"># --rm 옵션은 컨테이너를 stop 하면 자동으로 컨테이너를 죽여버린다.</span></span><br><span class="line"><span class="comment"># -d 옵션은 백그라운드에서 컨테이너를 실행한다는 옵션이다.</span></span><br><span class="line"><span class="comment"># 예제에서는 이해를 돕기 위해 포트나 컨테이너 이름 등등의 값을 임의로 설정함.</span></span><br><span class="line"></span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:basic</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 프로젝트의 com.example.demo.Router 파일에서 GET / 에 대한 라우터, 핸들러를 만들어두었다.</span></span><br><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok</span></span><br></pre></td></tr></table></figure><p>ok라는 텍스트가 출력이 됐다면 성공적으로 컨테이너가 뜬 것이다.<br>혹시나 <code>curl: (52) Empty reply from server</code>란 오류가 뜬다면 서버가 아직 뜨지 않은 것이니 10초 정도 기다렸다가 다시 시도해보자.</p><p>이제 <a href="https://hub.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a>에 우리가 작업한 이미지를 올려보자.<br>(물론 Docker Hub에 Repository가 존재하는 상태로 시작해야한다.)  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker push $&#123;repositoryName&#125;:$&#123;tagName&#125;</span></span><br><span class="line">docker push perfectacle/spring-boot-demo:basic</span><br><span class="line"></span><br><span class="line"><span class="comment"># The push refers to repository [docker.io/perfectacle/spring-boot-demo]</span></span><br><span class="line"><span class="comment"># b61d0959344e: Pushing [================&gt;                                  ]  6.096MB/18.22MB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Mounted from library/openjdk</span></span><br></pre></td></tr></table></figure><p>Docker Image는 여러 레이어로 겹겹이 쌓여있다.<br>우리가 Dockerfile에 선언한 <code>FROM openjdk:11-jre-slim</code> 부분에 의해 openjdk:11-jre-slim 이미지의 레이어에서부터 쌓아가는 것이다.<br>4bbad98352e9 ~ 5dacd731af1b까지가 openjdk:11-jre-slim 이미지의 레이어를 사용한 것이다.<br>그리고 제일 윗 라인에 b61d0959344e 이 부분이 Dockerfile의 <code>COPY build/libs/demo-0.0.1-SNAPSHOT.jar .</code>에 의해 생긴 레이어이다.<br>바로 저 jar 파일이 하나의 레이어를 차지하고 있는 것이다.<br>그럼 이 레이어란 건 어떻게 쓰이는지는 좀이따 살펴보자.</p><p>이제 어플리케이션 코드를 한 번 수정해보자.<br><code>com.example.demo.Router</code> 파일을 아래와 같이 수정해보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(GET(<span class="string">""</span>),</span><br><span class="line">                                     serverRequest -&gt; ServerResponse.ok()</span><br><span class="line">                                                                    .contentType(MediaType.TEXT_PLAIN)</span><br><span class="line">                                                                    .body(BodyInserters.fromObject(<span class="string">"ok!"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ok</code>에서 <code>ok!</code>로 바꿨을 뿐이다.  </p><p>이제 다시 소스 코드를 빌드해주자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>바뀐 소스 코드를 토대로 도커 이미지를 만들자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:basic-change-app .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 포트 및 컨테이너 이름 충돌을 방지하고자 전에 띄워놨던 컨테이너를 멈추자.</span></span><br><span class="line"><span class="comment"># 이전에 --rm 옵션을 줬기 때문에 stop을 하면 자동으로 컨테이너까지 죽여버린다.</span></span><br><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:basic-change-app</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:basic-change-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 54f0c4fe51ff: Pushing [=&gt;                                                 ]  590.8kB/18.22MB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>레이어의 진가가 여기서 나온다.<br>4bbad98352e9 ~ 5dacd731af1b까지가 openjdk:11-jre-slim 이미지의 레이어이고,<br>perfectacle/spring-boot-demo:basic 이미지에서 이미 사용했고 해당 이미지는 이미 Docker Hub에 올려두었다.<br>따라서 해당 레이어를 <strong>재활용</strong>하는 것이다.<br>이건 push 뿐만 아니라 pull에도 해당하는 내용이다.<br>실제 디스크에서 차지하는 용량도 해당 레이어를 재활용하기 때문에 이미지 push/pull 속도 및 용량 측면에서도 매우 효율적이다.  </p><h2 id="Spring-Boot-Docker-Image-최적화하기"><a href="#Spring-Boot-Docker-Image-최적화하기" class="headerlink" title="Spring Boot Docker Image 최적화하기"></a>Spring Boot Docker Image 최적화하기</h2><p>이렇게 레이어를 잘 구성해서 재활용할 수 있는 부분을 최대한 늘리는 게 이번 포스트에서 진행할 최적화의 한 방법이다.<br>하지만 우리는 레이어를 잘 활용하고 있지 못하고 있다.  </p><p>basic 태그의 이미지를 올릴 때도 <code>b61d0959344e: 18.22MB</code>를 업로드 했고,<br>basic-change-app 태그의 이미지를 올릴 때도 <code>54f0c4fe51ff: 590.8kB/18.22MB</code>를 업로드 했다.<br>우리가 변경한 부분은 매우 작은 것 같은데, 왜 이렇게 많은 용량을 업로드하는 것일까?<br>그건 우리가 jar 파일을 하나의 레이어로 구성했기 때문이다. </p><p>우선 jar 파일이 어떻게 구성돼있는지 한 번 까보자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/libs</span><br><span class="line">tar -xvf demo-0.0.1-SNAPSHOT.jar</span><br><span class="line">ls</span><br><span class="line"><span class="comment"># 우리가 여기서 눈여겨 볼 것은 BOOT-INF 디렉토리이다.</span></span><br><span class="line"><span class="comment"># BOOT-INF META-INF demo-0.0.1-SNAPSHOT.jar org</span></span><br><span class="line"></span><br><span class="line">ls BOOT-INF</span><br><span class="line"><span class="comment"># classes에는 우리가 작성한 어플리케이션 소스 코드가 들어있고, lib 디렉토리에는 라이브러리들(*.jar)이 들어있다.</span></span><br><span class="line"><span class="comment"># classes lib</span></span><br></pre></td></tr></table></figure><p>즉, 우리는 classes에 있는 파일만 수정했음에도 불구하고 lib에 있는 파일까지 같은 레이어로 묶어서 push하고 있던 것이다.<br>레이어를 재활용하기 위해선 jar 파일을 분해해서 이렇게 어플리케이션 레이어와 라이브러리 레이어를 쪼개야 최대한 레이어를 재활용할 수 있다.  </p><p>빌드 후에 매번 저렇게 jar 파일을 분해하기 귀찮으니 build task를 손 봐주자.<br>build.gradle에서 아래 내용을 추가해주자.  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task unpackJar(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    <span class="keyword">def</span> unpackDir = <span class="string">"$buildDir/unpack"</span></span><br><span class="line">    </span><br><span class="line">    delete unpackDir</span><br><span class="line">    from zipTree(jar.getArchiveFile())</span><br><span class="line">    into unpackDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build &#123;</span><br><span class="line">    finalizedBy unpackJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 Dockerfile에서 어플리케이션 레이어와 라이브러리 레이어를 분리시키자.  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/classes/ app</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/lib/ lib</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java -cp app:lib/* com.example.demo.DemoApplication</span></span><br></pre></td></tr></table></figure><p>이제 바뀐 task로 빌드해보자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>jar 파일이 <code>build/libs/unpack</code>에 제대로 풀어졌는지 확인해보고 이제 새로운 도커 이미지를 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># aefdad4cf83c: Pushing [=&gt;                                                 ]  592.9kB/18.12MB</span></span><br><span class="line"><span class="comment"># c132ceeeb517: Pushing [==================================================&gt;]  9.728kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>aefdad4cf83c는 라이브러리 레이어이고, c132ceeeb517는 어플리케이션 레이어이다.  </p><p>여기까지 문제가 없긴한데 Dockerfile에서 메인 클래스(com.example.demo.DemoApplication)를 하드코딩하는 게 매우 귀찮다.<br>JarLauncher를 이용해서 하드코딩 하는 부분을 없애보자! (물론 JarLauncher를 쓰면 main class를 하드코딩하는 거 보다 아주 조금 느리게 서버가 뜬다.)<br>Dockerfile을 아래와 같이 수정해주자.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/classes BOOT-INF/classes</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/META-INF META-INF</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/org org</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure><p>덕지덕지 클래스패스 붙던 게 사라지고, 메인 클래스 하드코딩하던 부분도 사라졌다.</p><p>이미 빌드는 했고, 소스코드에 변경된 건 없으므로 새로운 도커 이미지를 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher</span><br><span class="line"></span><br><span class="line"><span class="comment"># 55e024f80fff: Pushing [==================================================&gt;]  221.7kB</span></span><br><span class="line"><span class="comment"># fb71d1d0e2a1: Pushing [==================================================&gt;]  3.072kB</span></span><br><span class="line"><span class="comment"># 182065791613: Pushing [=&gt;                                                 ]  593.4kB/18.12MB</span></span><br><span class="line"><span class="comment"># b0d121a9a0fe: Pushing [==================================================&gt;]  9.728kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>위 Dockerfile에도 단점이 존재한다.<br>바로 레이어가 4개나 존재한다는 것이다.<br>우리는 어플리케이션 레이어/라이브러리 레이어로만 구분하려고 했는데 <strong>메인 클래스 하드코딩, 클래스패스</strong> 두 가지 문제점 때문에 또 다른 문제점을 만들어냈다.<br>이제 레이어를 다시 두 개로 줄여보자.</p><p>먼저 Copy의 횟수를 줄여야 레이어를 줄일 수 있으니 Copy하기 좋게 BOOT-INF/lib 폴더만 다른 곳으로 빼야한다.<br>그러기 위해서는 build task와 관련된 task들을 아래와 같이 수정해야한다.  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">task moveLib &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> unpackDir = <span class="string">"$buildDir/unpack"</span></span><br><span class="line">        ant.move(<span class="string">file:</span> <span class="string">"$&#123;unpackDir&#125;/app/BOOT-INF/lib"</span>, <span class="string">toFile:</span> <span class="string">"$&#123;unpackDir&#125;/lib"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task unpackJar(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    <span class="keyword">def</span> unpackDir = <span class="string">"$buildDir/unpack"</span></span><br><span class="line"></span><br><span class="line">    delete unpackDir</span><br><span class="line">    from zipTree(jar.getArchiveFile())</span><br><span class="line">    into <span class="string">"$unpackDir/app"</span></span><br><span class="line"></span><br><span class="line">    finalizedBy moveLib</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build &#123;</span><br><span class="line">    finalizedBy unpackJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 Dockerfile을 아래와 같이 수정해서 레이어를 두 개(어플리케이션, 라이브러리)로 만들자.  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/app .</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure><p>이제 바뀐 task로 빌드해보자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>lib 폴더가 <code>build/libs/unpack/app/BOOT-INF</code>에 없고 <code>build/libs/unpack/</code>에 있는지 확인해보고<br>이제 새로운 도커 이미지를 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer</span><br><span class="line"></span><br><span class="line"><span class="comment"># aeafcfee4d7d: Pushing [=&gt;                                                 ]  593.4kB/18.12MB</span></span><br><span class="line"><span class="comment"># f69cb2892736: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>다시 레이어가 두 개로 줄어들었다.</p><p>그럼 이제 어플레이션 코드만 수정하고 과연 라이브러리 레이어는 재활용하는지 살펴보자.<br><code>com.example.demo.Router</code> 파일을 아래와 같이 수정해보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(GET(<span class="string">""</span>),</span><br><span class="line">                                     serverRequest -&gt; ServerResponse.ok()</span><br><span class="line">                                                                    .contentType(MediaType.TEXT_PLAIN)</span><br><span class="line">                                                                    .body(BodyInserters.fromObject(<span class="string">"ok!"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ok!</code>에서 <code>ok!!</code>로 바꿨을 뿐이다.  </p><p>소스코드가 바뀌었으니 다시 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>새로운 도커 이미지로 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># e5ff3f17bd79: Pushing [==&gt;                                                ]    790kB/18.12MB</span></span><br><span class="line"><span class="comment"># 6f4d8004dddf: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>엥? 어플리케이션 소스코드만 바꿨는데 왜 라이브러리 레이어는 재활용하지 못하는 거지?<br>그럼 혹시 라이브러리를 추가했을 때 어플리케이션 레이어는 재활용할까?</p><p>build.gradle에 modelmapper를 디펜던시로 추가해보자.  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">    testImplementation <span class="string">'io.projectreactor:reactor-test'</span></span><br><span class="line">    implementation <span class="string">'org.modelmapper:modelmapper:2.3.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>디펜던시를 추가했으니 다시 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>새로운 도커 이미지로 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1902203c1efa: Pushing [==&gt;                                                ]  921.1kB/21.94MB</span></span><br><span class="line"><span class="comment"># 6f4d8004dddf: Layer already exists</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>어플리케이션 레이어는 재활용이 잘 되고 변경된 라이브러리 레이어만 push 하는 걸 볼 수 있다.</p><p>근데 통상적으로 라이브러리 레이어보다 어플리케이션 레이어의 변경이 잦고,<br>라이브러리 레이어의 용량이 더 커서 라이브러리 레이어를 재활용하는 게 훨씬 효율적이다.</p><p>혹시 Dockerfile에 선언한 레이어의 순서에 뭔가 연관이 있지 않을까 싶어 Dockerfile을 아래와 같이 수정해보았다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/app .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure><p>COPY 구문의 순서만 뒤바꾼 것이다. (lib 먼저, 그 다음에 app 레이어를 쌓게 끔)  </p><p>이미 빌드는 했고, 소스코드에 변경된 건 없으므로 새로운 도커 이미지를 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:change-layer-order .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:change-layer-order</span><br><span class="line"></span><br><span class="line"><span class="comment"># 43e70d9a1e7a: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 44d3b0d75158: Pushing [========&gt;                                          ]  3.919MB/21.94MB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>레이어 순서를 바꾼 후 첫 Push이기 때문에 어플리케이션/라이브러리 레이어 모두 push 하고 있다.</p><p>이제 어플리케이션 코드를 바꿔보자.<br><code>com.example.demo.Router</code> 파일을 아래와 같이 수정해보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(GET(<span class="string">""</span>),</span><br><span class="line">                                     serverRequest -&gt; ServerResponse.ok()</span><br><span class="line">                                                                    .contentType(MediaType.TEXT_PLAIN)</span><br><span class="line">                                                                    .body(BodyInserters.fromObject(<span class="string">"ok!!!!"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ok!!</code>에서 <code>ok!!!!</code>로 바꿨을 뿐이다.</p><p>소스코드가 바뀌었으니 다시 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>새로운 도커 이미지로 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:change-layer-order-and-app .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order-and-app</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:change-layer-order-and-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13f989ce91ed: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 44d3b0d75158: Layer already exists</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>우리가 바라던대로 용량이 큰 라이브러리 레이어는 재활용하고 있고, 용량이 작은 어플리케이션 레이어는 변경했기 때문에 push하고 있다. </p><p>그럼 혹시 라이브러리 레이어를 수정했을 때 어플리케이션 레이어는 재활용할지 한 번 실험을 해보자.<br>build.gradle에 modelmapper의 버전을 바꿔보.  </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">    testImplementation <span class="string">'io.projectreactor:reactor-test'</span></span><br><span class="line">    implementation <span class="string">'org.modelmapper:modelmapper:2.3.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>디펜던시를 변경했으니 다시 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><p>새로운 도커 이미지로 빌드하자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:change-layer-order-and-lib .</span><br></pre></td></tr></table></figure><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order-and-lib</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:change-layer-order-and-lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7a3da3f26c6b: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># c67d124680cf: Pushing [&gt;                                                  ]  265.7kB/25.75MB</span></span><br><span class="line"><span class="comment"># 6f4d8004dddf: Layer already exists</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>아쉽지만 라이브러리 레이어만 바꿨다고 해서 어플리케이션 레이어를 재활용 할 순 없다.<br>그래도 어플리케이션 레이어는 대부분 라이브러리 레이어 보다 용량이 적고,<br>라이브러리 레이어가 변경이 되는 거보다 어플리케이션 레이어가 변경될 확률이 훨씬 높다.<br>따라서 어플리케이션 레이어를 재활용하는 것보다 라이브러리 레이어를 재활용하는 것이 훨씬 낫다.</p><h2 id="레이어-순서에-따라서-재활용할-수-있는-레이어가-달라진다"><a href="#레이어-순서에-따라서-재활용할-수-있는-레이어가-달라진다" class="headerlink" title="레이어 순서에 따라서 재활용할 수 있는 레이어가 달라진다"></a>레이어 순서에 따라서 재활용할 수 있는 레이어가 달라진다</h2><p>우리의 Dockerfile을 보면 아래와 같다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;buildDir&#125;</span>/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/app .</span></span><br></pre></td></tr></table></figure><p>어플리케이션 레이어<br>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ<br>라이브러리 레이어</p><p>위와 같이 라이브러리 레이어 위에 어플리케이션 레이어를 쌓고 있다.<br>이 상황에서 어플리케이션 레이어만 수정하면 아래 있는 라이브러리 레이어를 재활용 할 수 있다.<br>하지만 라이브러리 레이어를 바꾼다면 라이브러리 레이어를 쌓고 그 위에 다시 어플리케이션 레이어를 쌓아야한다.<br>따라서 어플리케이션 레이어를 재활용하지 못하는 것이다.<br>도커 이미지는 마치 스택 자료구조 안에 레이어들을 쌓아간다고 생각하면 좀 더 이해하기 쉬운 것 같다.</p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://spring.io/guides/topicals/spring-boot-docker" rel="external nofollow noopener noreferrer" target="_blank">TOPICAL GUIDE Spring Boot Docker</a>  </li><li><a href="https://toedter.com/2017/09/23/optimizing-docker-images-for-spring-boot/" rel="external nofollow noopener noreferrer" target="_blank">Optimizing Docker Images for Spring Boot</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/spring-boot-docker-image-optimization/thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;이 글에서 Docker와 Spring Boot, Gradle에 대한 기본적인 지식은 있다고 판단하고 설명한다.&lt;br&gt;프로젝트는 &lt;a href=&quot;https://github.com/perfectacle/spring-boot-docker-demo&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;spring-boot-docker-demo 저장소&lt;/a&gt;에서 단계별로 브랜치를 확인해보면 된다.&lt;br&gt;이해를 돕기 위해 docker image tag 단위로 branch를 땄다.&lt;/p&gt;
    
    </summary>
    
      <category term="Middle-end" scheme="https://perfectacle.github.io/categories/Middle-end/"/>
    
      <category term="DevOps" scheme="https://perfectacle.github.io/categories/Middle-end/DevOps/"/>
    
    
      <category term="Spring Boot" scheme="https://perfectacle.github.io/tags/Spring-Boot/"/>
    
      <category term="Docker" scheme="https://perfectacle.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>어떻게 웹플럭스는 적은 쓰레드만으로 많은 요청을 처리할 수 있을까?</title>
    <link href="https://perfectacle.github.io/2019/03/10/how-can-webflux-process-huge-requests-with-fewer-threads/"/>
    <id>https://perfectacle.github.io/2019/03/10/how-can-webflux-process-huge-requests-with-fewer-threads/</id>
    <published>2019-03-10T10:24:38.000Z</published>
    <updated>2019-08-22T04:55:48.482Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/how-can-webflux-process-huge-requests-with-fewer-threads/thumb.png" alt=""></p><p>기본적으로 SpringMVC에서 많이 사용하는 WAS인 Tomcat의 경우에는 기본적으로 쓰레드 풀의 갯수가 200개이고,<br>Jetty의 경우에는 기본적으로 minimum 8개에서 maximum 200개로 설정돼있다.<br>쓰레드 생성 비용은 비싸므로(오래 걸리므로) 미리 생성해서 ThreadPool에 쌓아놓는 것이다.<br>여기서 말하는 Thread는 <a href="/2019/03/10/green-thread-vs-native-thread/">Green Thread vs Native Thread</a>에서 얘기하다 싶이 Native Thread(OS에서 관리하는 Thread)이다.<br>이 말은 동시에 요청을 최대 200개까지 처리 가능하단 얘기이다.</p><a id="more"></a><p>그에 반해 Webflux는 core * 2의 Thread만을 생성한다.<br>SpringMVC에 비해 턱없이 모자란 쓰레드 갯수이고 그럼 싱글 코어의 경우에는 동시에 2개의 요청밖에 처리하지 못할 것처럼 보인다.  </p><h2 id="SpringMVC는-어떻게-동작하는가"><a href="#SpringMVC는-어떻게-동작하는가" class="headerlink" title="SpringMVC는 어떻게 동작하는가?"></a>SpringMVC는 어떻게 동작하는가?</h2><ol><li>요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다.  </li><li>그러다 I/O(File I/O, Network I/O 등등)가 발생하면 CPU를 block 시킨다. (idle 상태에 빠진다.)  </li><li>이 때 다른 요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다.  </li><li>이런 식으로 쓰레드를 돌아가면서 요청을 처리하고 block이 풀리면 작업을 이어나간다.  </li></ol><h2 id="Webflux는-어떻게-동작하는가"><a href="#Webflux는-어떻게-동작하는가" class="headerlink" title="Webflux는 어떻게 동작하는가?"></a>Webflux는 어떻게 동작하는가?</h2><p>Webflux는 기본적으로 아래의 쓰레드로 이루어진다.  </p><ol><li>요청을 받는 쓰레드 (이하 A 쓰레드라 칭함)  </li><li>block 상태에서 풀린 쓰레드의 요청을 처리하는 쓰레드 (이하 B 쓰레드라 칭함)</li><li>block 상태가 풀렸는지 무한 루프 돌면서 감시하는 event loop를 위한 쓰레드 (몇 개의 쓰레드가 쓰이는지는 케바케, 이하 C 쓰레드라 칭함.)  </li></ol><p>통상적으로 event loop를 위한 쓰레드의 갯수는 정확하지 않으므로 Webflux에서는 core * 2개의 쓰레드를 사용한다고 한다.<br>그럼 어떻게 그 적은 쓰레드(리소스, 비용)로 수많은 요청을 동시에 처리할 수 있는 걸까?</p><ol><li>요청이 들어오면 A 쓰레드에서 요청을 처리한다.  </li><li>그러다 I/O(File I/O, Network I/O 등등)가 발생하면 CPU를 block 시킨다. (idle 상태에 빠진다.)  </li><li>이런 비동기 작업을 처리하기 위해 Queue에 넣는다.  </li><li>A 쓰레드는 계속해서 요청을 받아서 처리한다.  </li><li>동시에 C 쓰레드에서 Queue를 무한 루프 돌면서 감시를 한다.</li><li>Event Loop에서 감시를 하다가 작업이 끝난 이벤트가 있으면 B 쓰레드에서 해당 이벤트를 처리한다.</li></ol><p>이런 일련의 흐름으로 인해 CPU가 놀 틈 없이 열심히 돌릴 수 있다.</p><h2 id="Webflux는-왜-CPU-Core-2개의-쓰레드를-사용할까"><a href="#Webflux는-왜-CPU-Core-2개의-쓰레드를-사용할까" class="headerlink" title="Webflux는 왜 CPU Core * 2개의 쓰레드를 사용할까?"></a>Webflux는 왜 CPU Core * 2개의 쓰레드를 사용할까?</h2><p>단순히 쓰레드 생성 비용이 비싸니까 쓰레드를 적게 쓰는 Webflux가 성능 상 뛰어나다고 생각하면 안 된다.<br>조금만 더 인심 쓰지… 왜 2개만으로도 충분하다고 생각하는 걸까? 하나 더 생성하면 조금 더 좋아지는 것 아닐까?? </p><p>쓰레드가 많다는 건 뭔가?<br>결국 쓰레드 사이에서 공유 자원의 <a href="/2019/03/10/java-synchronized-note/">동기화</a> 이슈가 걸려있다.<br>쓰레드가 많으면 많을 수록 동기화 이슈로 인해 시간이 오래 걸리게 된다.<br>따라서 Thread가 적으면 적을 수록 동기화 이슈로 인한 문제에 덜 시달리게 된다.</p><p>또한 CPU는 한 번에 하나의 작업 밖에 수행하지 못한다.<br>따라서 CPU Core 갯수보다 더 많은 쓰레드를 생성하는 건 무의미하게 동기화 이슈를 늘리는 것에 불과하다.<br>하지만 Webflux에서 Core * 2개의 갯수를 만든 이유는 무엇일까?<br>아는 사람이 있다면 댓글로 남겨주길 바란다.  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/how-can-webflux-process-huge-requests-with-fewer-threads/thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;기본적으로 SpringMVC에서 많이 사용하는 WAS인 Tomcat의 경우에는 기본적으로 쓰레드 풀의 갯수가 200개이고,&lt;br&gt;Jetty의 경우에는 기본적으로 minimum 8개에서 maximum 200개로 설정돼있다.&lt;br&gt;쓰레드 생성 비용은 비싸므로(오래 걸리므로) 미리 생성해서 ThreadPool에 쌓아놓는 것이다.&lt;br&gt;여기서 말하는 Thread는 &lt;a href=&quot;/2019/03/10/green-thread-vs-native-thread/&quot;&gt;Green Thread vs Native Thread&lt;/a&gt;에서 얘기하다 싶이 Native Thread(OS에서 관리하는 Thread)이다.&lt;br&gt;이 말은 동시에 요청을 최대 200개까지 처리 가능하단 얘기이다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://perfectacle.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="Srping" scheme="https://perfectacle.github.io/tags/Srping/"/>
    
      <category term="Webflux" scheme="https://perfectacle.github.io/tags/Webflux/"/>
    
      <category term="Reactive" scheme="https://perfectacle.github.io/tags/Reactive/"/>
    
  </entry>
  
</feed>
