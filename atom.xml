<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>오늘도 끄적끄적</title>
  
  <subtitle>Toss Server Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://perfectacle.github.io/"/>
  <updated>2020-01-24T06:52:03.948Z</updated>
  <id>https://perfectacle.github.io/</id>
  
  <author>
    <name>양권성</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>공인인증서</title>
    <link href="https://perfectacle.github.io/2020/01/24/korean-certification/"/>
    <id>https://perfectacle.github.io/2020/01/24/korean-certification/</id>
    <published>2020-01-24T06:52:03.000Z</published>
    <updated>2020-01-24T06:52:03.948Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/korean-certification/thumb.png" alt="npki라는 디렉리토리 안에 보관돼있는 공인인증서의 공개키(*.der)와 비밀키(*.key)"></p><h2 id="인증서는-왜-쓸까"><a href="#인증서는-왜-쓸까" class="headerlink" title="인증서는 왜 쓸까"></a>인증서는 왜 쓸까</h2><p>A가 데이터를 보냈는데 이게 진짜 A가 보낸 건지 아닌지를 검증할 수가 없다.<br>인증서는 A라는 사람이라는 것을 <strong>보증해주는 문서</strong>라고 보면 된다.<br>따라서 A한테 메세지가 올 때 A의 인증서가 오지 않는다면 A라고 취급을 하지 않으면 된다.<br>하지만 개나소나 인증서를 발급할 수 있으면 A 행세를 아무나 낼테니까 <strong>인증된 기관(CA, Certificate Authority)</strong>으로부터 적절한 절차를 거쳐 인증서를 발급받을 수 있다.</p><a id="more"></a><p><img src="/images/korean-certification/google-certificate.png" alt="구글에서 사용 중인 인증서"><br>우리가 알고 있는 TLS 인증서(https 도메인마다 발라져있는) 같은 경우에도 이런 절차를 거쳐 발급된다.<br>그리고 이런 인증서들은 <strong>X.509(공개키 인증서 포맷의 표준)</strong>라는 표준을 준수한다.</p><h2 id="공인인증서는-왜-나왔을까"><a href="#공인인증서는-왜-나왔을까" class="headerlink" title="공인인증서는 왜 나왔을까"></a>공인인증서는 왜 나왔을까</h2><p>인터넷 뱅킹이나 온라인 쇼핑몰 등등을 이용하기 위해서는 보안이 취약해서는 안되며 이를 위해서 인증서 사용은 필수이다.</p><p><a href="https://news.joins.com/article/521864" rel="external nofollow noopener noreferrer" target="_blank">https://news.joins.com/article/521864</a><br>하지만 과거에는 미국의 수출 금지법에 의해 미국을 제외한 나라에서는 브라우저에서 56bit 길이 이하의 약한 암호화 방식 밖에 사용할 수 없었다.</p><p>따라서 국내에서 직접 암호화 알고리즘인 SEED(128bit 길이, 2009년부터는 256bit 길이도 제공)를 개발하고,<br>해당 알고리즘을 사용하는 <strong>공인인증서</strong>도 만들게 되었다. 하지만 국제 표준 암호 알고리즘도 아니고 국내에서만 인증된 CA에서 발급한 인증서이다보니 웹 브라우저에서 사용할 수 없었다.<br>따라서 당시 국내 점유율이 압도적인 IE에서 사용이 가능한 ActiveX라는 기술을 사용하여 공인인증서를 사용할 수 있게 만들었다.</p><p>과거에는 어쩔 수 없는 선택일 수 밖에 없었을 것 같은데 브라우저에서 해당 제약이 사라진 요즘같은 시대에<br>비표준 기술을 위해 ActiveX나 설치형 프로그램을 잔뜩 깔아야하는 건 아마 여러 이해관계가 얽혀있기 때문이 아닐까 싶다.<br>(그 때문에 사용자만 엄청 고생하는 ㅠㅠ…)</p><h2 id="공인인증서-구조"><a href="#공인인증서-구조" class="headerlink" title="공인인증서 구조"></a>공인인증서 구조</h2><p><img src="/images/korean-certification/certifiacate-and-key.png" alt="공인인증서와 개인키 파일"><br>MacOS는 /Users/사용자이름/Library/Preferences/NPKI,<br>Windows 10는 C:\Users\사용자이름\AppData\LocalLow\NPKI에 위치하고 있다.</p><p>공인인증서(*.der, *.cer 등등)와 개인키(*.key)파일로 이루어져있다.<br>아니면 공인인증서와 개인키 파일이 합쳐진 형태(*.p12, *.pfx 등등)로 이루어진 경우도 있다.<br>공인인증서와 개인키 파일이 합쳐진 형태는 PKCS#12(<strong>P</strong>ublic <strong>K</strong>ey <strong>C</strong>ryptography <strong>S</strong>tandards, 공개키 암호화 표준의 12번째 표준)을 준수하고 있다.<br>PKCS#12는 다수의 <code>X.509 인증서 + 개인키</code> 묶음을 하나의 파일로 저장하기 위한 표준이다.</p><h2 id="공인인증서"><a href="#공인인증서" class="headerlink" title="공인인증서"></a>공인인증서</h2><p>*.cer(Canonical Encoding Rules) 또는 *.der(Distinguished Encoding Representation)과 같은 확장자를 가지며 바이너리 형태로 인코딩 돼있다.</p><p><img src="/images/korean-certification/certificate.png" alt="MacOS의 Keychain Access에서 본 공인인증서 정보"><br>공인인증서는 <strong>X.509 V3</strong>을 따른다.<br>또한 공인인증서 소유자의 <strong>공개키</strong> + CA(Certificate Authority, 발행기관) 정보 및 <strong>전자서명</strong> + 사용목적 + 유효기간 등등이 저장돼있다.</p><p>위 인증서는 은행에서 사용 중인 공인인증서인데 은행에 대한 정보는 1도 없다.<br>아마 은행은 CA가 아니기 때문에 CA에게 대신 발급 요청(CSR, Certificate Signing Request)을 하고 발급받은 인증서를 개인에게 전달해주는 시스템 같다.<br>아마 보안모듈은 공인인증서를 전달받으면 해당 CA로부터 발급된 인증서가 맞는지 검증까지 해주는 것 같다.<br>(TLS 인증서였다면 이런 행위는 브라우저가 알아서 해주겠지만…)<br>CA(인증서 발급 기관, Certificate Authority)에게 인증서 발급을 요청할 때 요청자의 공개키를 함께 보낸다.<br>그러면 CA는 서명(CA의 개인키로 암호화)한 인증서를 발급해준다.<br>그리고 인증서 안에는 <strong>인증서 발급 요청자의 공개키</strong>가 포함돼있고, 어떤 용도의 인증서인지,<br>어느 기관(CA, Certificate Authority)에서 발급한 건지 등등의 정보가 포함돼있다.</p><p><img src="/images/korean-certification/not-trusted-certificate.png" alt="MacOS의 Keychain Access에서 공인인증서는 신뢰할 수 없다고 나온다."><br>또한 공인인증서는 국내에서만 사용하는 인증서이기 때문에 OS 레벨에서는 해당 인증서가 신뢰된 CA로부터 발급받은 인증서인지 알 수가 없다.<br>(그냥 은행이나 공공기관 등등을 믿고 쓰는 수 밖에…)</p><h2 id="비밀키-key"><a href="#비밀키-key" class="headerlink" title="비밀키 (*.key)"></a>비밀키 (*.key)</h2><p><img src="/images/korean-certification/key-format-desc.png" alt=""><br><a href="https://www.rootca.or.kr/kor/accredited/accredited06_01.jsp" rel="external nofollow noopener noreferrer" target="_blank">전자서명인증관리센터</a>에 보면 PKCS#5와 PKCS#8 형식이라고 나와있다.</p><blockquote><p>In cryptography, PKCS #8 is a standard syntax for storing private key information.<br>  The PKCS #8 private key may be encrypted with a passphrase using the PKCS #5 standards,<br>  which supports multiple ciphers.</p></blockquote><p>PKCS#8(Private-Key Information Syntax Standard)이 뭔지 찾아보니 <a href="https://en.wikipedia.org/wiki/PKCS_8" rel="external nofollow noopener noreferrer" target="_blank">위키피디아</a>에서는 개인키 저장을 위한 문법 표준이라고 하고 있다.<br>웬만한 개인키는 다 이 형식을 따르는 것 같다.<br>여기서 말하는 passphrase는 사용자가 공인인증서를 만들 때 입력한 비밀번호를 의미한다.</p><p>이번엔 PKCS#5(Password-Based Cryptography Standard)가 뭔지 찾아보니 패스워드를 깨먹기 어렵게 하기 위한 표준 같아 보였다.<br>그 안에는 Key Derivation Functions라는 게 있는데 패스워드 + salt + 이터레이션 카운트(해당 함수를 몇 번 이터레이션 돌릴지) 등등을 인자로 받아서 추가 연산을 진행하는 함수인데,<br>패스워드를 빠르게 계산하기 어렵게 해서 해커가 공격을 빠르게 하지 못하게 막기 위해 사용하는 함수 같다.<br>이런 Key Derivation Function을 커스텀하게 구현해도 되지만 좀 더 검증되고 표준에 등재된<br>PBKDF1과 PBKDF2가 있는데 공인인증서는 두 가지 방식을 모두 지원한다.</p><p>그리고 공인인증서의 개인키는 SEED 알고리즘으로 암호화해서 저장돼있다고 하니 개인키를 얻어오려면 복호화를 해야한다.</p><h2 id="ASN-1-Abstract-Syntax-Notation-One"><a href="#ASN-1-Abstract-Syntax-Notation-One" class="headerlink" title="ASN.1(Abstract Syntax Notation One)"></a>ASN.1(Abstract Syntax Notation One)</h2><p>X.509 인증서의 데이터 구조는 ASN.1 표기법에 의해 표기된다.<br>따라서 디코딩해보면 더 많은 정보를 얻어낼 수 있는데 온라인에서 디코딩을 할 수 있다.  </p><p><img src="/images/korean-certification/asn1-certificate.png" alt="공인인증서를 ASN.1 표기법으로 표기"><br><a href="https://lapo.it/asn1js" rel="external nofollow noopener noreferrer" target="_blank">https://lapo.it/asn1js</a>에 들어가서 공인인증서나 개인키 파일을 Base64로 인코딩한 텍스트를 입력한 후에 decode 버튼을 누르면 더 자세한 정보를 볼 수 있다.  </p><p><img src="/images/korean-certification/asn1-key.png" alt="개인키를 ASN.1 표기법으로 표기"><br>개인키 파일을 디코딩해보면 어떤 암호화 알고리즘을 사용했는지, 어떤 KDF(Key Derivation Function)를 사용했는지 나온다.<br>object identifer를 <a href="http://oid-info.com/get/1.2.410.200004.1.4" rel="external nofollow noopener noreferrer" target="_blank">http://oid-info.com/get/1.2.410.200004.1.4</a>에서 검색하면 더 자세한 정보가 나온다.</p><p><img src="/images/korean-certification/seed-iv.png" alt="개인키를 ASN.1 표기법으로 표기"><br>또한 <a href="http://www.rootca.or.kr/kcac/down/TechSpec/2.3-KCAC.TS.ENC.pdf" rel="external nofollow noopener noreferrer" target="_blank">SEED 알고리즘 규격 문서</a>를 보면 OID에 따라서 초기 벡터 값을 어떻게 세팅해야하는지 나온다.</p><h2 id="ActiveX로-깔은-모듈-delfino-Xecure-등등-에서는-무슨-일을-할까…"><a href="#ActiveX로-깔은-모듈-delfino-Xecure-등등-에서는-무슨-일을-할까…" class="headerlink" title="ActiveX로 깔은 모듈(delfino, Xecure 등등)에서는 무슨 일을 할까…?"></a>ActiveX로 깔은 모듈(delfino, Xecure 등등)에서는 무슨 일을 할까…?</h2><p><img src="/images/korean-certification/activex-commuicate-local.png" alt="Ajax나 WebSocket을 통해서 주기적으로 로컬과 통신한다."><br>그 안에서 공인인증서도 가져오고, 개인키 파일을 복호화 해서 개인키를 획득하기도 하고…<br>여러가지 행위들을 한다.</p><p><img src="/images/korean-certification/kb-login.png" alt="PKCS7이란 파라미터에 Base64 인코딩 된 스트링을 보내고 있다."><br>PKCS #7(Cryptographic Message Syntax)이 뭔지 찾아보니 전자서명에 대한 표준 같아 보였다.<br>실제로 어떤 카드사의 경우에는 PKCS7 방식으로 전자서명 하는 모듈을 쓰는 곳도 있다.</p><p>근데 PKCS7에 보낸 데이터를 보니 Base64 인코딩 된 스트링이고 이 데이터는 전자서명한 데이터는 아니고,<br>ASN.1 Decoder로 보니 내 공인인증서였다.<br>내 공인인증서를 보냄으로써 내가 맞는지 검증하는 것 같다.<br>하지만 공개키 인증서는 기본적으로 여기저기 공유가 돼도 문제 없도록 만들었다.<br>따라서 저 공인인증서를 내가 전달한 건지, 남이 전달한 건지 서버는 알 길이 없다.</p><p><img src="/images/korean-certification/kb-login-vid-random.png" alt="VID_RANDOM 파라미터에 Base64 인코딩 된 스트링을 보내고 있다."><br><a href="http://www.rootca.or.kr/kcac/down/TechSpec/1.5-KCAC.TS.SIVID.pdf" rel="external nofollow noopener noreferrer" target="_blank">식별번호를 이용한 본인확인 기술규격</a>을 보면 다음과 같은 부분이 나와있다.<br><code>VID = h(h(IDN, R)</code></p><ul><li>VID: 가상식별번호</li><li>h( ) : 해쉬 함수</li><li>IDN : 식별번호</li><li>식별번호 : 전자서명법 시행규칙 제13조의2에 의한 주민등록번호, 사업자등록번호 및 고유번호</li><li>R: 비트열 난수<br><code>본 규격에서는 적어도 160비트 이상의 안전한 임의의 난수를 생성하여 사용해야한다. 난수는 가상 식별번호를 생성하는데 사용되며 가상 식별번호와 함께 공인인증기관에 전달되어 공인인증기관이 식별번호를 검증하는데 사용된다.</code><br>국민은행 측에 보낸 VID_RANDOM 값을 Base64 디코딩해보면 20바이트(160비트)의 데이터가 나온다.<br><img src="/images/korean-certification/vid-random.png" alt="R 값은 개인을 식별하기 위한 아주 중요한 정보이다."></li></ul><p>따라서 보안 모듈에서는 다음과 같은 행동이 일어났다.</p><ol><li>공인인증서 목록을 불러온다.</li><li>비밀번호를 입력받아서 개인키를 복호화한다.</li><li>복호화한 개인키에서 R값을 가져온다.</li><li>js에서 보안모듈(127.0.0.1)과 통신을 해서 R값과 공인인증서 값을 받아와서 국민은행 사이트에게 ajax로 요청을 보낸다.</li><li>해당 유저의 공인인증서와 R값이 맞다면 로그인을 성공시킨다.</li></ol><p>모듈마다 어떻게 인증 절차를 거치는지 다 다르다.<br>어떤 모듈은 PKCS7 방식으로 전자서명한 데이터를 보내는 모듈도 있고, 어떤 모듈은 추출한 R 값을 한 번 더 암호화 해서 보내는 곳도 있고,<br>어떤 곳은 Base64 인코딩이 아닌 Hex 인코딩을 사용하는 곳도 있다.<br>하지만 같은 모듈을 사용하는 은행/카드사가 있다면 비슷한 방식을 통해 로그인 과정이 이뤄진다.<br>(하나를 뚫으면 여러 벤더사를 함께 뚫을 수 있게 된다.)</p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://www.letmecompile.com/certificate-file-format-extensions-comparison/https://www.letmecompile.com/certificate-file-format-extensions-comparison/" rel="external nofollow noopener noreferrer" target="_blank">https://www.letmecompile.com/certificate-file-format-extensions-comparison/</a></li><li><a href="https://indienote.tistory.com/272" rel="external nofollow noopener noreferrer" target="_blank">https://indienote.tistory.com/272</a></li><li><a href="https://indienote.tistory.com/273" rel="external nofollow noopener noreferrer" target="_blank">https://indienote.tistory.com/273</a></li><li><a href="https://www.slideshare.net/ied206/4th-inc0gnito" rel="external nofollow noopener noreferrer" target="_blank">https://www.slideshare.net/ied206/4th-inc0gnito</a></li><li><a href="https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0" rel="external nofollow noopener noreferrer" target="_blank">https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0</a></li><li><a href="https://news.joins.com/article/521864" rel="external nofollow noopener noreferrer" target="_blank">https://news.joins.com/article/521864</a></li><li><a href="https://www.rootca.or.kr/kcac/down/TechSpec/2.3-KCAC.TS.ENC.pdf" rel="external nofollow noopener noreferrer" target="_blank">SEED 암호 알고리즘 규격</a> </li><li><a href="https://www.rootca.or.kr/kcac/down/TechSpec/1.1-KCAC.TS.CERTPROF.pdf" rel="external nofollow noopener noreferrer" target="_blank">전자서명 인증서 프로파일 규격</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/korean-certification/thumb.png&quot; alt=&quot;npki라는 디렉리토리 안에 보관돼있는 공인인증서의 공개키(*.der)와 비밀키(*.key)&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;인증서는-왜-쓸까&quot;&gt;&lt;a href=&quot;#인증서는-왜-쓸까&quot; class=&quot;headerlink&quot; title=&quot;인증서는 왜 쓸까&quot;&gt;&lt;/a&gt;인증서는 왜 쓸까&lt;/h2&gt;&lt;p&gt;A가 데이터를 보냈는데 이게 진짜 A가 보낸 건지 아닌지를 검증할 수가 없다.&lt;br&gt;인증서는 A라는 사람이라는 것을 &lt;strong&gt;보증해주는 문서&lt;/strong&gt;라고 보면 된다.&lt;br&gt;따라서 A한테 메세지가 올 때 A의 인증서가 오지 않는다면 A라고 취급을 하지 않으면 된다.&lt;br&gt;하지만 개나소나 인증서를 발급할 수 있으면 A 행세를 아무나 낼테니까 &lt;strong&gt;인증된 기관(CA, Certificate Authority)&lt;/strong&gt;으로부터 적절한 절차를 거쳐 인증서를 발급받을 수 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
      <category term="보안" scheme="https://perfectacle.github.io/tags/%EB%B3%B4%EC%95%88/"/>
    
      <category term="공인인증서" scheme="https://perfectacle.github.io/tags/%EA%B3%B5%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%84%9C/"/>
    
  </entry>
  
  <entry>
    <title>AES 256 CBC + PBKDF2</title>
    <link href="https://perfectacle.github.io/2019/11/24/aes/"/>
    <id>https://perfectacle.github.io/2019/11/24/aes/</id>
    <published>2019-11-24T00:59:51.000Z</published>
    <updated>2019-11-24T00:59:51.342Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/aes/thumb.png" alt="">  </p><p>막연하게 양방향 암호화 하면 당연스레 AES를 떠올리고, 제대로 모른 채로 사용했다.<br>이제부터라도 조금은 알고 써야겠다는 생각이 들어서 살짝 정리해봤다.</p><h2 id="양방향-단방향-암호화"><a href="#양방향-단방향-암호화" class="headerlink" title="양방향/단방향 암호화"></a>양방향/단방향 암호화</h2><p>양방향 암호화는 암호화 및 복호화가 가능하다는 소리다.<br>휴대폰 번호 등등 민감한 개인정보는 암호화 해서 저장해야하는데 고객 정보를 식별하기 위해선 복호화도 가능해야한다.<br>혹시나 키와 DB가 털린다면 복호화가 가능하므로 적어도 개인정보는 마스킹 한 후에 암호화해서 저장해야한다.<br>양방향 암호화 알고리즘에는 DES(보안에 취약), <strong>AES</strong>, SEED(국내에서 개발, 공인인증서에 사용됨) 등등이 있다.</p><a id="more"></a><p>단방향 암호화는 암호화만 가능하고 복호화는 불가능하다는 소리다.<br>비밀번호와 같이 암호화 한 값들끼리 단순히 비교만 하면 되고, 복호화 할 필요가 없는 정보들은 단방향 암호화 해야한다.<br>혹시나 키와 DB가 털려도 복호화가 불가능하기 때문에 암호화된 값만 알 수 있지 원본 비밀번호는 알 수 없기 때문에 양방향 암호화 보다는 좀 더 안전하다.<br>이런 특성 때문에 비밀번호 찾기 대신에 비밀번호 재설정 기능 밖에 지원 할 수 없다. (비밀번호 찾기를 지원해주는 사이트는 보안이 매우 안 좋은 사이트이다.)<br>단방향 암호화 알고리즘에는 해시 알고리즘이 사용되며 SHA256, SHA512, MD5(무작위 대입 공격에 약함) 등등이 있다.</p><h2 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES (Advanced Encryption Standard)"></a>AES (Advanced Encryption Standard)</h2><p>DES 암호화 방식에 결함이 발견되어 그 이후에 미국에서 열린 암호화 공모전에서 채택된 알고리즘이다.<br>대칭키 방식이라 암호화 및 복호화에 사용되는 키 값이 동일하다.<br>서버에서 사용되는 AES의 키는 대부분 파일로 저장돼있다기 보다는 키 값에 사용될 값을 어디 비밀스러운 공간에 저장해뒀다가 불러오는 예제가 대다수이다.<br>소스코드나 config 파일에 문자열을 하드코딩 해뒀다가 사용하는 곳도 있지만 깃헙 등등이 털리면 답이 없기 때문에 정말 비밀스런 공간에 저장했다가 불러와야한다.<br>(정말 비밀스러운 공간에 잘 저장해뒀다가 불러오는 방법은 자세히는 모르겠다.)</p><h3 id="AES128-vs-AES192-vs-AES256"><a href="#AES128-vs-AES192-vs-AES256" class="headerlink" title="AES128 vs AES192 vs AES256"></a>AES128 vs AES192 vs AES256</h3><p>키 값의 길이에 따라 AES128(128 bit == 16 byte), AES192(192 bit == 24 byte), <strong>AES256(256 bit == 32 byte)</strong>으로 나뉜다.<br>키 값이 길면 길수록 무작위 대입 공격에 유리하다는 장점이 있다.<br>예를 들면 AES128은 2¹²⁸번 시도해서 공격에 성공한다면 AES256은 2²⁵⁶번 시도해야 성공할 수 있다.</p><p>하지만 이것 외에 또 다른 차이점이 있는데, 암호화에는 Round라는 게 존재한다.<br>예를 들면 1Round에는 bit-rotation을 진행하고, 2Round에는 1Round에서 나온 걸 XOR 연산하고, 뭐 이런 식으로 각 Round 별로 암호화에 필요한 연산을 진행하게 된다.<br>AES128은 10Round, AES192는 12Round, AES256은 14Round에 걸쳐 암호화를 진행한다.  </p><p>따라서 AES256은 키 값이 길어서 무작위 대입에도 유리하고, 암호화에 진행되는 Round도 많다보니 다른 방식에 비해 더 우수한 알고리즘이다.<br>물론 컴퓨팅 파워를 더 쓰긴 하겠지만, 요즘 서버 스펙에는 큰 무리는 되지 않는다.<br>오히려 불필요하게 빠르면 무작위 대입 공격에 더 불리해질 뿐이다. (유저 입장에서는 ms 단위의 차이는 체감도 하지 못할 수준일 것이다.)</p><h3 id="Block-Cipher"><a href="#Block-Cipher" class="headerlink" title="Block Cipher"></a>Block Cipher</h3><p>AES는 128 bit(16 byte)라는 고정된 블럭 단위로 암호화를 수행한다.<br>이는 키 값의 길이와는 전혀 무관하다.<br>하지만 AES는 128 bit까지만 암호화 할 수 있으므로 128 bit가 넘어가는 데이터를 암호화하기 위해 <strong>Block Cipher Mode</strong>(EBC, <strong>CBC</strong> 등등)를 선택해야한다.<br>즉 256 bit의 평문을 암호화 할 때 두 개의 128 bit로 쪼개서 각각 암호화를 수행하게 된다.  </p><p>또한 128 bit의 블럭으로 쪼개기 때문에 128 bit 보다 작은 블럭이 나올 수 있는데 이런 블럭은 뒤에 값을 붙여주는데 이 값을 <strong>padding</strong>이라고 부른다.<br>이따 나올 예제에서 사용하는 패딩의 종류를 보면 PKCS#5 padding을 사용하고 있다.<br>하지만 PKCS#5 padding은 8 byte 블럭에 대한 패딩인데 왜 PKCS#5 padding을 사용하는지 의문을 가지게 된다.<br><a href="https://stackoverflow.com/questions/20770072/aes-cbc-pkcs5padding-vs-aes-cbc-pkcs7padding-with-256-key-size-performance-java#comment31139784_20770158" rel="external nofollow noopener noreferrer" target="_blank">스택오버플로우의 한 댓글</a>을 살펴보면<br>레거시의 잔재인 것 같고, 내부적으로는 PKCS#7 padding으로 변환되는 것 같다.<br>PKCS#7 padding은 1~255 byte의 block에 대한 패딩을 만들어내는 방식이다.<br>소스 코드에서 PKCS#5 padding을 사용하는 것처럼 보이는 게 싫다면 <a href="https://www.bouncycastle.org/" rel="external nofollow noopener noreferrer" target="_blank">Bouncy Castle</a>을 사용해야한다.<br>Bouncy Castle 없이 PKCS#7 padding을 사용하려고 하면 java.security.NoSuchAlgorithmException 예외를 만나게 될 것이다.</p><h4 id="EBC-Electronic-Codebook"><a href="#EBC-Electronic-Codebook" class="headerlink" title="EBC (Electronic Codebook)"></a>EBC (Electronic Codebook)</h4><p>짧게 말하면 <strong>실무에서는 절대 사용하면 안 되는</strong> Mode이다.</p><p><img src="/images/aes/ecb-enc.png" alt=""><br><img src="/images/aes/ecb-dec.png" alt=""><br>이미지 출처: <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB)" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB)</a></p><p>EBC는 각 블럭을 독립적으로 암/복호화한다.<br>독립적으로 암호화하기 때문에 병렬로 암/복호화 할 수 있기 때문에 속도 측면에서 장점을 가진다.<br>또한 키값만 설정하면 되기 때문에 사용하기 쉽다는 장점도 가지고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">"a"</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256ECB &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        SecretKeySpec(KEY.toByteArray(), <span class="string">"AES"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while generating key: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 각각 알고리즘/Block Cipher Mode/Padding 메카니즘이다.</span></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/ECB/PKCS5PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec)</span><br><span class="line">        cipher.doFinal(plainText.toByteArray())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while encrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 각각 알고리즘/Block Cipher Mode/Padding 메카니즘이다.</span></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/ECB/PKC55PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec)</span><br><span class="line">        String(cipher.doFinal(cipherText))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while decrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> PLAIN_TEXT = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256ECBTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testEncrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 0 ~ 127 bit까지는 한 블럭 안에 담긴다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(<span class="string">""</span>)</span><br><span class="line">        assertThat(encrypted?.size).isEqualTo(BLOCK_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDecrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> decrypted = AES256ECB.decrypt(encrypted)</span><br><span class="line"></span><br><span class="line">        assertThat(PLAIN_TEXT).isEqualTo(decrypted)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 각 블럭이 독립적으로 암호화 되기 때문에 더 빨리 공격당하기 쉽고(병렬로 암/복호화 시도), 아래와 같은 결함을 가진다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> PLAIN_TEXT = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> DUPLICATED_COUNT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256ECBTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `반복된 문자열을 암호화 하면 반복된 암호문 블럭이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 좀 더 깔끔한 예제를 만들기 위해 패딩 값이 없게 끔 각 블럭을 꽉꽉 채워 암호화 시도한다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(PLAIN_TEXT.repeat(BLOCK_SIZE * DUPLICATED_COUNT))</span><br><span class="line">        <span class="keyword">val</span> encryptedBlocks = mutableListOf(</span><br><span class="line">                encrypted?.copyOfRange(BLOCK_SIZE, BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until DUPLICATED_COUNT) &#123;</span><br><span class="line">            <span class="keyword">val</span> firstBlock = encryptedBlocks.first()</span><br><span class="line">            <span class="keyword">val</span> currentBlock = encrypted?.copyOfRange(i * BLOCK_SIZE, i * BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (firstBlock.contentEquals(currentBlock)) <span class="keyword">continue</span></span><br><span class="line">            encryptedBlocks.add(currentBlock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 암호문에 들어간 반복된 문자열들을 추론 가능해짐.</span></span><br><span class="line">        assertThat(encryptedBlocks.size).isEqualTo(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `똑같은 평문을 암호화 하면 똑같은 암호문이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> encrypted2 = AES256ECB.encrypt(PLAIN_TEXT)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 딕셔너리를 만들어두면 어느 정도 암호문의 평문 데이터 추론이 가능해진다.</span></span><br><span class="line">        assertThat(encrypted).isEqualTo(encrypted2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 보안적 결함 때문에 1 ~ 127 bit의 데이터를 암호화 할 때만 사용해야한다고 하던데,<br>그런 거 따질 시간에 그냥 안전한 CBC 모드를 무조건 쓰는 걸 권장한다.  </p><h4 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC (Cipher Block Chaining)"></a>CBC (Cipher Block Chaining)</h4><p>예제를 찾다보면 가장 많이 보이는 Mode인 것 같다.</p><p><img src="/images/aes/cbc-enc.png" alt=""><br><img src="/images/aes/cbc-dec.png" alt=""><br>이미지 출처: <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)</a></p><p><a href="https://en.wikipedia.org/wiki/Initialization_vector" rel="external nofollow noopener noreferrer" target="_blank">IV(Initialization vector)</a>라는 처음보는 값이 사용된다.<br>vector는 힘과 방향을 가진다 라고 학교에서 배웠었는데 여기서 어떤 의미로 vector가 쓰인 건지는 잘 모르겠다…</p><p>첫 블럭의 암호문 결과가 다음 블럭에도 쓰이기 때문에 암호화 할 때 병렬로 처리하지 못한다.<br>하지만 복호화 할 때는 복호화 한 블럭이 그 다음 블럭에 사용되는 게 아니기 때문에 병렬로 처리할 수 있다.<br>이런 부분에 있어서 무작위 대입 공격에 EBC 보다는 더 유리하지 않을까 싶다.</p><p>간단하게 예제를 만들어보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">"a"</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="comment">// 16 바이트가 아닌 경우에는 java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 16 bytes long 오류가 나온다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> IV = <span class="string">"a"</span>.repeat(BLOCK_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256CBC &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(IV.toByteArray())</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        SecretKeySpec(KEY.toByteArray(), <span class="string">"AES"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while generating key: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        cipher.doFinal(plainText.toByteArray())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while encrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        String(cipher.doFinal(cipherText))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while decrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> PLAIN_TEXT = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> DUPLICATED_COUNT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256CBCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testEncrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 0 ~ 127 bit까지는 한 블럭 안에 담긴다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(<span class="string">""</span>)</span><br><span class="line">        assertThat(encrypted?.size).isEqualTo(BLOCK_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDecrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> decrypted = AES256CBC.decrypt(encrypted)</span><br><span class="line"></span><br><span class="line">        assertThat(PLAIN_TEXT).isEqualTo(decrypted)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `반복된 문자열을 암호화 해도 각 블럭은 다른 암호문 형태로 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 좀 더 깔끔한 예제를 만들기 위해 패딩 값이 없게 끔 각 블럭을 꽉꽉 채워 암호화 시도한다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT.repeat(BLOCK_SIZE * DUPLICATED_COUNT))</span><br><span class="line">        <span class="keyword">val</span> encryptedBlocks = mutableListOf(</span><br><span class="line">                encrypted?.copyOfRange(<span class="number">0</span>, BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until DUPLICATED_COUNT) &#123;</span><br><span class="line">            <span class="keyword">val</span> firstBlock = encryptedBlocks.first()</span><br><span class="line">            <span class="keyword">val</span> currentBlock = encrypted?.copyOfRange(i * BLOCK_SIZE, i * BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (firstBlock.contentEquals(currentBlock)) <span class="keyword">continue</span></span><br><span class="line">            encryptedBlocks.add(currentBlock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 암호문에 들어간 반복된 문자열들이 추론 불가능하다.</span></span><br><span class="line">        assertThat(encryptedBlocks.size).isEqualTo(DUPLICATED_COUNT)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 아래 결함은 여전히 가지고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> DUPLICATED_COUNT = <span class="number">5</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> PLAIN_TEXT = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256CBCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `똑같은 평문을 암호화 하면 똑같은 암호문이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> encrypted2 = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 딕셔너리를 만들어두면 어느 정도 암호문의 평문 데이터 추론이 가능해진다.</span></span><br><span class="line">        assertThat(encrypted).isEqualTo(encrypted2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>똑같은 평문을 암호화 하면 똑같은 암호문이 나온다</code>는 문제는 IV값이 매번 고정이기 때문에 발생하는 문제이다.<br>IV 값을 암호화 할 때마다 랜덤하게 생성해주면 된다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">"a"</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256CBC &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        SecretKeySpec(KEY.toByteArray(), <span class="string">"AES"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while generating key: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Generate Random IV</span></span><br><span class="line">        <span class="keyword">val</span> iv = ByteArray(BLOCK_SIZE)</span><br><span class="line">        SecureRandom.getInstanceStrong().nextBytes(iv)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipher.doFinal(plainText.toByteArray())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Combine Random IV and Encrypted Data</span></span><br><span class="line">        iv + encrypted</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while encrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Extract IV and Encrypted Data.</span></span><br><span class="line">        <span class="keyword">val</span> iv = cipherText?.copyOfRange(<span class="number">0</span>, BLOCK_SIZE)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipherText?.copyOfRange(BLOCK_SIZE, cipherText.size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        String(cipher.doFinal(encrypted))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while decrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>암호화 할 때 매번 랜덤한 IV 값을 생성하고,<br>복호화 할 때는 랜덤한 IV 값을 알 수 없기 때문에 암호문 첫 16바이트는 랜덤하게 생성한 IV 값을 붙여서 리턴해야한다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `똑같은 평문을 암호화 하면 다른 암호문이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">    <span class="keyword">val</span> encrypted2 = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">    assertThat(encrypted).isNotEqualTo(encrypted2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> decrypted = AES256CBC.decrypt(encrypted)</span><br><span class="line">    assertThat(decrypted).isEqualTo(PLAIN_TEXT)</span><br><span class="line">    <span class="keyword">val</span> decrypted2 = AES256CBC.decrypt(encrypted2)</span><br><span class="line">    assertThat(decrypted2).isEqualTo(PLAIN_TEXT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>문자열의 길이에 따라서 암호문의 길이가 달라지기 때문에 평문의 길이가 유추 가능하다</code>라는 것도 문제라고 생각했는데<br><a href="https://stackoverflow.com/questions/7303103/java-aes-encryption-with-salt" rel="external nofollow noopener noreferrer" target="_blank">Java AES Encryption with salt</a>을 보면<br>비밀번호와 달리 조금은 덜 민감한 정보를 암호화하는 것이기 때문인지 크게 중요치 않다고 여기는 것 같다.<br>애초에 AES의 목적이 고정된 길이를 리턴하는 해시 함수가 아니기 때문에도 그런 것 같다.  </p><h4 id="PBKDF2-Password-Based-Key-Derivation-Function"><a href="#PBKDF2-Password-Based-Key-Derivation-Function" class="headerlink" title="PBKDF2 (Password-Based Key Derivation Function)"></a>PBKDF2 (Password-Based Key Derivation Function)</h4><p>마지막으로 그러면 안 되겠지만 만약에 키 값이 털렸다고 치자.<br>하지만 키 값을 그대로 사용한 게 아니라 키 값을 다시 암호화 해서 사용했다면 어느 정도 안심할 수 있다.<br>이 때 사용할 키 값은 복호화 할 때도 사용할 키 값이기 때문에 항상 고정된 값을 리턴하는 암호화 알고리즘이어야 한다.  </p><p>이를 해소하기 위한 방법이 <strong>Key Derivation Function</strong>이다.<br>Key Derivation Function은 키 값도 늘려버리고, 암호화 횟수도 여러 번 돌려서 암호화를 수행하는데 시간이 오래 걸린다.<br>(하지만 AES는 키값이 128, 192, 256bit로 고정적이라서 키 값을 늘려버리진 않는다.)<br>그렇다고 해서 암호화 하는데 몇 초씩이나 걸리는 건 아니지만 해커가 일 초에 수십억 번 공격할 수 있는 걸 수천 번 정도 수준으로 줄여준다.<br>수천 번이라고 하니까 그래도 엄청 많아 보이지만 수십억 번에 비하면 새발의 피다.<br>또한 해시돼서 나오는 값이라 복호화도 불가능하다.  </p><p>그럼 예제를 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">"a"</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PBKDF2에 적용할 값들이다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> SALT = <span class="string">"&#123;,*jbU787l@BcG:L]Oos/?s7EwMo:i/%No2z)sP@ut@=cydO9&amp;@Xa137-ZHkke"</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> ITERATION_COUNT = <span class="number">1024</span></span><br><span class="line"><span class="comment">// 키 값이 256 bit이기 때문에 해시 돌린 digest 길이도 256 bit여야 한다.</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> DIGEST_BIT_LENGTH = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256CBC &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> factory = SecretKeyFactory.getInstance(<span class="string">"PBKDF2WithHmacSHA256"</span>)</span><br><span class="line">        <span class="keyword">val</span> spec = PBEKeySpec(KEY.toCharArray(), SALT.toByteArray(), ITERATION_COUNT, DIGEST_BIT_LENGTH)</span><br><span class="line">        SecretKeySpec(factory.generateSecret(spec).encoded, <span class="string">"AES"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while generating key: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Generate Random IV</span></span><br><span class="line">        <span class="keyword">val</span> iv = ByteArray(BLOCK_SIZE)</span><br><span class="line">        <span class="keyword">val</span> secureRandom = SecureRandom.getInstanceStrong()</span><br><span class="line">        secureRandom.nextBytes(iv)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipher.doFinal(plainText.toByteArray())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Combine Random IV and Encrypted Data</span></span><br><span class="line">        iv + encrypted</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while encrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Extract IV and Encrypted Data.</span></span><br><span class="line">        <span class="keyword">val</span> iv = cipherText?.copyOfRange(<span class="number">0</span>, BLOCK_SIZE)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipherText?.copyOfRange(BLOCK_SIZE, cipherText.size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5PADDING"</span>)</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        String(cipher.doFinal(encrypted))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Error while decrypting: <span class="variable">$e</span>"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256CBCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testEncrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(<span class="string">""</span>)</span><br><span class="line">        assertThat(encrypted).isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDecrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> decrypted = AES256CBC.decrypt(encrypted)</span><br><span class="line"></span><br><span class="line">        assertThat(PLAIN_TEXT).isEqualTo(decrypted)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)" rel="external nofollow noopener noreferrer" target="_blank">Block cipher mode of operation</a>  </li><li><a href="https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9" rel="external nofollow noopener noreferrer" target="_blank">Security Best Practices: Symmetric Encryption with AES in Java and Android</a>  </li><li><a href="https://whatis.techtarget.com/definition/initialization-vector-IV" rel="external nofollow noopener noreferrer" target="_blank">initialization vector (IV)</a></li><li><a href="https://crypto.stackexchange.com/questions/20/what-are-the-practical-differences-between-256-bit-192-bit-and-128-bit-aes-enc" rel="external nofollow noopener noreferrer" target="_blank">What are the practical differences between 256-bit, 192-bit, and 128-bit AES encryption?</a>  </li><li><a href="https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding" rel="external nofollow noopener noreferrer" target="_blank">What is the difference between PKCS#5 padding and PKCS#7 padding</a>  </li><li><a href="https://howtodoinjava.com/security/java-aes-encryption-example/" rel="external nofollow noopener noreferrer" target="_blank">Java AES Encryption Decryption Example</a>  </li><li><a href="https://www.javacodegeeks.com/2018/03/aes-encryption-and-decryption-in-javacbc-mode.html" rel="external nofollow noopener noreferrer" target="_blank">AES Encryption and Decryption in Java(CBC Mode)</a>    </li><li><a href="https://gist.github.com/itarato/abef95871756970a9dad" rel="external nofollow noopener noreferrer" target="_blank">Java AES CBC encryption example</a>  </li><li><a href="https://stackoverflow.com/questions/7303103/java-aes-encryption-with-salt" rel="external nofollow noopener noreferrer" target="_blank">Java AES Encryption with salt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/aes/thumb.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;&lt;p&gt;막연하게 양방향 암호화 하면 당연스레 AES를 떠올리고, 제대로 모른 채로 사용했다.&lt;br&gt;이제부터라도 조금은 알고 써야겠다는 생각이 들어서 살짝 정리해봤다.&lt;/p&gt;&lt;h2 id=&quot;양방향-단방향-암호화&quot;&gt;&lt;a href=&quot;#양방향-단방향-암호화&quot; class=&quot;headerlink&quot; title=&quot;양방향/단방향 암호화&quot;&gt;&lt;/a&gt;양방향/단방향 암호화&lt;/h2&gt;&lt;p&gt;양방향 암호화는 암호화 및 복호화가 가능하다는 소리다.&lt;br&gt;휴대폰 번호 등등 민감한 개인정보는 암호화 해서 저장해야하는데 고객 정보를 식별하기 위해선 복호화도 가능해야한다.&lt;br&gt;혹시나 키와 DB가 털린다면 복호화가 가능하므로 적어도 개인정보는 마스킹 한 후에 암호화해서 저장해야한다.&lt;br&gt;양방향 암호화 알고리즘에는 DES(보안에 취약), &lt;strong&gt;AES&lt;/strong&gt;, SEED(국내에서 개발, 공인인증서에 사용됨) 등등이 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Dev" scheme="https://perfectacle.github.io/categories/Note/Dev/"/>
    
    
      <category term="암호화" scheme="https://perfectacle.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94/"/>
    
      <category term="AES" scheme="https://perfectacle.github.io/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>(Kotlin) Request에서 Nullable? Non-Null?</title>
    <link href="https://perfectacle.github.io/2019/09/18/kotlin-request-nullable-non-null/"/>
    <id>https://perfectacle.github.io/2019/09/18/kotlin-request-nullable-non-null/</id>
    <published>2019-09-17T16:23:39.000Z</published>
    <updated>2019-09-17T17:43:43.514Z</updated>
    
    <content type="html"><![CDATA[<p>코틀린의 장점을 하나 꼽자면 Non-null 타입을 지원한다는 것이다.<br>모든 곳에 null을 없앨 수 있는데(100% 순수 코틀린 코드로만 짠다면)<br>통제할 수 없는 부분은 클라이언트로부터 받는 Request이다.  </p><p>그래서 Request에는 어떤 타입을 써야할지 삽질을 해봤다.  </p><a id="more"></a><h2 id="기본값을-사용하자"><a href="#기본값을-사용하자" class="headerlink" title="기본값을 사용하자."></a>기본값을 사용하자.</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="keyword">val</span> name: String? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> dto: <span class="type">DTO</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같을 때 request body의 name에 아무런 내용도 입력하지 않으면 name에 기본값 <code>null</code>이 잘 세팅된다.<br>기본값이 전부 존재하면 default constructor가 생성돼서 객체를 손쉽게 생성할 수 있다보니 테스트 할 때 용이하다.  </p><h2 id="무조건-nullable-타입을-사용하자"><a href="#무조건-nullable-타입을-사용하자" class="headerlink" title="무조건 nullable 타입을 사용하자."></a>무조건 nullable 타입을 사용하자.</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="keyword">val</span> name: String = <span class="string">"123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> dto: <span class="type">DTO</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같을 때 클라이언트에서 의도적으로 <code>{&quot;name&quot;: null}</code>을 보내는 순간<br><code>failed for JSON property name due to missing (therefore NULL) value for creator parameter name which is a non-nullable type</code><br>라는 오류와 함께 400 에러를 뱉는다. (<strong>타입에 관련된 에러임</strong>)<br>따라서 nullable 타입을 사용하자.</p><h2 id="Header와-Parameter의-default-value는-어노테이션에-있는-설정을-쓴다"><a href="#Header와-Parameter의-default-value는-어노테이션에-있는-설정을-쓴다" class="headerlink" title="Header와 Parameter의 default value는 어노테이션에 있는 설정을 쓴다."></a>Header와 Parameter의 default value는 어노테이션에 있는 설정을 쓴다.</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestHeader(required = false, defaultValue = <span class="meta-string">"11"</span>)</span> test: <span class="type">Int</span>?)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 때 헤더에 아무런 값도 보내지 않으면 11이 세팅된다.<br>하지만 아래와 같이 변수에 기본값을 세팅했다면 null이 세팅된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestHeader(required = false)</span> test: <span class="type">Int</span>? = <span class="number">11</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;코틀린의 장점을 하나 꼽자면 Non-null 타입을 지원한다는 것이다.&lt;br&gt;모든 곳에 null을 없앨 수 있는데(100% 순수 코틀린 코드로만 짠다면)&lt;br&gt;통제할 수 없는 부분은 클라이언트로부터 받는 Request이다.  &lt;/p&gt;&lt;p&gt;그래서 Request에는 어떤 타입을 써야할지 삽질을 해봤다.  &lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Kotlin" scheme="https://perfectacle.github.io/categories/Note/Kotlin/"/>
    
    
      <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
      <category term="Kotlin" scheme="https://perfectacle.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>(Kotlin) De/Serialize DTO 뽀개서 뿌셔버리기</title>
    <link href="https://perfectacle.github.io/2019/09/16/kotlin-de-serialize-dto/"/>
    <id>https://perfectacle.github.io/2019/09/16/kotlin-de-serialize-dto/</id>
    <published>2019-09-15T15:30:06.000Z</published>
    <updated>2019-09-17T16:26:12.828Z</updated>
    
    <content type="html"><![CDATA[<p>연차 대비 너무너무 느린 개발 속도를 향상시키기 위해 나만의 Cheetsheet를 하나씩 만들어야겠다.<br>처음 접하는 코틀린 환경에서 자바에서는 좀 할만했던 DTO의 (De)Serialize 관련해서 적어보았다.<br>모든 설명은 <strong>JSON으로 request와 response를 주고받는 HTTP API 기반</strong>으로 진행하기 때문에 엄밀히 따지면 부정확한 내용들이 많다.</p><a id="more"></a><h2 id="용어-설명"><a href="#용어-설명" class="headerlink" title="용어 설명"></a>용어 설명</h2><p>간단하게 용어들을 집고 넘어가자.</p><h3 id="DTO-Data-Transfer-Object"><a href="#DTO-Data-Transfer-Object" class="headerlink" title="DTO(Data Transfer Object)"></a>DTO(Data Transfer Object)</h3><p>데이터를 전송하는데 사용하는 객체  </p><p>쉽게 말해서 HTTP API에서 사용하는 JSON 타입 등등의 <strong>Request Body</strong>와 <strong>Response Body</strong>를 떠올리면 된다.<br>자바스크립트에서는 JSON이 자바스크립트의 Object 리터럴과 매우 유사해서 파싱하는데 크게 무리가 없지만,<br>JVM 진영에서는 꽤나 큰 이슈이다. (잘 몰라서 삽질을 하는 계기가 된다.)  </p><h3 id="Deserialize"><a href="#Deserialize" class="headerlink" title="Deserialize"></a>Deserialize</h3><p>쉽게 말하면 JSON 형태의 Request Body를 코틀린 등등의 Object로 파싱하는 작업을 의미한다.<br><strong>Setter에 해당 로직이 들어간다.</strong></p><p>Request Body는 클라이언트가 서버로 던지는 내용이다.<br>따라서 서버의 권한 밖이기 때문에 Kotlin이 non-null type을 지원한들 아래와 같은 문제를 마주치게 된다.</p><ol><li>non-null tpye이고, default value가 없는데 client에서 필드를 넘겨주지 않으면 (<code>{}</code>)</li><li>non-null tpye이고, default value가 있는데 client에서 null을 넘기면 (<code>{&quot;field&quot;: null}</code>)</li></ol><p>위와 같은 경우에 아래 오류와 마주치게 된다. (컴파일 타임에 클라이언트가 어떻게 던질지 모르므로 <strong>런타임 에러</strong>로 발생한다.)<br><code>JSON property name due to missing (therefore NULL) value for creator parameter name which is a non-nullable type</code></p><p><strong>따라서 클라이언트가 우리 말을 잘 듣는다는 보장이 없으므로 Request Body DTO의 필드들은 nullable type으로 지정해주자!</strong></p><h3 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize"></a>Serialize</h3><p>쉽게 말하면 코틀린 등등의 Object를 JSON 형태의 Response Body로 파싱하는 작업을 의미한다.<br><strong>Getter에 해당 로직이 들어간다.</strong></p><h2 id="기본적인-형태"><a href="#기본적인-형태" class="headerlink" title="기본적인 형태"></a>기본적인 형태</h2><p>가장 기본적인 형태들의 DTO를 파싱해보자.  </p><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-똑같은-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-똑같은-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 똑같은 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 똑같은 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;name: "name"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;name: "name"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="keyword">val</span> name: String?)</span><br></pre></td></tr></table></figure><h4 id="코틀린의-필드명과는-다른-경우"><a href="#코틀린의-필드명과는-다른-경우" class="headerlink" title="코틀린의 필드명과는 다른 경우"></a>코틀린의 필드명과는 다른 경우</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;n: "name"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;n: "name"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="meta">@JsonProperty(<span class="meta-string">"n"</span>)</span> <span class="keyword">val</span> name: String?)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-다른-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-다른-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 다른 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 다른 경우</h3><p>dto field name: name<br>request body’s key: n<br>response body’s key: name</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;n: "name"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;name: "name"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(name: String?) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">        <span class="meta">@JsonProperty(access = JsonProperty.Access.READ_ONLY)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">"n"</span>, access = JsonProperty.Access.WRITE_ONLY)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dto field name: name<br>request body’s key: name<br>response body’s key: n</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;name: "name"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;n: "name"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(name: String?) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">"n"</span>, access = JsonProperty.Access.READ_ONLY)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dto field name: name<br>request body’s key: names<br>response body’s key: n</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;name: "name"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;n: "name"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(name: String?) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">"n"</span>, access = JsonProperty.Access.READ_ONLY)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">"names"</span>, access = JsonProperty.Access.WRITE_ONLY)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LocalDateTime-3형제-다루기"><a href="#LocalDateTime-3형제-다루기" class="headerlink" title="LocalDateTime 3형제 다루기"></a>LocalDateTime 3형제 다루기</h2><p>보기 좋은 포맷으로 serialize하려면 <code>jackson-modules-java8</code>을 디펜던시에 추가해줘야한다.   </p><p>LocalDate, LocalTime, LocalDateTime 3형제를 다뤄보자.<br>모든 클라이언트가 ISO 8601을 따라서 Request Body를 만들어서 주면 좋겠지만 그렇지 않은 경우가 많기 때문에 직접 파싱해야할 경우가 있다.  </p><h3 id="기본-파싱-규칙-ISO-8601"><a href="#기본-파싱-규칙-ISO-8601" class="headerlink" title="기본 파싱 규칙 (ISO 8601)"></a>기본 파싱 규칙 (ISO 8601)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;"date": "2019-08-08", "time": "19:21:33", "dateTime": "2019-08-08T19:21:33"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;"date": "2019-08-08", "time": "19:21:33", "dateTime": "2019-08-08T19:21:33"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="keyword">val</span> date: LocalDate?,</span><br><span class="line">    <span class="keyword">val</span> time: LocalTime?,</span><br><span class="line">    <span class="keyword">val</span> dateTime: LocalDateTime?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;"date": "2019/08/08", "time": "19시 21분 33초", "dateTime": "2019/08/08 19시 21분 33초"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;"date": "2019/08/08", "time": "19시 21분 33초", "dateTime": "2019/08/08 19시 21분 33초"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd"</span>)</span> <span class="keyword">val</span> date: LocalDate?,</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">"HH시 mm분 ss초"</span>)</span> <span class="keyword">val</span> time: LocalTime?,</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd HH시 mm분 ss초"</span>)</span> <span class="keyword">val</span> dateTime: LocalDateTime?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;"date": "2019/08/08", "time": "19시 21분 33초", "dateTime": "2019/08/08 19시 21분 33초"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;"date": "2019-08-08", "time": "19:21:33", "dateTime": "2019-08-08T19:21:33"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    date: LocalDate?,</span><br><span class="line">    time: LocalTime?,</span><br><span class="line">    dateTime: LocalDateTime?</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> date = date</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy-MM-dd"</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd"</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> time = time</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"HH:mm:ss"</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"HH시 mm분 ss초"</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> dateTime = dateTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy-MM-dd'T'HH:mm:ss"</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd HH시 mm분 ss초"</span>)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="세계-시간-다루기"><a href="#세계-시간-다루기" class="headerlink" title="세계 시간 다루기"></a>세계 시간 다루기</h2><p>보기 좋은 포맷으로 serialize하려면 <code>jackson-modules-java8</code>을 디펜던시에 추가해줘야한다.  </p><p>Local 시리즈는 타임존이 없다.<br>저 시간/날짜가 영국 기준인지, 한국 기준인지 모른다.<br><strong>생일</strong>과 같이 타임존에 관계를 받지 않는 시간/날짜에 사용해야한다.  </p><p><strong>스포츠 중계</strong>와 같이 전세계에서 동시에 진행되는 경우에는 타임존이 필수다.<br>그럼 타임존을 가지고 있는 OffsetDateTime, ZonedDateTime, Instant를 다뤄보자.  </p><p>OffsetDateTime은 Timezone만 가지고 있는 반면, ZonedDateTime은 Timezone + Zone의 특성(Summer Time 여부 등등)도 가지고 있다.<br>Instant는 Unix Timestamp를 다룰 때 용이하다.</p><p>application.yaml에 아래 설정을 넣지 않으면 Deserialize해서 다루는 DTO 객체와 Response Body에 Timezone이 UTC로 고정된다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  jackson:</span></span><br><span class="line"><span class="attr">    deserialization:</span></span><br><span class="line"><span class="attr">      adjust_dates_to_context_time_zone:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="기본-파싱-규칙-ISO-8601-1"><a href="#기본-파싱-규칙-ISO-8601-1" class="headerlink" title="기본 파싱 규칙 (ISO 8601)"></a>기본 파싱 규칙 (ISO 8601)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;"offsetDateTime": "2019-08-08T19:21:33+09:00", "zonedDateTime": "2019-08-08T19:21:33+09:00[Asia/Seoul]", "unixTime": 1568558972&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;"offsetDateTime": "2019-08-08T19:21:33+09:00", "zonedDateTime": "2019-08-08T19:21:33+09:00", "unixTime": "2019-09-15T14:49:32Z"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="keyword">val</span> offsetDateTime: OffsetDateTime?,</span><br><span class="line">    <span class="keyword">val</span> zonedDateTime: ZonedDateTime?,</span><br><span class="line">    <span class="keyword">val</span> unixTime: Instant?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우-1"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우-1" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;"offsetDateTime": "2019/08/08 19시 21분 33초 +09:00", "zonedDateTime": "2019/08/08 19시 21분 33초 +09:00 [Asia/Seoul]", "unixTime": 1568558972&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;"offsetDateTime": "2019/08/08 19시 21분 33초 +09:00", "zonedDateTime": "2019/08/08 19시 21분 33초 +09:00 [KST]", "unixTime": "2019-09-15T14:49:32Z"&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd HH시 mm분 ss초 XXX"</span>)</span> <span class="keyword">val</span> offsetDateTime: OffsetDateTime?,</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd HH시 mm분 ss초 XXX '['z']'"</span>)</span> <span class="keyword">val</span> zonedDateTime: ZonedDateTime?,</span><br><span class="line">    <span class="keyword">val</span> unixTime: Instant?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우-1"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우-1" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;"offsetDateTime": "2019/08/08 19시 21분 33초 +09:00", "zonedDateTime": "2019/08/08 19시 21분 33초 +09:00 [Asia/Seoul]", "unixTime": "2019/08/08 19시 21분 33초 +09:00"&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;"offsetDateTime": "2019-08-08T19:21:33+09:00", "zonedDateTime": "2019-08-08T19:21:33+09:00[KST]", "unixTime": 1565259693&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZonedDateTimeDTO3</span></span>(</span><br><span class="line">    offsetDateTime: OffsetDateTime?,</span><br><span class="line">    zonedDateTime: ZonedDateTime?,</span><br><span class="line">    unixTime: Instant?</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> offsetDateTime = offsetDateTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy-MM-dd'T'HH:mm:ssXXX"</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd HH시 mm분 ss초 XXX"</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> zonedDateTime = zonedDateTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy-MM-dd'T'HH:mm:ssXXX'['z']'"</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd HH시 mm분 ss초 XXX '['z']'"</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> unixTime = unixTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy/MM/dd HH시 mm분 ss초 XXX"</span>)</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUnixTime</span><span class="params">()</span></span> = unixTime?.epochSecond</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;연차 대비 너무너무 느린 개발 속도를 향상시키기 위해 나만의 Cheetsheet를 하나씩 만들어야겠다.&lt;br&gt;처음 접하는 코틀린 환경에서 자바에서는 좀 할만했던 DTO의 (De)Serialize 관련해서 적어보았다.&lt;br&gt;모든 설명은 &lt;strong&gt;JSON으로 request와 response를 주고받는 HTTP API 기반&lt;/strong&gt;으로 진행하기 때문에 엄밀히 따지면 부정확한 내용들이 많다.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Kotlin" scheme="https://perfectacle.github.io/categories/Note/Kotlin/"/>
    
    
      <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
      <category term="Kotlin" scheme="https://perfectacle.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>자산과 부채, 그리고 현금흐름과 자본이득</title>
    <link href="https://perfectacle.github.io/2019/08/24/assets-debts-cash-flow-and-captial-gains/"/>
    <id>https://perfectacle.github.io/2019/08/24/assets-debts-cash-flow-and-captial-gains/</id>
    <published>2019-08-24T06:03:12.000Z</published>
    <updated>2019-08-24T06:03:12.949Z</updated>
    
    <content type="html"><![CDATA[<p>돈으로부터 자유로워지려면 어떻게 해야할까?<br>월급을 얼마를 받던 상관없이 내가 원하는 삶을 살 수는 없을까?<br>지금은 내가 일을 해서 돈을 벌지만, 내가 일을 못하게 되면 어떤 삶을 살아야할까?<br>그렇다면 평생 일을 할 수 있다면, 죽을 때까지 계속해서 일을 해야하는 걸까?</p><p>사람마다 일과 삶(Working &amp; Life), 그리고 돈에 대한 가치가 다 다르겠지만 내 스스로 기준을 정하고 내가 원하는 삶으로 이끌어나가기 위해서 책을 읽은 내용을 토대로 좀 정리해봤다.  </p><a id="more"></a><h2 id="자산과-부채"><a href="#자산과-부채" class="headerlink" title="자산과 부채"></a>자산과 부채</h2><p>로버트 기요사키의 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=13347349" rel="external nofollow noopener noreferrer" target="_blank">부자 아빠, 가난한 아빠</a>에서는 다음과 같이 설명하고 있다.  </p><blockquote><p>자산은 내 지갑에 돈을 넣어주고, 부채는 내 지갑에서 돈을 꺼내간다.</p></blockquote><h3 id="자산"><a href="#자산" class="headerlink" title="자산"></a>자산</h3><p>로버트 기요사키의 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=6862489" rel="external nofollow noopener noreferrer" target="_blank">앞으로 10년, 돈의 배반이 시작된다</a>에서는 자산을 아래 4종류로 분류하고 있다.  </p><ol><li>기업<br>세계적인 기업들(MS, Google, Apple, Facebook, etc.) 뿐만 아니라 기본적으로 기업은 이익을 창출하는 집단이다</li><li>부동산<br>월/전세를 놓던, 싸게 사서 더 비싸게 팔던, 건물을 지어서 팔던, 부동산을 통해서도 수익을 낼 수 있다.</li><li>금융자산<br>주식, 펀드, 채권 등등을 통해 수익을 낼 수 있다.</li><li>상품(원자재)<br>금, 은 등등의 상품을 통해서도 수익을 낼 수 있다. (물론 금, 은의 가격이 떨어지기도 한다.)<br>금과 은의 가격이 등락하는 이유는 미국이 달러의 금본위제도를 폐지하면서 돈이 인쇄 가능한 종이 쪼가리(수준으로 전락)에 불과하기 때문이다.  </li></ol><h3 id="부채"><a href="#부채" class="headerlink" title="부채"></a>부채</h3><p><img src="/images/assets-debts-cash-flow-and-captial-gains/debt.png" alt="부채는 내 지갑에서 돈을 꺼내가는 모든 것이다."><br>일반적으로 생각하는 빚(은행이나 각종 방법으로 빌린 돈) 말고도 다양한 종류의 부채가 존재한다.</p><ul><li>자동차<br>많은 사람들이 자동차를 산다.<br>자동차는 많은 편리함을 주는 반면에 자산과 부채 관점에서 보면 부채에 불과하다.<br>자동차를 구매해서 운전하는 순간 자동차의 가치(금액)은 곤두박질 치고, 기름값과 각종 유지비용은 <strong>내 지갑에서 돈을 꺼내가는 부채</strong>이다.  </li><li>집<br>부동산은 자산이 될 수도, 부채가 될 수도 있다.<br>집은 오래되면 수리해야하고, 각종 세금도 있고, 주택담보대출 등등의 부채에 대한 이자 또한 <strong>내 지갑에서 돈을 꺼내가는 부채</strong>이다.<br>많은 사람들이 평생 내 집 마련을 위해 일하고, 이를 자산으로 여기는데 현금흐름을 창출해내지 못하는 이상 집은 부채에 불과하다.  </li><li>시간이 지나면 가격이 떨어지는 각종 사치품(시계, 옷, 가방 등등)<br>시간이 흘러가면 흘러갈 수록 가치가 올라간다면 부채는 아니겠지만, 그렇지 않은 경우에는 부채다.<br>이를 사기 위해 내 지갑에서 돈을 꺼냈는데 이 사치품들은 지나면 지날 수록 가치가 떨어지기 때문이다.<br>심지어 이런 사치품들을 사기 위해 할부나 빚을 냈다면 상황은 더더욱 심각하다.</li></ul><p>이 외에도 상당히 많은데 내가 어떻게 설명해야할 지 모르겠다.</p><h4 id="좋은-부채"><a href="#좋은-부채" class="headerlink" title="좋은 부채"></a>좋은 부채</h4><p>그렇다고 해서 부채가 무조건 나쁘다는 건 아니다.<br>부채를 통해 자산을 만들어낼 수 있다면 좋은 부채다.<br>만약에 은행에서 연 금리 5%로 대출을 받았는데 그 대출금으로 연 6%의 수익률을 낸다면 그 부채는 좋은 부채다.</p><p>부채 없이 성공한 부자는 없을 것이고, 현재 부자들도 대부분 부채가 있을 것이다.<br>만약 현재 부채가 없는 부자라면, 부채가 있었다면 더 큰 부자도 될 수 있었을 것이다.<br>왜냐면 좋은 부채는 자산을 만들어주는데, 자금이 크면 클 수록 큰 자산을 만들어 낼 수 있고, 자금 조달 수단 중 하나에 부채가 포함되기 때문이다.  </p><p>만약 대출받은 100원과 내 돈 100원으로 수익을 내고 있었다고 쳐보자. (수익을 내고 있다는 말은 대출 원리금 상환을 한 후에도 수익이 남는 구조를 뜻한다.)<br>내가 투자한 100원을 전부 회수한 이후부터는 내 자본금은 하나도 들이지 않고 수익을 내기 시작하는 것이다.<br>이렇게 내 자본금은 하나도 들어가지 않고, 수익을 내는 구조를 <strong>무한수익</strong>이라고 하며, 이렇게 무한 수익을 낼 수 있게 끔 해주는 부채가 가장 좋은 부채가 아닐까 싶다.</p><h4 id="나쁜-부채"><a href="#나쁜-부채" class="headerlink" title="나쁜 부채"></a>나쁜 부채</h4><p>자산을 만들어내지 못하는 부채는 전부 나쁜 부채이다. (학자금 대출이 전형적인 경우가 아닐까 싶다.)<br>똑같은 자동차라도 가정집에서 그냥 몰면 돈잡아 먹는 부채에 불과하고, 그 자동차로 택시 운전 등등을 통해 현금 흐름을 창출해낸다면 자산이 될 수 있다.<br>따라서 그 자동차를 구입하기 위해 받은 대출금 마저도 용도에 따라서 좋은 부채가 될지, 나쁜 부채가 될지가 결정된다.  </p><p>대부분의 가계 부채는 나쁜 부채일 것이다.<br>내 지갑에서 돈을 꺼내가는 반면에 돈을 채워넣어주지는 않을 것이기 때문이다.<br>그렇기 때문에 나는 지갑에 돈을 채워넣기 위해서 더욱 열심히 일해야할 것이다.  </p><p>계속해서… 평생…은 일하지 못하기 때문에 문제가 발생한다.<br>따라서 은퇴 후에는 각종 연금(국민연금, 퇴직연금, 연금저축보험 등등)에 의존하게 된다.  </p><p>하지만 국민 연금의 경우에는 합법적인 <strong>폰지 사기</strong>라는 생각이 든다. (물론 틀렸을 가능성도 크다.)<br>폰지 사기는 사기꾼 찰스 폰지의 이름에서 따왔는데 사기의 절차는 다음과 같다.</p><ol><li><strong>투자자 A</strong>에게 수익을 약속해서 <strong>폰지</strong>는 투자금을 받는다.  </li><li><strong>투자자 B</strong>에게 수익을 약속해서 <strong>폰지</strong>는 투자금을 받는다.  </li><li><strong>폰지</strong>는 <strong>투자자 A에</strong>게 수익금을 준다.  </li></ol><p>이 폰지 사기의 맹점은 더이상 투자자가 나타나지 않는 이상 수익금은 발생하지 않는다.<br>이 폰지 사기를 한 번 국민 연금에 빗대어서 생각해보자.</p><ol><li><strong>부모님</strong>에게 물가 상승률 대비 수익을 약속해서 <strong>정부</strong>는 국민연금을 걷는다.  </li><li><strong>나</strong>에게 물가 상승률 대비 수익을 약속해서 <strong>정부</strong>는 국민연금을 걷는다.  </li><li><strong>정부</strong>는 <strong>부모님</strong>에게 연금을 준다.</li></ol><p>저출산, 고령화 시대에 더이상 새롭게 연금을 내줄 사람이 줄어드는 이상 연금은 바닥나거나 젊은이들이 더 많이 부담해야할 것이다.<br>정부에서 과연 물가 상승률 대비해서 계속해서 수익을 내고 있을까?<br>그렇다면 다행인데 만약 그렇지 않다면 나는 합법적인 폰지 사기와 다를 바 없다고 생각하고 문제가 심각하다고 본다. </p><p>정상적으로 국민연금이 운영됐다는 전제 하에도 예상 수령액을 보면 불우한 내 노후가 눈 앞에 아른거렸다.<br>그러다보니 각종 은행 및 보험사 등에서 연금성 저축이나 보험을 권유한다.<br>하지만 <a href="https://www.youtube.com/channel/UC2soFUK5L61ovrRW5L5u-JA" rel="external nofollow noopener noreferrer" target="_blank">황소장의 부동산팩폭</a>의 <a href="https://www.youtube.com/watch?v=18vDx6p2Ef0" rel="external nofollow noopener noreferrer" target="_blank">한의사 교수님 그리고 보험</a> 영상을 보면서 꼼꼼히 검토해보고 가입해야한다.<br>영상 내용을 간단히 요약하자면 70년대에 연금 보험을 들었는데 그 때 기준으로 <strong>쌀 두 가마니를 살 수 있는 돈을 저축</strong>했는데, 은퇴 후에 연금을 받아보니 <strong>점심 한 끼 사먹을 수 있는 돈</strong>을 돌려받았다는 얘기이다.<br>모든 연금성 저축 상품들이 이렇지 않겠지만 정말 꼼꼼히 검토해보고 가입해야한다.<br>과거의 100원과 현재의 100원의 가치는 다르다.<br>또한 <strong>현재 1000원을 가지고 있어도 과거의 100원만도 못하게 되는 경우</strong>도 허다하다.<br><a href="/2019/08/15/why-central-banks-creates-money/">인플레이션(feat. 물가 상승률)에 대한 내용은 포스트</a>에 작성해 뒀으니 꼭 이해해야하는 내용 중 하나이다. </p><h2 id="현금흐름과-자본이득"><a href="#현금흐름과-자본이득" class="headerlink" title="현금흐름과 자본이득"></a>현금흐름과 자본이득</h2><p><img src="/images/assets-debts-cash-flow-and-captial-gains/cash-flow.png" alt="현금흐름은 자산으로부터 내 지갑으로 현금이 흘러들어오는 걸 뜻한다."><br>자신이 가진 부동산 자산에서 나오는 전/월세가 이 경우에 해당한다. (수익형)</p><p><img src="/images/assets-debts-cash-flow-and-captial-gains/capital-gains.png" alt="자본이득은 자산의 가치가 상승하는 걸 의미한다."><br>부동산 가격이 오르거나, 금/은 등의 가격이 오르거나, 주가가 오르는 등이 자본이득이다.<br>대부분 투기꾼들이 저가에 사서 <strong>거품</strong>을 잔뜩 끼게 한 다음에 고가에 팔아 치우곤 한다. (시세 차익형)<br>이게 과연 거품인지 아닌지를 보는 눈이 있어야 개미들이 피해보지 않을 것이다.  </p><p>자본이득 같은 경우에는 미래를 예측하는 눈이 있지 않는 이상은 도박에 불과할 것이다.<br>이를 위해서 리스크를 관리하고 회피하는 능력이 있지 않아야할까 싶다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;돈으로부터 자유로워지려면 어떻게 해야할까?&lt;br&gt;월급을 얼마를 받던 상관없이 내가 원하는 삶을 살 수는 없을까?&lt;br&gt;지금은 내가 일을 해서 돈을 벌지만, 내가 일을 못하게 되면 어떤 삶을 살아야할까?&lt;br&gt;그렇다면 평생 일을 할 수 있다면, 죽을 때까지 계속해서 일을 해야하는 걸까?&lt;/p&gt;&lt;p&gt;사람마다 일과 삶(Working &amp;amp; Life), 그리고 돈에 대한 가치가 다 다르겠지만 내 스스로 기준을 정하고 내가 원하는 삶으로 이끌어나가기 위해서 책을 읽은 내용을 토대로 좀 정리해봤다.  &lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"/>
    
    
      <category term="경제" scheme="https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"/>
    
      <category term="자본주의" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"/>
    
      <category term="재테크" scheme="https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"/>
    
      <category term="자산" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EC%82%B0/"/>
    
      <category term="부채" scheme="https://perfectacle.github.io/tags/%EB%B6%80%EC%B1%84/"/>
    
      <category term="현금흐름" scheme="https://perfectacle.github.io/tags/%ED%98%84%EA%B8%88%ED%9D%90%EB%A6%84/"/>
    
  </entry>
  
  <entry>
    <title>야놀자를 떠나며... (feat. 레저큐)</title>
    <link href="https://perfectacle.github.io/2019/08/23/exit-yanolja-feat-leisureq/"/>
    <id>https://perfectacle.github.io/2019/08/23/exit-yanolja-feat-leisureq/</id>
    <published>2019-08-22T23:16:36.000Z</published>
    <updated>2019-08-24T01:39:18.677Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/exit-yanolja-feat-leisureq/thumb.gif" alt=""><br>오늘은 야놀자 서류상 <strong>퇴사일</strong>이다. (오늘까지 남은 연차를 사용했다.)<br>총 세 번의 이직 시도 끝에 성공할 수 있었다.<br>여태까지 신입으로만 이직(프론트엔드 신입(5개월 재직) -&gt; 백엔드 중고 신입)했고, 지인 추천을 통해서만 면접을 봤는데<br>이번 이직에서는 지인 추천도 있었지만, 내 힘으로 스스로 지원해서 합격까지 한 케이스도 많아서 굉장히 뿌듯한 경험이었다.<br>나와 같은 2~3년 차 주니어 분에게 도움이 됐으면 하는 바람, 개인적으로 회고를 하고 싶어서 정리를 해봤다.  </p><a id="more"></a><h2 id="왜-퇴사를-결심했나"><a href="#왜-퇴사를-결심했나" class="headerlink" title="왜 퇴사를 결심했나"></a>왜 퇴사를 결심했나</h2><p>야놀자는 탄력 근무제(연장 근무를 했다면 다른 날 단축 근무 가능), 식비 지원, 분기별 야놀자 포인트 지급, 전용 사옥 등등의 좋은 복지들이 있다.<br>또한 <a href="https://yanolja.github.io/2019/07/tech_yanolja" rel="external nofollow noopener noreferrer" target="_blank">Tech야, 놀자</a>란 세미나를 할 정도로 탄탄한 개발문화와 <a href="https://www.mk.co.kr/news/business/view/2019/06/406700/" rel="external nofollow noopener noreferrer" target="_blank">유니콘 기업</a>이 되는 등 굉장히 유망한 회사다.<br>그럼에도 불구하고 내가 퇴사를 결심한 계기를 크게 두 가지다.</p><ol><li>가장 큰 요인은 <strong>개발에 집중하지 못하는 환경</strong>이었다.<br>레저큐에서 야놀자로 조직이 이동되면서(완전히 퇴사 후 입사 처리되었다. 레저큐는 야놀자의 계열사인데 일부만 야놀자로 조직 이동이 된 상태다.) 레저큐의 인프라 쪽을 한 번 쭉 털고 가야하는 이슈가 있었다.<br>평상시에 인프라에 관심이 많았던 내가 해당 업무를 맡게 되었고, 끝까지 털지 못하고 퇴사하게 되었다. (이후에는 시스템 엔지니어 쪽 팀에서 도와줄 예정인 걸로 알고 있다.)<br>개발이 하고 싶었지만, 점점 인프라 쪽 업무의 비중이 높아지면서 내 정체성을 의심하기 시작했다.<br>나는 서버 개발자인가? 아니면 시스템 엔지니어인가…?<br>물론 인프라 쪽도 알면 좋지만, 아직까지는 개발이 더 <strong>마렵다</strong>는 생각이 들었다.</li><li><strong>연봉</strong><br>대부분의 이직 사유 중 하나일 것이다.<br>물론 나보다 열악한 근무 환경 속에서도 안 좋은 대우를 받으시는 분들도 있을 거다.<br>하지만 사람의 욕심은 끝이 없어서 자꾸만 위를 올려다 보게 되었다.<br>네임밸류 기업에서 시작을 한 게 아니기 때문에 첫 시작 자체가 높지 않았던 탓도 있었던 것 같다. (그렇다고 그렇게 낮은 편도 아니었다.)</li></ol><p>그 외에도 있긴 하지만, 너무 개인적인 일이기도 하고 크게 공감을 얻을만한 내용이 아니어서 적지 않았다.</p><h2 id="세-번의-이직-시도"><a href="#세-번의-이직-시도" class="headerlink" title="세 번의 이직 시도"></a>세 번의 이직 시도</h2><p>작년에 두 번, 올해 한 번의 이직을 시도했다.<br>공교롭게도 이직 시도할 쯤이 연봉 협상 시기와 비슷한 경우가 많았다.<br>그만큼 연봉 인상에 대한 갈증도 어느정도 있었던 것 같다.</p><h3 id="첫-번째-시도-오피지지"><a href="#첫-번째-시도-오피지지" class="headerlink" title="첫 번째 시도, 오피지지"></a>첫 번째 시도, 오피지지</h3><p><a href="https://www.op.gg/" rel="external nofollow noopener noreferrer" target="_blank">오피지지</a>는 게임 랭킹/플레이 분석 등등을 해주는 서비스를 제공해주는 회사이다.<br>우리나라 보다 외국 유저가 많은만큼 글로벌 경험도 해볼 수 있고, 또 트래픽도 굉장히 많은 걸로 알고 있다.<br>면접을 보러 건물 앞을 서성이자 프로게이머 면접 왔냐고 물어봤다.<br>프로게이머 구단을 꾸리고 있을 정도로 게임에 대한 열정을 엿볼 수 있었다.  </p><p>우선 면접 중에 가장 신선했던 것은 자신있는 코드를 가져와서 직접 리뷰를 한다는 점이다.<br>물론 코드를 제출하는 게 아니라 개인 노트북을 들고 가서 직접 코드를 돌리진 않고 IDE를 띄워놓고 하나하나 리뷰했다.<br>외부 사람에게 코드리뷰를 한 적은 처음이었고, 내 코드에 어떤 개선사항들이 있는지, 앞으로 어떻게 해결해나가야할지 등등에 대해서 피드백을 알 수 있어서 좋았다.<br>그 이후에는 기술적인 질문들을 받았는데 이 때 제대로 대답을 하지 못했다.<br>단골 질문들도 나왔는데 평상시 그런 내용들은 물라도 <strong>일하는데 문제가 없었던 터</strong>라 공부를 미루고 있었다.<br>또한 <strong>면접 전에 반짝 공부해서 가기에는 회사에게 미안했다.</strong><br>내 원래 모습이 아닌 거짓된 모습을 보여주는 것 같기 때문에 회사에게도, 나에게도 좋지 않다고 판단을 했다.<br>그 이후에는 인사? 면접까지 바로 이루어졌다. (이건 뭐 다른 기업들이랑 크게 다르지 않았던 것 같아서 적을만한 게 없다.)<br>그리고 면접이 끝나고 나서도 해당 질문들을 정리하고 공부했어야 했는데 게으르게도 정리하지 않았다.  </p><p>결과는 <strong>불합격</strong>이었다.<br>내 추측에 의하면 내가 답변을 제대로 못했기 때문이라기 보다는 성향이 맞지 않았던 것 같았다.<br>당시에는 <del>빨대를 꼽을</del>나를 빠르게 성장시켜 줄 사수나 환경에 대해 갈망하고 있었다.<br>시간이 흘렀지만 나는 그대로인 것 같았다.<br>그러다보니 나를 바꿀 생각을 안 하고, 주변 환경을 바꿔서 쉽게 쉽게 가려고 했던 것 같다.<br>면접 때도 그런 태도를 계속 내비췄던 것 같은데 당시 오피지지는 그렇게 막 챙겨주고 가르쳐 줄 상황이 아니었기 때문이 아닐까 생각을 한다.</p><h3 id="두-번째-시도-쿠팡"><a href="#두-번째-시도-쿠팡" class="headerlink" title="두 번째 시도, 쿠팡"></a>두 번째 시도, 쿠팡</h3><p><a href="https://www.coupang.com/" rel="external nofollow noopener noreferrer" target="_blank">쿠팡</a>은 이커머스 사업을 하는 회사이다.<br>프론트엔드 스터디 강의를 해주신 두 분께서 쿠팡 출신이기 때문에 쿠팡에 대해 굉장히 기대가 크고 벽도 높다고 생각했다.<br>경력이 적었던 터라 내부 추천으로 들어가기에는 무리가 있어보였고 신입으로 지원하게 되었다.</p><p>운 좋게 서류를 통과하고 코딩 테스트를 볼 차례가 되었다.<br><a href="http://tech.kakao.com/2018/09/21/kakao-blind-recruitment-for2019-round-1/" rel="external nofollow noopener noreferrer" target="_blank">카카오 블라인드 채용 코딩 테스트</a> 문제를 봤을 때 이걸 다 푼 사람이 있나 싶을 정도였다.<br>그 중에 1/5도 못 맞출만큼 평상시에 알고리듬에 관한 공부를 하지 않았다.<br>그러다보니 거의 벼락치기 수준으로 코딩 테스트를 준비했다.  </p><p>결과는 <strong>불합격</strong>이었다.<br>개인적인 기준에는 너무 어려웠다.<br>초반 1~2 문제는 시간이 좀 걸렸고, 풀었던 문제들도 나이스하지 못하게 풀었다.<br>뒤로 가면 갈 수록 도저히 실무에서 겪어보지 못한 복잡성이었다.<br>지금 다시 풀라고 해도 못 붙는다.  </p><p>이렇게 나에게 코딩 테스트는 넘사벽 급의 존재가 되었다.<br>이 때부터라도 알고리듬 공부를 열심히 했어야했는데 또 게으름 탓에 알고리듬 공부도 딱히 하지 않으며 시간만 흘러갔다.</p><h3 id="세-번째-시도"><a href="#세-번째-시도" class="headerlink" title="세 번째 시도"></a>세 번째 시도</h3><p>세 번째 시도부터는 올해에 시도하기 시작했다.<br>그리고 처음으로 공격적으로 동시에 여러 곳을 면접봤다.<br>일주일에 면접을 5번 본 적도 있고, 심지어 오전에 한 개, 오후에 한 개 이렇게 본 날도 있었다.<br>떨어지기도 많이 떨어졌고, 붙기도 많이 붙었다.  </p><h4 id="탈락한-기업"><a href="#탈락한-기업" class="headerlink" title="탈락한 기업"></a>탈락한 기업</h4><ol><li>스노우<br><a href="https://snowcorp.com/" rel="external nofollow noopener noreferrer" target="_blank">스노우</a>는 스마트폰의 카메라 필터나 영상과 관련된 앱을 만드는 회사이다.<br><del>비개발자인 친구들도 많이 사용하는 앱이라 스노우 지원했다고 자랑도 했다.</del><br>하지만 서류부터 <strong>광탈</strong>했다.  </li><li>카카오뱅크<br><a href="https://www.kakaobank.com/" rel="external nofollow noopener noreferrer" target="_blank">카카오뱅크</a>는 국내 최초로 온라인 100% 은행이다. (오프라인 은행 지점이 없다.)<br>평상시에 크게 사용하진 않지만(역시 사람은 익숙한 것을 바꾸기가 정말 힘들다.) 그래도 간편함과 혁신적인 부분에 있어서는 정말 좋게 생각하고 있었다.<br>스노우의 전례가 있기 때문에 이번엔 친구들에게 설레발을 떨지 않았다.<br>서류를 열심히 작성해서 제출했지만 역시나 서류에서 <strong>탈락</strong>했다.<br>지원동기를 적어내는 칸에 <strong>거짓말을 치지 않는 이상 나를 어필하는 능력이 부족</strong>했다.<br>금융 쪽은 아예 경험이 없기 때문에 뭐라 적을 내용이 없었는데 그런 경험이 없기 때문에 떨어졌던 게 아닐까 싶다.</li><li>카카오<br><a href="https://www.kakaocorp.com/" rel="external nofollow noopener noreferrer" target="_blank">카카오</a>는 카카오톡이라는 메신저로 성장하여 다음 포털까지 인수한 회사이다.<br>월간 카카오를 통해 도전했고, 한 달에 한 번씩 볼 수 있기 때문에 크게 부담 가지지 않고 지원했다.<br>서류까지는 어찌저찌 통과했지만, 역시나 코딩 테스트에서 탈락했다.<br>&nbsp;<br>하지만 카카오는 나에게 용기를 불어넣어준 아주 고마운 회사이다.<br>회사마다, 팀마다 다르겠지만 내가 여태까지 봐왔던 코딩 테스트(카카오 블라인드 채용, 쿠팡 신입)와 비교해보면 난이도가 너무 낮았다. (그렇다고 발로 풀어도 될 정도까진 아니고…)<br>아마도 신입은 경력이 없다보니 증명할 게 코딩 테스트 말고는 없어서 좀 빡세게 냈던 게 아닐까 싶다.<br>따라서 경력은 프로젝트 이력 등등을 통해 증명할 수 있으니 다소 코딩 테스트의 비중을 좀 낮춘 게 아닐까 싶다.<br>실제로 내가 본 다른 기업의 코딩 테스트는 전부 카카오의 코딩 테스트와 비슷한 수준이었다.</li></ol><h4 id="네오펙트"><a href="#네오펙트" class="headerlink" title="네오펙트"></a>네오펙트</h4><p><a href="https://www.neofect.com/" rel="external nofollow noopener noreferrer" target="_blank">네오펙트</a>는 의료 재활 솔루션 회사이다.<br>생소한 도메인이기도 하고, 서버 개발자가 뭐 할일이 크게 있나… 싶을 정도였는데<br>의료 재활 기기와 앱을 연동해서 재활을 쉽고 재미있게 도와주는데 이 때 앱에서 사용할 API 서버를 개발하는 업무의 담당자를 뽑고 있었다.</p><p>서류까지는 무사통과 되고, 그 이후에 코딩 테스트를 봤는데 신기하게 <strong>SQL, 자바스크립트(DOM 지식이 필요한)</strong> 문제들이 나왔다.<br>솔직히 다른 코딩 테스트들은 어떤 문제는 ‘이 회사는 실무에서 이정도 복잡성을 다루면서 이런 문제를 내나?’ 싶은 수준의 문제도 많았는데 네오펙트는 참 실용적인 문제들만 나와서 좋았다.<br>(그만큼 내가 준비가 덜 됐기 때문에 그렇게 느꼈을지도 모르겠다.)  </p><p>코딩 테스트 통과 후에 주말에 두 명의 면접관과 함께 행아웃으로 라이브 코딩 면접도 보았다. (손코딩은 아니고 IDE를 사용해서 풀었다.)<br>라이브 코딩이기 때문에 구글링을 하면 안 되는 줄 알고 초반에 좀 뻘뻘대다가 해도 된다는 소리를 듣고 정말 실용적으로 면접보는 것 같아서 좋았다.<br>문제 자체는 Easy 레벨이었는데 초반에 너무 성급하게 문제를 푸는 바람에 이해를 잘못해서 시간을 정말 많이 날렸다.<br>어찌저찌 문제를 풀고 코드를 제출했다.<br>너무 덜렁대는 성격을 보여준 것 같아 불안했는데 어찌저찌 통과했다.</p><p>마지막으로 기술 면접과 인사 면접을 하루에 몰아서 보았다.<br>오피지지 이후로 첫 번째 기술 면접이기 때문에 오피지지에서 대답하지 못했던 부분들은 많이 공부해둔 상태였다. (실무를 통해 경험하다보니 자연스레 공부한 내용들도 있었고…)<br>하지만 자바 관련된 질문들, 스프링 관련된 질문들은 전혀 하지 않았다.<br>오로지 내가 진행한 프로젝트 이력에 대해서만 물어봤다. (그 이외의 질문도 좀 있긴 했지만)<br>이후에 면접관에게 왜 그런 내용은 물어보지 않았냐고 여쭙자 ‘자신들이 질문한 것만으로 어느 정도 검증이 되기도 하고, 그런 걸 물어봐도 뻔한 대답이 돌아오기 때문에 제대로 검증이 안되기 때문’이라고 말했던 것 같다. (정확히는 기억이…)</p><p>결과는 <strong>합격</strong>이었다.<br>처음으로 합격한 회사라 기분이 정말 좋았다.<br>하지만 집에 돌아가는 순간 입사하지 않기로 마음 먹었다.<br>거리가 너무 멀기도 하고, 교통편이 좋지 않아서 집에 가면서 마음이 많이 돌아섰다.<br>하지만 굉장히 실용적인 부분만 검증한 것 같아서 굉장히 좋은 면접 경험이었다.</p><h4 id="네이버-파이낸셜-분사-예정"><a href="#네이버-파이낸셜-분사-예정" class="headerlink" title="네이버 파이낸셜(분사 예정)"></a>네이버 파이낸셜(분사 예정)</h4><p><a href="https://pay.naver.com/" rel="external nofollow noopener noreferrer" target="_blank">네이버 파이낸셜</a>은 네이버 페이라는 간편 결제 서비스를 개발하는 핀테크 회사이다. (아직은 네이버 소속)<br>네이버 파이낸셜은 미래에셋에서 5000억을 투자(예정)받을 정도로 미래에 촉망받는 회사이다.<br>나는 간편결제라면 대부분 네이버 페이 밖에 안 쓰고, 굉장히 편리하게 사용하고 있는 서비스이기 때문에 지원했다. (네이버라는 네임밸류도 한 몫 했다.)  </p><p>신기하게 코딩 테스트는 보지 않고 서류를 합격하였다.<br>대신 면접장에서 화이트보드에 손코딩(정확한 문법까지 작성하진 않아도 됨)과 A4 용지에 출력된 문제들을 푸는 걸로 코딩 테스트를 대체했다.<br>내가 경력이 짧다는 이유로 이런 과정도 있었는데 경력이 많은 경우에는 이마저도 스킵하지 않을까 싶었다.<br>1차 면접에서는 역시나 프로젝트 위주의 질문을 많이 받았다.<br>면접이 끝난 후에 선물을 받았는데 2019년이 절반 이상 흘러갔는데 캘린더가 선물에 포함된 건 조금 아쉬웠다.  </p><p>1주가 흐른 후에 합격 메일을 통보 받고, 2차 면접 날짜를 잡았다.<br>2차는 기술 심층 면접이었다.<br>1차에서 물어보지 않았던 부분들에 대해서 질문을 많이 받았다.<br>초반에는 인프라 쪽 질문을 많이 받았고, 면접관 분도 개발자 불러다놓고 너무 인프라 쪽 얘기만 한 것 같다고 말씀하셨다.<br>많은 질문들이 나의 추측으로 밖에 답변할 수 없을 정도로 내 지식이 크게 부족했다.<br>그 때마다 면접관 분들은 정답을 원하는 게 아니라 그냥 알고 있는 그 대로 한 번 얘기해보라고 다독여주셨다.<br>그래서인지 면접이 끝날 때 쯤에는 몸에 산소 공급이 부족한 느낌이 들 정도로 얘기를 많이 했고, 머리에서 김이 나는 것 같았다.  </p><p>또 1주가 흐른 후에 합격 메일을 통보 받고, 마지막 3차 임원진 면접 날짜를 잡았다.<br>임원진이기 때문에 비개발직군이 들어오지 않을까 싶었는데, 내가 하는 말을 전부 이해하시는 걸 보아 개발자이거나 개발자 출신 같아 보였다.<br>그리고 블로그 하는 걸 굉장히 높게 평가해주셨고, 면접을 보는 내내 긍정적인 신호를 받았다.  </p><p>결과는 <strong>합격</strong>이다.<br>개인적으로 1차에서는 프로젝트 위주로, 2차에서는 기술 위주로 평가를 받아서 다방면에서 고루고루 평가를 제대로 받았단 느낌이 들었다.<br>하지만 3차까지 면접과정이 있다보니 역시 몸과 마음이 시간이 지나면 지날 수록 지침을 느꼈다.<br>1차와 2차는 하루에 몰아서 봤으면 어땠을까… 싶기도 하다. (그러면 내가 지쳐 쓰러졌을 지도 모르겠지만…)</p><h4 id="밸런스-히어로"><a href="#밸런스-히어로" class="headerlink" title="밸런스 히어로"></a>밸런스 히어로</h4><p><a href="https://truebalance.io/" rel="external nofollow noopener noreferrer" target="_blank">밸런스 히어로</a>는 인도에서 무선통신요금을 효율적으로 관리하는 솔루션 등등을 제공해주는 앱(트루 밸런스)을 개발한 핀테크 기업이다.<br>처음에 채용 담당자로부터 <strong>카카오톡</strong>으로 연락이 왔다. (주변 지인을 통해서 내 번호를 알았다고 한다.)<br>나는 인터넷에 핸드폰 번호를 공개한 적이 없어서 맨 처음엔 스팸인가 싶어서 무시했지만 내 주제에 오히려 굴러들어온 기회를 걷어차버리는 것 같아서 먼저 채용 담당자를 만났다.  </p><p>처음에는 별 생각없이 만났는데 정말 흥미로운 서비스 같았다.<br>일단 인도 인구가 13억 명이나 되고, 인도는 현재 개발이 크게 되지 않았고,<br>매달 1,000만명이 스마트폰을 신규가입하고, 인터넷이란 환경을 스마트폰으로 처음 접하는 세대가 대부분이라는 점이 굉장히 흥미로웠다.<br>그러다 보니 비싼 아이폰은 거의 쓰지 않고, 또 대부분이 스마트폰으로 인터넷을 접했기 때문에 프론트엔드 개발자 보다는 안드로이드 개발자가 클라이언트 쪽 주력이란 사실도 흥미로웠다.<br>그리고 서비스를 개발하는 입장에서 인도 현지에 무조건 방문한다는 사실을 듣고 설렘 반, 두려움 반이었다.</p><p>바로 그 날 저녁에 이력서를 보내고, 시간이 흘러 서류는 통과하고 코딩테스트를 봤다.<br>다른 코딩 테스트와 비슷한 수준이었는데 샘플로 등록된 테스트 코드가 많지 않았다.<br>그래서 내가 테스트 코드를 등록해서 돌려봤는데 내가 등록한 테스트 코드는 잘 통과했다.<br>그래서 바로 제출을 했는데 말하기 창피한 수준의 점수가 나와서 한숨을 푹푹 쉬어가며 떨어졌다고 생각했는데 웬걸 합격 메일이 날아왔다.</p><p>1차로 기술면접을 봤는데 그 날 처음 위워크를 방문해봤는데 상당히 시설이 좋아서 일하는 분위기 보다는 노는 분위기가 났다.<br>그리고 건물은 높은데 엘레베이터가 두 대 뿐이 없어서 엘레베이터 전쟁도 어느 정도 예상되었다.<br>네오펙트는 프로젝트 이력만 물어봤던 것에 비해서 밸런스 히어로는 기본적인 기술 관련된 질문도 좀 했다. (JVM 메모리 구조나 GC 같은…)<br>그리고 내가 진행한 배포 서버 구축 프로젝트에 대해서 내가 <strong>CI/CD</strong> 서버 구축이라고 적어놨는데 사실 단순히 배포 서버만 만든 건데 해당 단어의 의미를 정확히 모르고 사용했다는 것도 피드백을 해주셨다.  </p><p>1차 면접에 대한 결과는 그날 저녁에 바로 와서 여기 사람이 그렇게 급한가… 싶었다.<br>(아니면 내가 그만큼 뽑고 싶은 인재인가…란 생각도 들긴 했지만 아직 김칫국 마시기엔 일렀기 때문에 애써 자기 최면을 했다.)<br>2차 면접은 1차에서 기술에 대한 걸 봤기 때문에 전형적인 임원진 면접으로 알고 있었는데 테크 리더 분께서 들어오셔서 기술 심층 면접을 보았다.<br>블로그에 대해 얘기를 하다가 심도있게 작성한 글을 얘기하다보니 직접 심도있게 적은 글을 골라보라 하고 그에 대해 설명도 부탁하셨다.<br>그렇게까지 디테일하게 블로그에 대해서 물어본 적은 처음이었다.<br>그리고 해시맵이나 GC의 구조 등등에 대해서 좀 더 심도있게 질문해주셨는데 처음엔 내가 답변을 제대로 못하자 문제를 해결할 수 있게 끔 질문을 유도해주셨다.  </p><p>결과는 <strong>합격</strong>이다.<br>코딩테스트까지는 일반적인 속도였지만, 그 이후부터는 굉장히 빠르게 채용이 진행되고 결과도 빨리 알려줘서 좋았다.   </p><h4 id="비바-리퍼블리카"><a href="#비바-리퍼블리카" class="headerlink" title="비바 리퍼블리카"></a>비바 리퍼블리카</h4><p><a href="https://toss.im/" rel="external nofollow noopener noreferrer" target="_blank">비바 리퍼블리카</a>는 간편 송금 서비스로 시작한 토스란 앱을 만들고, 토스로 이름이 더 많이 알려진 핀테크 스타트업이다.<br>토스하면 복지라던지, 여러가지 무성한 소문 때문에 굉장히 높은 벽으로 인식하고 있었다.  </p><p>토스는 다른 회사와 달리 코딩 테스트를 일절 보지 않았다. (손코딩도 마찬가지로)<br>이유를 물어보니 코딩 테스트로 역량 검증이 힘들다고 했던 걸로 기억한다.  </p><p>서류 넣자마자 다음날 연락이 와서 그 다음주에 바로 1차 기술 면접 날짜를 잡았다.<br>다른 곳과 마찬가지로 대부분 프로젝트 관련된 질문이었고, 다른 데서는 인프라 쪽 얘기를 많이 했는데 여기선 서버 개발 쪽 얘기를 많이 했다.<br>내가 MSA 경험이 없고 대용량의 트래픽을 받아본 경험이 없다보니 그에 대한 답변을 못하자 계속해서 답변을 유도할 수 있는 질문을 해주셨다.</p><p>그리고 그 다음날 바로 합격 전화가 와서 또 그 주에 2차 문화 면접 날짜를 잡았다.<br>임원진 면접도 아니고, 문화 면접이기 때문에 어떻게 준비를 해야할지 막막해서 지인에게 조언을 구했다.<br>지인은 아래와 같이 조언해주었다.  </p><ol><li>인생의 목표를 설정해라.  </li><li>인생의 목표와 회사의 목표를 봐라.  </li><li>공통점을 찾아라.  </li><li>공통점이 없다면, 혹은 현저히 적다면 과감히 포기해라.  </li></ol><p>나는 거짓말을 쳐서라도 들어가고 싶은 곳은 들어가야하나 싶었는데 그 분은 장기적으로 봤을 때는 회사나 본인 둘 다에게 손해라고 말씀해주셨다.<br>누구나 해줄 수 있는 말이지만 나에겐 굉장히 영향력이 큰 분이라 위 조언을 토대로 아래와 같이 행동해보았다.  </p><ol><li>인생의 목표를 정한다.  </li><li>내 인생의 목표를 이루려면 뭘 해야할까?  </li><li>회사가 내 인생의 목표를 이루는데 도움이 될까?</li><li>된다면 어떤 부분에서 어떤 도움을 받을 수 있을까?</li></ol><p>위와 같은 고민을 하자 토스에는 내 인생의 목표를 이뤄줄만한 점이 있기 때문에 그걸 토대로 면접을 준비했다.<br>이 시간은 불과 3시간도 채 걸리지 않았다.<br>배민의 2차 면접을 위해 1주일 간 배민다움 책을 읽은 것에 비하면(1주일 내내 읽은 건 아니지만)<br>굉장히 단시간 내에 2차 면접 준비를 마쳤고, 확신 또한 있었다.</p><p>2차 면접은 위에 고민한 내용을 토대로 정리해서 답변을 했고, 나를 당홯하게 만드는 질문이나 내용들이 어느 정도 있었지만 확신을 갖고 있었기 때문에 이상한 답변을 한 것 같진 않다.<br>그리고 토스가 어떻게 일하는지, 정말 기업 문화가 어떤 문화인지 알 수 있게 해주는 면접이었다.</p><p>결과는 <strong>합격</strong>했는데 바로 그 날 저녁에 알려주었다. <del>(저녁에도 열심히 일하는 무서운 사람들…)</del><br>다른것보다도 내가 여태껏 경험해본 모든 채용과정을 통틀어 제일 빨랐다.<br>모든 과정이 1주일 내로 다 끝났다.<br>개인적으로 이런 부분도 구직자를 배려해주는 한 부분인 것 같다고 느꼈다.</p><h4 id="우아한-형제들"><a href="#우아한-형제들" class="headerlink" title="우아한 형제들"></a>우아한 형제들</h4><p><a href="https://www.woowahan.com/" rel="external nofollow noopener noreferrer" target="_blank">우아한 형제들</a>은 배달의 민족(줄여서 배민), 배민찬, 배민 라이더스 등등의 서비스를 만든 회사로 오히려 <strong>배민</strong>이란 이름으로 더 잘 알려져있다.<br>우아한 형제들을 처음 지원할 때는 굉장히 망설였다.<br>월간 카카오와 달리 한 달에 한 번 지원할 수 있는 제도가 아니기 때문에 재도전하기까지 쿨타임(기간)이 어느정도 있기 때문이었다.<br>하지만 개발이 하고 싶다는 강한 욕구와 기술 블로그와 다양한 세미나 등등을 통해 개발 문화가 탄탄한 게 눈에 보였기 때문에 고민 끝에 지원했다.</p><p>이력서 양식에서부터 신경을 많이 쓴 티가 났다. <del>(내가 쓴 이력서를 재활용하지 못해서 좀 귀찮았지만…)</del><br>일반적인 회사의 지원동기 같은 건 물어보지 않았고(아마도 없었던 걸로 기억한다.),<br>배민의 B급 감성과 잘 맞는 사람을 찾는 것인지 노래와 시를 인용해서 작성하는 내용도 있었는데 평상시 가사 보다는 비트 위주의 음악을 듣다보니 해당 내용을 그냥 무시하고 적었다.</p><p>1주일 정도가 흘러 코딩 테스트 메일이 와서 서류는 합격인 줄 알았는데 코딩 테스트까지가 서류 전형이었다.<br>문제는 크게 어렵진 않았는데 복잡도(리스트가 엄청 크다거나) 부분에서 타임아웃이 발생했다.<br>시간이 없는 관계로 제출을 하긴 했는데 계속해서 마음에 걸렸지만 어쩔 수 없었다.</p><p>또 1주일 정도가 흘러 코딩 테스트는 합격 메일이 오고, 그로부터 또 1주 후에 이제 1차 기술 면접을 보게 되었다.<br>이번 기술 면접 때도 자바나 스프링 같은 기본적인 기술보다는 프로젝트 이력 위주로 물어보았다.<br>내가 인프라 쪽 얘기를 굉장히 많이 하자 내 정체성(본인은 인프라 쪽이냐, 개발 쪽이냐)을 여쭤보고 내가 개발이라고 답하자 안심하는 듯 했다.<br>면접 분위기도 딱딱하지 않고 자연스럽게 풀어주어서 좋았다.<br>코딩 테스트에 관한 건 내 코딩 습관(메서드를 쪼개거나 변수 앞에 final을 붙이는 등등)에 대해서만 물어보았다.<br>면접 중간중간 공부 열심히 했다는 칭찬도 들었는데 이 때부터 자신감이 엄청 붙기 시작해서 면접이 끝나고 붙었다는 자신이 생겼다.<br>한편으론 면접을 못봤다고 생각했을 때도 붙은 경험이 있기 때문에 반대로 되는 게 아닐까, 나 혼자 헛소리 하다 온 게 아닐까 걱정이 됐다.<br>면접이 끝나고 배민의 B급 감성이 가득 담긴 선물을 주는데 면접 때 뭘 받아본 적은 처음이어서 기분이 되게 좋았다.</p><p>그로부터 1주일 정도가 흘러 1차 합격 메일이 오고, 2차 임원진 면접을 그로부터 1주 후에 보았다.<br>면접 보기 하루 전날에 스타벅스 기프트콘을 주는 것 또한 면접자를 배려해준다는 걸 크게 느낄 수 있었다.<br>정말정말 들어가고 싶은 회사이기 때문에 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11211590" rel="external nofollow noopener noreferrer" target="_blank">배민다움</a>이란 책도 읽었다.<br>개인적으로 배민에 들어갈 생각이 없더라도 꼭 한 번 읽어보길 권한다.<br>한 기업의 역사와 어떤 마인드를 가지고, 또 어떻게 충성도 높은 고객을, 그런 문화들을 만들어냈는지 엿볼 수 있는 기회이다.<br>책을 본 덕분에 면접은 괜찮게 봤다는 느낌이 들었다.  </p><p>그로부터 1주일 정도가 흘러 최종 <strong>합격</strong> 메일이 왔다.<br>면접자를 배려하는 점은 굉장히 좋은 경험이었지만 길었던 면접 과정에 몸과 마음이 많이 지친 것 같았다.</p><p><ins class="adsbygoogle" style="display:block;margin:60px auto;width:728px;height:90px" data-ad-client="ca-pub-3881550906962162" data-ad-slot="8264718850"></ins></p><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><h2 id="나는-어떻게-합격할-수-있었을까"><a href="#나는-어떻게-합격할-수-있었을까" class="headerlink" title="나는 어떻게 합격할 수 있었을까?"></a>나는 어떻게 합격할 수 있었을까?</h2><p>자만이 아니라 내 주관적인 판단 하에 어떤 이유 때문에 생각지도 못한 기업들에 합격할 수 있었는지 고민해봤다.<br>하나하나 나열해서 과거로 올라가자면 끝이 없을테니 적당히 추려보았다.</p><h3 id="연차대비-다양한-경험"><a href="#연차대비-다양한-경험" class="headerlink" title="연차대비 다양한 경험"></a>연차대비 다양한 경험</h3><p>나는 다음과 같은 경험을 해보았다.  </p><ol><li>프로젝트 세팅(Gradle, JDK, 기술 스택)  </li><li>서버 세팅(AWS의 VPC, Subnet, Routing Table, NAT Gateway, EC2, ELB, EB, Security Group, Route 53, RDS, ElastiCache 등등을 처음부터 끝까지 만들어보았다.)  </li><li><a href="/2017/09/28/map-api-performance-improvement/">성능 개선</a>(지도보기 API 응답 15MB -&gt; 2MB로 줄임, 응답 속도를 22초에서 0.5초로 단축)  </li><li>기존 로직을 수정할 때 먼저 기존 로직을 손대지 않고 성공하는 테스트 코드를 작성한 후에 로직을 개선하면서 테스트가 실패하지 않게 끔 하며 리팩토링</li><li>Dogfooding(외부에 제공할 서비스를 사내에서 미리 적용해봄) 용으로 진행한 프로젝트에서 Spring WebMVC를 사용해도 됨에도 불구하고 먼저 Webflux를 제안해주셔서 Webflux에 대한 간단한 이해도 및 장단점</li><li>인프라 경험<ol><li>자동화된 배포 서버 구축 및 배포 방식 통일(Jenkins, Ansible)  </li><li>서버 환경 통일(Docker)  </li><li>모니터링 시스템 구축(Prometheus, Exporter, Grafana)  </li><li>Scale In/Out에 대비하여 유동적으로 서비스 디스커버리(Consul)</li></ol></li></ol><p>위와 같은 경험은 주니어에게 AWS에 대한 제한을 걸지 않았던 환경(각자 DevOps로 일하는 문화)과 독자적으로 프로젝트를 진행할 수 있었던 환경,<br>지속적으로 AWS 쪽에 관심을 표하니 인프라 쪽 업무도 맡을 수 있게 된 환경이 나에게 주어졌기 때문에 경험할 수 있었다.<br>한마디로 복이 참 많았다.</p><h3 id="블로그"><a href="#블로그" class="headerlink" title="블로그"></a>블로그</h3><p>이번 면접에서 블로그에 대해 얘기가 나오지 않은 적이 거의 없었던 것 같다.<br>먼저 언급을 해주거나, 블로그 글 재밌게 잘 봤다고 얘기해주거나, 블로그에 나온 내용 중에 궁금한 점을 물어보거나 할 정도였으니 말이다.  </p><p>3년 전, 처음 블로그 시작은 개발자로 취직하기 전에 이력서에 한 줄이라도 더 적어보고 싶은 마음에, 스타 개발자가 되고 싶은 마음에 시작했다.<br>하지만 이제 블로그에 정리를 하지 않으면 이해도가 많이 줄어드는 것 같고, 정리를 해놓으면 마음이 좀 안심되는 지경에 이르렀다. (그럼에도 불구하고 게으를 땐 여전히 잘 안 쓴다 ㅠㅠ…)<br>또한 블로그를 해서 손해본 적은 없었던 것 같다. (앞으로는 말조심 해야할 일이 더 많을 것 같다.)<br>따라서 뭐가 됐던 블로그에 조금씩 남기다 보면 하나의 밑거름이 되지 않을까 싶다. <del>(광고 수익으로 돈까스를 공짜로 먹으려는 심산도 있긴 하다.)</del></p><h3 id="자신감"><a href="#자신감" class="headerlink" title="자신감"></a>자신감</h3><p>뭔소리냐 싶을 수 있겠지만, 합격하는 곳이 생기고 심지어 칭찬해주거나 면접 잘 봤다고 얘기해주는 면접관도 있다보니<br>그 이후에 보는 면접에서는 더 잘 대답한 것 같았다.<br>심지어 준비를 덜 했는데도 잘 본 기업도 있었다.  </p><p>물어볼 게 비슷해보였고, 그에 대해 나는 준비됐다라고 자신감을 가지기 시작하니 두렵지 않았다.<br>그전에는 ‘어떻게 내가 감히, 나는 아직 부족해’라는 생각으로 의기소침해하며 제대로 대답도 못하거나 이직 시도할 생각 조차도 하지 못했다.<br>하지만 이런 자신감을 가지고 나니 남은 면접들이 전부 수월하게 잘 풀렸다.</p><h3 id="이력서"><a href="#이력서" class="headerlink" title="이력서"></a>이력서</h3><p>지인의 조언을 받아 <a href="https://docs.google.com/document/d/1VBjqH1ghnNB7SONO0JrOHe4kTE328-YZrbm0UrQt4uE/edit?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">전형적인 국문 이력서</a>에서 <a href="https://docs.google.com/document/d/1oLILPuICSujGcaknguKo7vpfV-FrRCyp-VpDKYvAt58/edit?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">프로젝트 중심의 정보들만 남긴 이력서</a>로 탈바꿈했다.<br>전형적인 국문 이력서(사진, 성별, 나이, 주소, 학력, 성장배경 등등)는 기술 중심의 회사라면 그닥 궁금해할 거 같지 않았다.<br>‘개발자가 개발만 잘하면 되지, 뭐가 중요하냐’라는 생각에 수정을 했는데 매우 잘 한 것 같다. </p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>최종적으로 이직하기로 한 회사가 있긴 하지만, <strong>수습 3개월</strong>이라는 큰 관문이 남아있기 때문에 공개하기엔 이른 것 같다.<br>연말 쯤에는 속시원히 어떤 회사 다닌다고 말할 수 있지 않을까 싶다. </p><p>이번 면접 때 느낀 점은 회사에서 원하는 인재는 다 비슷한 것 같았다. (문화만 좀 다를 뿐이지)<br>결국엔 잘하는 사람을 원한다. (내가 잘한다고 막 자만하거나 그런 건 아니다.)<br>적어도 현재 잘하지 않더라도 열심히 해서 미래 잠재 능력을 보는 것도 같았다. (아마도 나는 이 축에 속하는 것 같고 이건 연차가 적은 주니어까지만 먹힐 것 같다.)<br>대부분이 엄청 기술적인 부분보다는 프로젝트 중심으로 많이 물어봤다. (전부 자사 서비스 회사를 가서 그런 경험이 중시된 부분도 있겠지만)<br>결국 프로젝트 경험을 쌓아야하기 때문에 개인적인 토이 프로젝트나 오픈 소스 쪽 경험을 쌓아보는 것도 좋은 것 같다.  </p><p>또한 거짓말 칠만한, 가식적인 질문들(직장 상사의 부당한 지시에 어떻게 대응할 것인지 등등)이 없었고, 나의 솔직한 대답(지원 동기)가 좋게 작용했다.<br>유튜브나 블로그에 저런 것 관련해서 어떻게 답변해야하는지, 면접관이 듣고싶어하는 답은 정해져있다 뭐 이런 내용을 어느 정도 봤었는데 그렇게까지 나 자신을 속이고 싶지 않았다. (덜 간절했던 건지도 모르겠지만…)<br>지원 동기에 대해서 어떤 회사에는 ‘잘하는 사람이 있어서 그 사람 보고 지원했습니다’, 또 어떤 회사에는 ‘평상시에 자주 사용하는 서비스인데 제가 만들고 남들이 쓰는 거 보면 뿌듯할 거 같아서’,<br>또 다른 회사에는 ‘대용량 트래픽에 대한 경험이 없다보니 그런 경험 하고 싶어서’ 이렇게 말했다.<br>인터넷에서 말하는 ‘그 회사여야만 하는 이유’, ‘다른 회사에도 써먹을 수 있는 이유면 안 된다’라는 내용에 완전 위배했다.<br>만약 내가 자신이 없었다면, 준비가 덜 됐더라면 저런 내용들로 나 자신을 숨기고 포장했을 거다.<br>하지만 나는 기술로 승부하는 개발자이기 때문에 숨김없는 나의 기술 실력으로 승부했는데 좋게 작용한 것 같고, 전부 기술 중심의 회사이기 때문에 먹힌 전략 같았다.</p><p>그리고 이번 이직을 통해서 개발자 측면에서도 많은 성장을 했지만, 한 사람 측면에서도 엄청난 성장을 했다.<br>열심히 하고, 잘 한다고 이직 해보라는 권유를 주변으로부터 종종 받았다.<br>하지만 그럴 때일 수록 ‘카프카도 잘 모르는데, 레디스도 잘 모르는데, MSA로 서버 구성도 안 해봤는데, 알고리듬이나 자료구조도 잘 모르는데, 객체지향도 잘 모르는데, 스프링도 잘 모르는데’ 이런 생각이 자꾸만 들었다.<br>그래서 ‘조금만 더 준비하고 봐야지’란 생각으로 계속 공부만 해왔다. (사실 경력 중에 공부 안 하고 인생 낭비한 세월이 절반은 된 것 같다. 물론 공부한 하면서 살진 못하겠지만…)<br>하지만 이번 이직을 통해 내가 합격하지 못할 곳이라고 생각한 기업들에 많이 떨어지기도 했지만 합격도 많이 했다.<br>그러다보니 <strong>내가 생각한 나보다 나는 좀 더 가치가 있는 사람이구나</strong>라는 걸 깨닫게 되었다.<br>그동안 내 가치를 내 스스로 깎아내리고, 제대로 판단하지 못하고 시간을 많이 낭비했다는 생각도 들었다.<br>어떻게 보면 자만일지 모르겠지만 정도 차이는 있더라도 내 가치를 내 스스로 판단하지 못한 건 사실이었다. (물론 지금도 정확히 판단하진 못하지만…)<br>그러다보니 말이나 행동할 때 자신감이 붙다보니 계속해서 좋은 결과가 있었던 것 같다.</p><p>이런 사실은 주변에서 천년 만년 말해줘도 죽었다 깨어나도 깨닫지 못한다.<br>본인이 직접 깨달아야한다. (물론 그만한 준비를 해왔다는 전제 하에…)<br>하지만 시간은 계속해서 흘러가기 때문에 최대한 빨리 깨달아야한다.<br>당신의 가치를 계속해서 깎아내리는 일이 없길 바란다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/exit-yanolja-feat-leisureq/thumb.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;오늘은 야놀자 서류상 &lt;strong&gt;퇴사일&lt;/strong&gt;이다. (오늘까지 남은 연차를 사용했다.)&lt;br&gt;총 세 번의 이직 시도 끝에 성공할 수 있었다.&lt;br&gt;여태까지 신입으로만 이직(프론트엔드 신입(5개월 재직) -&amp;gt; 백엔드 중고 신입)했고, 지인 추천을 통해서만 면접을 봤는데&lt;br&gt;이번 이직에서는 지인 추천도 있었지만, 내 힘으로 스스로 지원해서 합격까지 한 케이스도 많아서 굉장히 뿌듯한 경험이었다.&lt;br&gt;나와 같은 2~3년 차 주니어 분에게 도움이 됐으면 하는 바람, 개인적으로 회고를 하고 싶어서 정리를 해봤다.  &lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="잡동사니" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"/>
    
    
      <category term="퇴사" scheme="https://perfectacle.github.io/tags/%ED%87%B4%EC%82%AC/"/>
    
      <category term="이직" scheme="https://perfectacle.github.io/tags/%EC%9D%B4%EC%A7%81/"/>
    
      <category term="면접" scheme="https://perfectacle.github.io/tags/%EB%A9%B4%EC%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>(Hexo) NexT 테마</title>
    <link href="https://perfectacle.github.io/2019/08/22/hexo-theme-next/"/>
    <id>https://perfectacle.github.io/2019/08/22/hexo-theme-next/</id>
    <published>2019-08-22T06:38:15.000Z</published>
    <updated>2019-08-22T18:18:01.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Static-Page-Blog-테마-선정"><a href="#Static-Page-Blog-테마-선정" class="headerlink" title="Static Page Blog 테마 선정"></a>Static Page Blog 테마 선정</h2><p>Static Page로 만들어진 블로그들은 테마가 굉장히 중요하다.<br>네이버나 티스토리에는 있는 기본적인 기능들이 없는 테마들이 상당히 많다. (검색, 카테고리, 태그, 페이지네이션 등등)<br>따라서 디자인만 보고 골랐다가 커스터마이징하느라 시간을 날리기 십상이기 때문에 디자인과 기능 사이에 어느정도 절충안을 가지고 골라야한다.  </p><a id="more"></a><p><img src="/images/hexo-theme-next/hueman.png" alt=""><br>나는 이전에 <a href="https://github.com/ppoffice/hexo-theme-hueman" rel="external nofollow noopener noreferrer" target="_blank">Hueman</a> 테마를 살짝 커스터마이징해서 사용했다.<br>검색이나 카테고리, 메뉴 등등의 기능은 좋았지만 디자인이 좀 구려보였다.<br>다소 아쉽긴 했지만 블로그의 본질은 <strong>글쓰기</strong>이기 때문에 좀 더 가치있는 일에 집중을 하고 싶어서 큰 불만없이 사용하고 있었다.</p><p><img src="/images/hexo-theme-next/pork-cutlet.jpeg" alt="넘나 맛있는 내사랑 돈까스를 매주 공짜로 먹을 수만 있다면..."><br>하지만 욕심이 생겨서 구글 애드센스를 통해 조그만 수익이라도 창출해보고 싶었다.<br>그러나 번번히 정책에 부합하지 않는다는 답변만 받았다.<br>그러다보니 ‘애드센스 다느라 뻘짓할 시간에 공부해서 연봉 올리는 게 더 낫겠다’는 판단이 들었다.</p><h2 id="왜-NexT-테마로-바꾸는가"><a href="#왜-NexT-테마로-바꾸는가" class="headerlink" title="왜 NexT 테마로 바꾸는가?"></a>왜 NexT 테마로 바꾸는가?</h2><p>하지만 인간의 욕심은 끝이 없고, 주변에서 ‘왜 애드센스 안 다냐, 다른 사람들은 쉽게 통과됐다’라는 소리가 들리길래 다시 욕심이 생겼다.<br>애드센스 말고 다른 광고 플랫폼도 있지만 ‘질떨어지는 광고가 노출되면 어떡하나, 광고가 너무 과해서 사람들의 발길이 끊기면 어떡하나’ 이런 걱정들이 들었다.<br>그렇다고 해서 애드센스가 통과 잘 되는 다른 플랫폼으로 갈아타고 싶진 않았고, 내가 테마를 커스터마이징하면서 뭔가 웹표준이나 접근성에 위배되는 등등의 잘못을 저지르지 않을까 싶었다.<br>따라서 애드센스가 통과된 적이 있고, 사람들이 많이 사용하는 테마를 최대한 커스터마이징하지 않으려고 하다보니 <a href="https://github.com/theme-next/hexo-theme-next" rel="external nofollow noopener noreferrer" target="_blank">NexT</a>란 테마를 발견하게 되었다.</p><p>우선 카테고리, 메뉴, 태그, 검색 등등의 기능은 이전 Hueman 테마와 동일하다.<br>하지만 디자인이 깔끔하고 테마 안에서도 <a href="https://muse.theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Muse</a>, <a href="https://mist.theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Mist</a>, <a href="https://pisces.theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Pisces</a>, <a href="https://theme-next.org" rel="external nofollow noopener noreferrer" target="_blank">Gemini</a>와 같은 테마들이 존재한다. (나는 Pisces 테마를 택했다.)<br>또한 사이드바에 목차가 나오는 것도 좋고, 예전에는 블로그 홈에 썸네일이 없으면 좀 보기가 안 좋았는데 이 테마는 굳이 썸네일이 없어도 돼서 썸네일을 고르는데 들었던 시간을 단축시킬 수도 있다.<br><a href="https://theme-next.org/docs/" rel="external nofollow noopener noreferrer" target="_blank">문서</a>도 굉장히 잘 되있고, 한국어도 잘 지원한다.<br>또한 북마크 기능(다음에 해당 페이지 재방문시 스크롤 위치 기억), <a href="https://github.com/MoOx/pjax" rel="external nofollow noopener noreferrer" target="_blank">PJAX</a> (AJAX와 pushState를 이용하여 페이지를 처음부터 로딩하는 게 아니라 필요한 컨텐츠만 로딩), 각종 Analytic, 댓글 등등의 플러그인의 사용이 가능하다.<br>그리고 유지보수도 굉장히 활발히 이루어지고 있다.</p><p>테마를 바꾸고 만 하루만에 바로 통과되었다.<br>기존 테마를 내 맘대로 커스터마이징 하면서 뭔가 잘못 건드린 모양이다.<br><del>주 1회 매콤 치즈 돈까스를 실현하기 위해 블로그를 열심히 해야겠다.</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Static-Page-Blog-테마-선정&quot;&gt;&lt;a href=&quot;#Static-Page-Blog-테마-선정&quot; class=&quot;headerlink&quot; title=&quot;Static Page Blog 테마 선정&quot;&gt;&lt;/a&gt;Static Page Blog 테마 선정&lt;/h2&gt;&lt;p&gt;Static Page로 만들어진 블로그들은 테마가 굉장히 중요하다.&lt;br&gt;네이버나 티스토리에는 있는 기본적인 기능들이 없는 테마들이 상당히 많다. (검색, 카테고리, 태그, 페이지네이션 등등)&lt;br&gt;따라서 디자인만 보고 골랐다가 커스터마이징하느라 시간을 날리기 십상이기 때문에 디자인과 기능 사이에 어느정도 절충안을 가지고 골라야한다.  &lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="잡동사니" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"/>
    
    
      <category term="Hexo" scheme="https://perfectacle.github.io/tags/Hexo/"/>
    
      <category term="Theme" scheme="https://perfectacle.github.io/tags/Theme/"/>
    
      <category term="NexT" scheme="https://perfectacle.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>왜 한국은 미국 금리에 의존적일까?</title>
    <link href="https://perfectacle.github.io/2019/08/15/why-korea-depends-on-interest-rate-us/"/>
    <id>https://perfectacle.github.io/2019/08/15/why-korea-depends-on-interest-rate-us/</id>
    <published>2019-08-15T01:14:29.000Z</published>
    <updated>2019-08-22T05:54:34.771Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://youtu.be/0LYMTsj_eqc?t=3022" rel="external nofollow noopener noreferrer" target="_blank">EBS 다큐프라임 자본주의 제1부 돈은 빚이다</a>와<br><a href="https://www.youtube.com/channel/UClmxSq4_kJfLtyIY7TycFfw" rel="external nofollow noopener noreferrer" target="_blank">돌디</a> 님의 <a href="https://youtu.be/LzpNvyvTmIE" rel="external nofollow noopener noreferrer" target="_blank">금리</a>, <a href="https://youtu.be/jqeXqLJMYl0?t=590" rel="external nofollow noopener noreferrer" target="_blank">돈은 가짜다 - 저축만 해서 망하는 이유</a> 영상을 보면 좀 더 많은 인사이트를 쌓을 수 있다.</p><h2 id="왜-한국은-한국-금리에만-의존할-수-없는-걸까"><a href="#왜-한국은-한국-금리에만-의존할-수-없는-걸까" class="headerlink" title="왜 한국은 한국 금리에만 의존할 수 없는 걸까?"></a>왜 한국은 한국 금리에만 의존할 수 없는 걸까?</h2><p>그 이유는 바로 무역 때문이다.<br>대부분의 나라가 무역을 하기 때문에 그 나라의 금리에만 의존할 순 없을 것이다.<br>더군다나 우리 나라는 자원(석유, 나무, 철광석 등등)이 거의 없다.<br>대부분 외국에서 수입에 의존하기 때문이다.<br>이렇게 수출/수입을 할 때 쓰는 돈이 <code>기축통화</code>인데 우리나라의 통화는 기축통화가 아니기 때문에 우리나라의 금리에만 의존할 수가 없는 거다.</p><a id="more"></a><h3 id="기축통화-우리가-미국-금리에-의존할-수-밖에-없는-이유"><a href="#기축통화-우리가-미국-금리에-의존할-수-밖에-없는-이유" class="headerlink" title="기축통화 - 우리가 미국 금리에 의존할 수 밖에 없는 이유"></a>기축통화 - 우리가 미국 금리에 의존할 수 밖에 없는 이유</h3><p>기축통화는 <code>국제거래에 통용되는 결제 수단</code>으로서 가장 의미있는 돈이 기축통화인데, 현재 기축통화는 미국의 달러($)이다.  </p><p>그럼 어떻게 달러가 기축통화가 되었을까?<br>현재 미국이 경제대국이지만 과거에는 영국이 경제대국이었다.<br>그래서 2차 세계 대전 이전에는 영국의 파운드(£)가 기축통화였다.<br>하지만 2차 세계 대전 당시에 영국은 전쟁 자금을 마련하기 위해 미국으로부터 많은 돈을 빌렸고,<br>그 돈을 갚기 위해 영국은 많은 금을 미국에 지불하게 된다.<br>대부분 금을 제일 많이 가지고 있는 국가가 패권을 가지게 되고, 그로 인해 미국이 패권을 가지게 됨으로써 <code>1944년 미국 브레튼우즈 협정</code>에서 달러가 기축통화가 되었다.</p><h3 id="달러의-의미"><a href="#달러의-의미" class="headerlink" title="달러의 의미"></a>달러의 의미</h3><p><a href="/2019/08/15/money-is-debt#최초의-은행">돈은 빚이다</a>에서 말했다 싶이 금은 들고다니기 불편하므로 대부분의 사람이 금고에 금을 맡기고, 금 보관증으로 거래를 하기 시작했다.<br>기축통화가 된 달러도 마찬가지였다.<br>35 달러를 가져오면 금 1oz로 교환해주겠다고 <code>1944년 미국 브레튼우즈 협정</code>에서 정해졌다. (이를 <code>금 본위제 또는 금 태환제</code>라고 부른다.)</p><p>즉, <code>달러는 금 보관증</code>으로써 작용하기 시작했다.<br><img src="/images/why-korea-depends-on-interest-rate-us/dollar-in-past.jpeg" alt="TEN DOLLARS IN GOLD COIN이라는 문구를 주목해라."></p><p>하지만 그 이후에 베트남 전쟁으로 달러의 가치가 하락하기 시작했다.<br>달러의 가치가 하락했다는 것은 수요/공급 법칙에 의해 달러의 공급이 많아졌음을 의미한다.<br>즉, 공급이 많아졌다는 것은 중앙은행에서 달러를 많이 찍어냈음을 의미한다.<br>왜냐하면 전쟁을 하려면 많은 돈이 필요하기 때문이다.<br>그만한 금이 없음에도 불구하고 미국은 자신의 금고 안에 금이 얼마나 들어있는지는 미국 자신 밖에 모르기 때문에 <code>없는 금을 교환</code>해준다고 교환증(달러)을 마구 찍어댄 게 아닐까 싶다.</p><p>그래서 미국에 수출을 해서 달러를 벌어들인 각국은 달러의 가치를 점점 의심하기 시작한다.<br>그 결과 많은 국가가 <code>달러(금 보관증)</code>를 금으로 바꾸기 시작한다.<br>엎친데 덮친격으로 미국은 무역 적자(수출액 &lt; 수입액)였기 때문에 금은 점점 더 미국 밖으로 유출되기 시작한다.  </p><p>역사적으로 금을 가장 많이 가진 국가가 패권을 쥐기 때문에 금의 유출이 두려웠던 미국은 <code>1971년 닉슨 대통령</code>에 의해 금 본위제(달러를 금으로 교환)를 폐지하도록 한다.<br>왜냐하면 돈은 종이 쪼가리에 불과하기 때문에 중앙은행에서 찍어대기만 하면 되지만, 금은 실물이기 때문에 돈보다 생성(혹은 확보)해내기가 훨씬 어려웠기 때문이다.<br>물론 폐지할 때도 영구적으로 폐지한다고 하면 달러(금 보관증)를 소유한 나라의 반발이 심할 것이므로 미국의 경제가 살아날 때까지 임시 방편으로 폐지하는 것처럼 얘기했지만 그 이후 금 본위제는 부활하지 않고 있다.</p><p><img src="/images/why-korea-depends-on-interest-rate-us/dollar-in-present.jpg" alt="1971년 이후의 달러는 GOLD와 관련된 문구가 어디에도 적혀있지 않다."><br>이제 달러는 금으로부터 자유로워졌고, 단순히 종이 쪼가리에 불과하게 된다.<br>즉, 금의 보유량과 상관없이 이제 마구잡이로 찍어댈 수 있게 됐다.</p><h3 id="미국의-조폐공사"><a href="#미국의-조폐공사" class="headerlink" title="미국의 조폐공사"></a>미국의 조폐공사</h3><p>또한 달러의 조폐공사인 미국의 중앙은행(FRB, Federal Reserve Bank)은 한국과 달리 정부가 운영하는 기관이 아닌 <code>민간은행</code>이다.<br>따라서 민간은행에 의해 돈이 생산되다보니 완전 그들의 손아귀에 막강한 권력이 있는 것이다.<br>미국 정부마저도 중앙은행에 이자를 내고 돈을 대출받고 있다.  </p><p>어찌보면 굉장히 웃긴 일인데, 미국에서도 화폐 발행권을 민간은행에서 정부로 옮기려는 시도는 있었다.<br>케네디 대통령이 <code>암살</code>당한 해인 <code>1963년 6월</code>에 <code>대통령령 11110호(화폐의 발행권을 정부로 가져온다는 내용)</code>에 서명했다.<br>그로부터 5개월 후인 11월에 케네디 대통령은 암살 당하고, 그 이후 대통령을 맡게 된 존슨 대통령은 대통령령 11110호에 <code>서명한 것을 취소</code>했다.<br>음모론에 불과할지 모르겠지만, <code>그만큼 미국의 중앙은행이 가진 권력이 막강했기 때문에 이런 사태가 벌어졌다</code>라는 루머도 있다.</p><p>이렇게 달러는 종이 쪼가리에 불과하고(완전 종이 쪼가리까지는 아니고, 미국에 대한 신뢰도로써 사용되는 게 아닐까 싶다.), 그 달러 마저도 정부가 아닌 민간은행에서 발행하기 때문에<br>미국에 대한 의존도를 낮추자는 차원에서 다른 기축통화를 지정하자는 얘기도 있었지만 그만한 경제 규모를 가진 큰 나라가 없기 때문에 계속해서 달러가 기축통화로서 자리잡고 있는 게 아닐까 싶다.</p><h3 id="한국-금리는-미국-금리에-의존한다"><a href="#한국-금리는-미국-금리에-의존한다" class="headerlink" title="한국 금리는 미국 금리에 의존한다."></a>한국 금리는 미국 금리에 의존한다.</h3><p><a href="/2019/08/15/why-central-banks-creates-money/">왜 중앙은행은 화폐를 발행하는가? (feat. 인플레이션, 디플레이션)</a>에서 말했다 싶이 돈도 수요/공급 원칙을 따른다.<br>또한 금리(돈을 빌려주는 대가, 이자)에도 마찬가지로 수요/공급 원칙이 적용된다.  </p><p>돈을 빌리려는 사람이 많으면 공급 부족에 의해 금리는 올라간다.<br>경기가 좋으면 사람들은 많은 돈을 사용할테고, 그로 인해 돈도 빌려서 여기저기 사업도 번창하고, 투자도 많이 할 것이다.<br>이렇게 경기가 좋으면 금리는 올라가게 돼있다.</p><p>돈을 빌리려는 사람이 적으면 공급 과잉에 의해 금리는 내려간다.<br>경기가 안 좋으면 사람들의 소비 심리는 위축되고, 그로 인해 기업의 매출은 줄어들고, 기업은 매출이 줄어들었으니 인건비 절감의 목적으로 정리해고를 하고, 또 정리해고 당한 사람들은 돈을 벌지 못하니 소비 심리는 위축되고…<br>이런 사이클이 계속해서 반복된다.<br>정부 입장에서는 사람들이 소비를 하지 않으니 세금이 덜 걷히게 되니 돈을 쓰게 끔 만들어야한다.<br>돈이 있어야 쓰게 되는데 사람들은 돈이 없다보니 적은 금리로 대출해주는 것이다.<br>하지만 그럼에도 불구하고 사람들이 금리가 비싸다고 생각되면 돈을 많이 빌리지 않을테니 사람들이 돈을 많이 빌릴 때까지 계속해서 금리를 내린다.<br>0%까지 내리면 누구나 돈을 빌리고 갚지 않으면 되기 때문에 0.1%까지 낮추는 것으로 알고 있다.</p><p>이렇게 경기가 안 좋아지면 금리는 내려가고, 그러다 다시 경기가 좋아지면 금리를 올리고, 이런 싸이클이 계속해서 반복된다.  </p><p>하지만 이는 한 나라의 금리만 바라봤을 때의 얘기이고, 다른 나라의 금리까지 끼어들게 되면 상황은 좀 복잡해진다.  </p><table><thead><tr><th>은행명</th><th>이자</th><th>자본</th></tr></thead><tbody><tr><td>A</td><td>3%</td><td>건장</td></tr><tr><td>B</td><td>1%</td><td>부실</td></tr></tbody></table><p>당신이라면 어느 은행에 예금할 것인가? 이성적으로 판단해보면 당연히 A 은행에 맡길 것이다.<br>그럼 이 은행명을 국가로 바꿔보자.</p><table><thead><tr><th>국가</th><th>이자</th><th>자본</th></tr></thead><tbody><tr><td>미국</td><td>3%</td><td>건장</td></tr><tr><td>한국</td><td>1%</td><td>부실</td></tr></tbody></table><p>대부분 한국보다 미국이 훨씬 튼튼한 나라라고 생각한다.<br>더군다나 금리마저 높다면??<br>당장 한국에 투자했던 사람은 한국에 투자한 돈을 빼서 다시 미국에 투자할 것이다.<br>따라서 이런 자본의 유출을 막기 위해 경기의 상황과는 별개로 울며 겨자먹기로 금리를 조금씩 올려서 미국보다 금리를 높게 만들 수도 있을 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://youtu.be/0LYMTsj_eqc?t=3022&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;EBS 다큐프라임 자본주의 제1부 돈은 빚이다&lt;/a&gt;와&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/channel/UClmxSq4_kJfLtyIY7TycFfw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;돌디&lt;/a&gt; 님의 &lt;a href=&quot;https://youtu.be/LzpNvyvTmIE&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;금리&lt;/a&gt;, &lt;a href=&quot;https://youtu.be/jqeXqLJMYl0?t=590&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;돈은 가짜다 - 저축만 해서 망하는 이유&lt;/a&gt; 영상을 보면 좀 더 많은 인사이트를 쌓을 수 있다.&lt;/p&gt;&lt;h2 id=&quot;왜-한국은-한국-금리에만-의존할-수-없는-걸까&quot;&gt;&lt;a href=&quot;#왜-한국은-한국-금리에만-의존할-수-없는-걸까&quot; class=&quot;headerlink&quot; title=&quot;왜 한국은 한국 금리에만 의존할 수 없는 걸까?&quot;&gt;&lt;/a&gt;왜 한국은 한국 금리에만 의존할 수 없는 걸까?&lt;/h2&gt;&lt;p&gt;그 이유는 바로 무역 때문이다.&lt;br&gt;대부분의 나라가 무역을 하기 때문에 그 나라의 금리에만 의존할 순 없을 것이다.&lt;br&gt;더군다나 우리 나라는 자원(석유, 나무, 철광석 등등)이 거의 없다.&lt;br&gt;대부분 외국에서 수입에 의존하기 때문이다.&lt;br&gt;이렇게 수출/수입을 할 때 쓰는 돈이 &lt;code&gt;기축통화&lt;/code&gt;인데 우리나라의 통화는 기축통화가 아니기 때문에 우리나라의 금리에만 의존할 수가 없는 거다.&lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"/>
    
    
      <category term="경제" scheme="https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"/>
    
      <category term="자본주의" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"/>
    
      <category term="재테크" scheme="https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"/>
    
      <category term="금리" scheme="https://perfectacle.github.io/tags/%EA%B8%88%EB%A6%AC/"/>
    
      <category term="기축통화" scheme="https://perfectacle.github.io/tags/%EA%B8%B0%EC%B6%95%ED%86%B5%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>왜 중앙은행은 화폐를 발행하는가? (feat. 인플레이션, 디플레이션)</title>
    <link href="https://perfectacle.github.io/2019/08/15/why-central-banks-creates-money/"/>
    <id>https://perfectacle.github.io/2019/08/15/why-central-banks-creates-money/</id>
    <published>2019-08-14T16:56:31.000Z</published>
    <updated>2019-08-22T05:54:34.844Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/why-central-banks-creates-money/thumb.jpg" alt="돈 많이 벌고싶다..."></p><p><a href="https://youtu.be/0LYMTsj_eqc" rel="external nofollow noopener noreferrer" target="_blank">EBS 다큐프라임 자본주의 제1부 돈은 빚이다</a>를 보고 나면 더 많은 인사이트를 얻을 수 있다.</p><h2 id="물가는-왜-상승하는가-feat-인플레이션"><a href="#물가는-왜-상승하는가-feat-인플레이션" class="headerlink" title="물가는 왜 상승하는가? (feat. 인플레이션)"></a>물가는 왜 상승하는가? (feat. 인플레이션)</h2><p><img src="/images/why-central-banks-creates-money/demand-and-supply.jpg" alt="수요와 공급의 원칙을 알고 있는가?"></p><p>수요가 늘어나거나 공급이 줄어들면 가격이 올라간다.(공급 부족)<br>예를 들면 참외 농사가 흉년이 일어나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 5개로 확 줄어들은 상황이거나,<br>어느날 참외가 암을 치료해준다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1000명으로 늘어난 상황이다.</p><a id="more"></a><p>수요가 줄어들거나 공급이 늘어나면 가격은 줄어든다.(공급 과잉)<br>예를 들면 참외 농사가 풍년이 나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 1000개로 확 늘어난 상황이거나,<br>어느날 참외를 먹으면 암에 걸린다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1명으로 줄어들은 상황이다.</p><p>이렇게 특정 물건에 대해서 수요와 공급의 원칙에 의해 물가가 상승/하락하곤 한다.<br>하지만 이건 특정 물건에만 국한되는 게 아니라 돈에도 적용되는 원칙이다.</p><p>돈의 공급이 늘어나는 방법에는 두 가지 방법이 있다.</p><ol><li>중앙은행에서는 화폐를 발행할 수 있다.<br>돈을 찍어내는데 당연히 공급이 늘어날 것이다.</li><li>일반 시중에 있는 은행들(중앙은행도 마찬가지)은 빚을 생성(대출로 인해)해서 그 이자로 인해 이익을 창출한다.<br>은행은 대출해 줄 수록 이자를 많이 받을 수 있고, 그러면 그럴 수록 통화량은 증가한다.<br>즉, 새로운 빚이 생성됨과 동시에 새로운 돈이 생성되는 것이다.</li></ol><p>위와 같은 방법으로 인해 돈이 많아졌으니 돈에 대한 공급이 과잉 현상이 발생한다.<br>즉, 돈의 가치가 하락한다.</p><p>돈의 가치가 하락했는데 참외의 수요/공급 상황은 동일하다고 해보자.<br>그럼 더 많은 돈을 지불해야 참외 한 개를 살 수 있게 된다.<br>이렇게 통화량의 증가로 인해 화폐가치가 하락하고, 물가가 오르는 경제 현상을 <code>인플레이션(통화팽창)</code>이라고 한다.</p><p><img src="/images/why-central-banks-creates-money/korea-graphg.png" alt="출처: 한국은행"><br>우리나라 경제를 보면 꾸준하게 통화량도 증가했고, 그와 비슷한 추세로 물가도 같이 상승했음을 알 수 있다.</p><h2 id="중앙은행"><a href="#중앙은행" class="headerlink" title="중앙은행"></a>중앙은행</h2><p>중앙은행(우리나라의 중앙은행은 한국은행이다.)은 아래 권한들을 통해 통화량을 조절한다.</p><h3 id="이자율-통제"><a href="#이자율-통제" class="headerlink" title="이자율 통제"></a>이자율 통제</h3><p>이자율을 통제(올리고 내림)함으로써 어떻게 통화량을 조절할 수 있다는 걸까?</p><p>우선 경기가 안 좋다고 쳐보자.<br>그럼 사람들의 지갑은 무거워 질 것이고, 더더욱 경기는 안 좋아질 것이다.<br>이 때 사람들이 소비를 하게 끔 만드는 방법은 무엇일까?<br>바로 통화량을 늘려 사람들이 돈을 더 많이 가지게 끔 하면 돈을 많이 쓰게 될 것이다.<br>그러면 통화량을 늘려야하는데 이자율만 내려도 통화량은 자연스레 늘어난다.<br>이자율이 내려가면 사람들은 싼 이자에 돈을 빌릴 수 있으니 더 대출을 많이 하게 된다.<br>그럼 대출을 함으로써 새로운 돈이 생성되는 것이다. (통화량 증가)</p><p>반대로 경기가 좋다고 쳐보자.<br>경기가 좋으니 사람들의 지갑은 빵빵할 것이고, 이자율이 조금 높아져도 지갑이 빵빵하니 어느정도 납득할 것이다.<br>하지만 대부분의 사람들이 이자율이 높아지면 내야할 이자가 많기 때문에 전보다는 돈을 많이 빌리지 않게 된다.<br>또한 이자율이 비싸졌으니 비싼 이자를 감당하기 힘들어서 하루 빨리 빚을 갚으려고 할 것이다.<br>이럼으로써 빚은 적게 생성되거나 줄어들게 되다보니 통화량은 줄게 돼있다.</p><h3 id="화폐-발행"><a href="#화폐-발행" class="headerlink" title="화폐 발행"></a>화폐 발행</h3><p>말 그대로 돈을 찍어내는 것이다.<br>이자율 통제는 통화량을 늘릴 수도, 줄일 수도 있지만 화폐 발행은 통화량을 줄일 순 없다.</p><p>또한 양적 완화(quntitative easing)라는 단어도 있는데 이 단어의 뜻은 <code>중앙은행이 화폐를 찍어 통화량을 늘림으로써 경기방어와 신용경색(금융기관에서 돈이 제대로 공급되지 않아 기업들이 어려움을 겪는 현상)을 해소하는 정책</code>이라고 한다.<br>양적 완화는 이자율을 낮췄음에도 불구하고 경기가 회복되지 않는 등 효과가 없을 때 시행한다.</p><h2 id="중앙은행은-왜-화폐를-발행할까"><a href="#중앙은행은-왜-화폐를-발행할까" class="headerlink" title="중앙은행은 왜 화폐를 발행할까?"></a>중앙은행은 왜 화폐를 발행할까?</h2><p>우선 <code>경기가 안 좋아서 시중에 돈을 많이 풀려고</code>라고 생각할 수 있다.<br>하지만 이것보다 더 근본적인 무서운 이유가 존재한다.<br>그것은 <code>대출에는 이자 시스템이 존재하는데, 대출받은 돈 자체가 이자를 발생시키지 않기 때문</code>이다.</p><ol><li>중앙은행에서 여태까지 화폐를 100원만 발행했다고 쳐보자.<br>(통화량 100원)</li><li>100원을 A라는 사람에게 이자 10원과 함께 빌려줬다. (여기서 지급 준비율은 무시한다.)<br>(통화량: 100원, A의 자본: 100원)</li><li>A는 이자까지 갚기 위해 B라는 사람으로부터 보트를 10원에 산다.<br>(통화량: 100원, A의 자본: 90원, B의 자본: 10원)  </li><li>A가 보트를 타고 잡은 물고기를 B가 10원에 산다.<br>(통화량: 100원, A의 자본: 100원, B의 자본: 0원)</li></ol><p>위와 같은 상황에서 A는 아무리 열심히 일을 해도 이자 10원을 갚을 수 없다.<br>애초에 그 10원이란 돈은 존재하지 않기 때문이다.</p><ol><li>따라서 중앙은행에서 <code>이자 10원을 갚게 끔 해주기 위해 화폐를 발행</code>한다.<br>(통화량 110원, A의 자본: 100원, B의 자본: 0원)  </li><li>발행한 10원을 B에게 이자 1원과 함께 빌려준다.<br>(통화량 110원, A의 자본: 100원, B의 자본: 10원)  </li><li>다시 A가 보트를 타고 잡은 물고기를 B가 10원에 산다.<br>(통화량 110원, A의 자본: 110원, B의 자본: 0원)</li></ol><p>이렇게 <code>이자를 갚게 하기 위해 화폐를 발행</code>하고, 기존에 대출받은 사람이 아닌 다른 사람에게 대출해주고, <code>그 사람의 대출금을 내가 빼앗아와야</code> 이자까지 갚을 수 있다.<br>즉, 다른 사람의 대출금을 뺏어야하는 무서운 시스템이다.<br>또한 경기를 회복시키기 위해 화폐를 발행하는 것이 아닌 이자를 갚게 하기 위해서, 누군가 대출을 받게 하기 위해서 화폐를 발행하는 것 또한 정말 무섭다.</p><p>위와 같은 상황에서 B가 이자 11원까지 갚기 위해서는 중앙은행에서 또 화폐를 발행하고, B가 아닌 다른 누군가가 그 돈을 대출하고, 그 대출금을 뺏어와야 이자까지 갚을 수 있다.</p><p>결국 계속해서 누군가의 대출금을 뺏어와야 하는 시스템이고, 누군가의 대출금을 뺏어오지 못하는 가난하고 힘없는 자부터 파산을 하게 되는 아주 잔인한 시스템이다. 마치 폭탄 돌리기 같다…</p><h2 id="통화량이-줄어드는-경우도-있을까-feat-디플레이션"><a href="#통화량이-줄어드는-경우도-있을까-feat-디플레이션" class="headerlink" title="통화량이 줄어드는 경우도 있을까? (feat. 디플레이션)"></a>통화량이 줄어드는 경우도 있을까? (feat. 디플레이션)</h2><p>대부분의 경우에는 통화량이 계속해서 증가한다.<br>그러다가 폭탄 돌리기를 하다 시한폭탄이 터지듯, 누군가 빚을 갚지 못해 파산하는 경우에는 통화량이 줄어든다.</p><ol><li>A가 은행에 100원을 예금한다.<br>(통화량: 100원, 은행 자본: 100원)  </li><li>은행에서 지급 준비율 10%에 의해 10원만 남겨두고 90원을 B에게 대출해준다.<br>(통화량: 190원, 은행 자본: 10원)  </li><li>B가 빚을 갚지 못해 파산한다.<br>(통화량: 100원, 은행 자본: 10원)</li></ol><p>이렇게 누군가 빚을 갚지 못해 파산하는 경우에 통화량이 줄어들고 그에 따라 은행도 타격을 받고, 기존 예금주도 타격을 입는다.<br>이럴 때 <code>디플레이션(통화량의 축소로 물가가 하락하고, 경제활동이 침체되는 현상)</code>이 발생한다.<br>통화량이 축소됐으므로 수중에 갖고 있는 돈이 적다는 뜻이니 당연히 경제 활동은 침체되는 것이다.<br>기업이 위축되고, 생산과 투자를 줄이고 정리해고 하게 된다.<br>그럼 일자리가 줄어들고 돈을 벌기 힘들어진다.</p><p>하지만 무서운 점은 인플레이션 후에 디플레이션이 오는 건 <code>숙명</code>이라고 한다.<br>왜냐하면 경제 호황이 진정한 돈(생산을 통해서 번 돈 등등)이 아닌 빚으로 빌린 돈이기 때문이다.<br>그럼 그 빚이 계속해서 쌓이다가 누군가는 갚지 못하고, 그로 인해 통화량이 줄어들기 때문에 빚을 갚지 못하고, 계속해서 파산에 파산을 꼬리 물듯이 지속되면서 디플레이션이 오는 것이다.</p><p>이런 디플레이션이 오는 이유 중 하나는 갚을 능력이 되지 않는 사람에게까지 대출해주는 것이다.<br>당장 눈앞의 이익에 눈이 멀어 은행에서 나쁜 짓을 한 것이다.<br>그럼 그 사람들이 줄줄이 빚을 갚지 못해 파산할 것이다.<br>모기지 사태에서 이런 일이 벌어졌다는데 정확하게는 공부해봐야겠다.</p><p>물가가 감소되는 사례를 직접 경험하지 못해서(일본은 실제로 디플레이션이 일어난 적이 있다고 한다.) 맨날 물가는 오르기만 한다(인플레이션)고 불평불만 했는데, 오히려 내리는 것(디플레이션)보다 훨씬 나은 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/why-central-banks-creates-money/thumb.jpg&quot; alt=&quot;돈 많이 벌고싶다...&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://youtu.be/0LYMTsj_eqc&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;EBS 다큐프라임 자본주의 제1부 돈은 빚이다&lt;/a&gt;를 보고 나면 더 많은 인사이트를 얻을 수 있다.&lt;/p&gt;&lt;h2 id=&quot;물가는-왜-상승하는가-feat-인플레이션&quot;&gt;&lt;a href=&quot;#물가는-왜-상승하는가-feat-인플레이션&quot; class=&quot;headerlink&quot; title=&quot;물가는 왜 상승하는가? (feat. 인플레이션)&quot;&gt;&lt;/a&gt;물가는 왜 상승하는가? (feat. 인플레이션)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/why-central-banks-creates-money/demand-and-supply.jpg&quot; alt=&quot;수요와 공급의 원칙을 알고 있는가?&quot;&gt;&lt;/p&gt;&lt;p&gt;수요가 늘어나거나 공급이 줄어들면 가격이 올라간다.(공급 부족)&lt;br&gt;예를 들면 참외 농사가 흉년이 일어나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 5개로 확 줄어들은 상황이거나,&lt;br&gt;어느날 참외가 암을 치료해준다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1000명으로 늘어난 상황이다.&lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"/>
    
    
      <category term="경제" scheme="https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"/>
    
      <category term="자본주의" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"/>
    
      <category term="재테크" scheme="https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"/>
    
      <category term="인플레이션" scheme="https://perfectacle.github.io/tags/%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"/>
    
      <category term="디플레이션" scheme="https://perfectacle.github.io/tags/%EB%94%94%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"/>
    
      <category term="중앙은행" scheme="https://perfectacle.github.io/tags/%EC%A4%91%EC%95%99%EC%9D%80%ED%96%89/"/>
    
  </entry>
  
  <entry>
    <title>돈은 빚이다.</title>
    <link href="https://perfectacle.github.io/2019/08/15/money-is-debt/"/>
    <id>https://perfectacle.github.io/2019/08/15/money-is-debt/</id>
    <published>2019-08-14T15:08:49.000Z</published>
    <updated>2019-08-22T05:34:24.109Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/money-is-debt/thumb.png" alt="돈은 빚이다."></p><p><a href="https://youtu.be/0LYMTsj_eqc" rel="external nofollow noopener noreferrer" target="_blank">EBS 다큐프라임 자본주의 제1부 돈은 빚이다</a>를 보고 나면 더 많은 인사이트를 얻을 수 있다.</p><h2 id="돈은-어떻게-생성되는가"><a href="#돈은-어떻게-생성되는가" class="headerlink" title="돈은 어떻게 생성되는가?"></a>돈은 어떻게 생성되는가?</h2><p>개인이 돈을 만드는 가장 쉬운 방법은 돈을 버는 것이다.<br>좀 더 큰 관점에서 보면 돈 자체를 찍어내는 은행에서 돈을 만들어야 진정한 의미의 돈이 생성되는 것 같다.<br>하지만 이렇게 은행에서 찍어내는 돈은 실제 <code>통화량(시중에 유통되고 있는 화폐의 양)</code>의 극히 일부이다.<br>대부분의 돈은 <code>눈에 보이지 않는다.</code><br>즉 대부분의 돈은 <code>은행에 존재</code>한다.</p><a id="more"></a><h3 id="최초의-은행"><a href="#최초의-은행" class="headerlink" title="최초의 은행"></a>최초의 은행</h3><p>현재는 돈으로 거래를 하지만 과거 영국에선 금으로 거래를 했다.<br>사람들은 자신의 모든 금을 휴대하기 불편하고, 집에 보관하기도 불안하기 때문에 금 세공업자의 금고에 안전하게 보관해놓았다.<br>그 때는 심지어 보관하는데 보관료까지 냈다.<br>지금 생각해보면 은행에서 <code>너네 돈 안전하게 보관하고 있으니 보관료 내놔</code>하는 형태이다.<br>(언젠가 진짜 이런 세상이 올지도 모른다.)</p><p>그리고 사람들은 휴대하기 불편한 금 대신에 휴대하기 편한 <code>금 보관증</code>으로 거래하기 시작했다.<br>금 보관증만 갖고 있으면 금고로 가서 금으로 바꿀 수 있기 때문에 굳이 금으로 거래할 필요가 줄어든 것이다.<br>여기서 금 세공업자는 이런 생각을 하게 된다.<br><code>한 사람이 와서 자신의 모든 금을 찾는 일은 드물고, 모든 사람이 동시에 몰려오지도 않는다.</code><br>그래서 금고에 놀고있는 금들을 대출해주고 이자를 받아 수익을 창출하기 시작한다.</p><p>이런 소문이 흘러서 금고에 금을 맡긴 사람들에게까지 퍼져나갔다.<br>사람들은 자신의 허락도 없이 마음대로 금을 빌려주고, 이익을 얻는 금 세공업자에게 따지기 시작했다.<br>그러자 금 세공업자는 <code>대출로 얻은 이자의 일부를 주겠다</code>라고 금의 주인들과 딜을 하기 시작했다.<br>금의 주인들도 보관료를 내던 마당에서 오히려 이자를 준다니까 고마운 상황이었다.<br>금 세공업자도 조금은 아쉽지만 보관료만 받기 보다 좀 더 쏠쏠한 대출 이자의 일부를 취하는 쪽을 택했다.</p><p>그런데 얼마 지나지 않아 금 세공업자는 더욱 욕심을 내게 된다.<br><code>내 금고에 금이 얼마나 들어있는지는 나 밖에 모른다.</code>는 전제 하에 있지도 않은 금을 빌려주게 되었다.<br>물론 있지도 않은 금의 실물을 빌려줄 수 없으니 <code>금 보관증</code>을 마구 발행함으로써 있지도 않은 금을 만들게 된 것이다.<br>또한 실물 금을 찾는 사람들이 평균적으로 자신이 맡긴 금의 <code>10%</code>를 찾아간다는 사실에 의거하여 금고의 금보다 실제로 <code>10배</code>가 많은 금 보관증을 발행하였다.</p><p>시간이 지나자 이런 소문도 다시 흘러서 금 보관증을 갖고 있는 사람들의 귀에 들어갔다.<br>결국 금 세공업자를 의심한 부자들은 자신의 금을 모두 찾아갔고, 뒤늦게 금 보관증을 들고 온 사람들은 이미 금고는 텅 비었기 때문에 금을 받을 수 없었다.</p><p>이런 사태를 <code>뱅크런(Bankrun, 은행에 돈을 맡긴 사람들이 동시에 돈을 찾는 현상)</code>이라 부르며 현대의 우량한 은행들 조차 뱅크런을 맞으면 파산에 이르게 된다.</p><h3 id="현재의-은행"><a href="#현재의-은행" class="headerlink" title="현재의 은행"></a>현재의 은행</h3><p>최초의 은행과 마찬가지로 은행은 돈이 생기면 대출을 해주고 이자를 통해 수익을 얻어낸다.<br>그리고 그 이자의 일부를 예금자에게 돌려주는 형태도 마찬가지이다.</p><p>하지만 최초의 은행이 10배의 돈을 대출해 줄 수 있던 점과는 다른 점이 있는데 바로 <code>지급 준비율(은행은 예금액의 10%를 지급할 준비, 즉 보유하고 있어야한다.)</code>이다.<br>은행은 지급 준비율이 10%가 돼야한다는 토대를 마련한 게 최초의 은행에서 말한 <strong>사람들이 평균적으로 자신이 맡긴 금의 <code>10%</code>를 찾아간다</strong>는 사실을 바탕으로 만들어졌다. (우리나라의 평균 지급 준비율은 3.5%이다, 즉 더 많은 돈을 빌려줄 수 있다.)</p><p>이 지급 준비율 때문에 시중에는 없던 돈이 탄생한다.<br>간단하게 A가 은행에 100원을 예금했다고 생각해보자.<br>그럼 지급 준비율 10%에 의해 은행은 10원만 은행에 남겨두고 B에게 90원을 대출해준다.<br>이제 <code>통화량</code>은 190원이 된다.<br>여기서 90원의 없던 돈이 생겨났고, 이 돈을 <code>신용통화</code>라고 부른다.</p><p>간단한 계산을 통해 100원이란 돈이 얼만큼 불어나는지 계산해보자.</p><table><thead><tr><th>은행명</th><th>예금액</th><th>대출액</th><th>잔여 예금액</th></tr></thead><tbody><tr><td>A</td><td>100</td><td>90</td><td>10</td></tr><tr><td>B</td><td>90</td><td>81</td><td>9</td></tr><tr><td>C</td><td>81</td><td>72</td><td>9</td></tr><tr><td>D</td><td>72</td><td>64</td><td>8</td></tr><tr><td>E</td><td>64</td><td>57</td><td>7</td></tr><tr><td>F</td><td>57</td><td>51</td><td>6</td></tr><tr><td>G</td><td>51</td><td>45</td><td>6</td></tr><tr><td>H</td><td>45</td><td>40</td><td>5</td></tr><tr><td>I</td><td>40</td><td>36</td><td>4</td></tr><tr><td>J</td><td>36</td><td>32</td><td>4</td></tr><tr><td>K</td><td>32</td><td>28</td><td>4</td></tr><tr><td>L</td><td>28</td><td>25</td><td>3</td></tr><tr><td>M</td><td>25</td><td>22</td><td>3</td></tr><tr><td>N</td><td>22</td><td>19</td><td>3</td></tr><tr><td>O</td><td>19</td><td>17</td><td>2</td></tr><tr><td>P</td><td>17</td><td>15</td><td>2</td></tr><tr><td>Q</td><td>15</td><td>13</td><td>2</td></tr><tr><td>R</td><td>13</td><td>11</td><td>2</td></tr><tr><td>S</td><td>11</td><td>9</td><td>2</td></tr><tr><td>T</td><td>9</td><td>8</td><td>1</td></tr><tr><td>U</td><td>8</td><td>7</td><td>1</td></tr><tr><td>V</td><td>7</td><td>6</td><td>1</td></tr><tr><td>W</td><td>6</td><td>5</td><td>1</td></tr><tr><td>X</td><td>5</td><td>4</td><td>1</td></tr><tr><td>Y</td><td>4</td><td>3</td><td>1</td></tr><tr><td>Z</td><td>3</td><td>2</td><td>1</td></tr><tr><td>AA</td><td>2</td><td>1</td><td>1</td></tr><tr><td>AB</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>100 + 90 + 81 + 72 + 64 + 57 + 51 + 45 + 40 + 36 + 32 + 28 + 25 + 22 + 19 + 17 + 15 + 13 + 11 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 863원</p><p>정확한 계산인지는 모르겠으나 소수점까지 더하면 더 늘어날 것이다.<br>즉 원래 통화량은 100원이었는데 신용통화 763원이 추가되어 통화량은 863원이 됐다.<br>이것이 바로 통화량 대부분의 돈이 생성되는 과정이다.</p><p>지급 준비율이 낮아지면 더 많은 돈을 생성할 수 있다(통화량 증가).</p><h2 id="돈은-빚이다"><a href="#돈은-빚이다" class="headerlink" title="돈은 빚이다."></a>돈은 빚이다.</h2><p>은행은 지급 준비율을 제외한 모든 예금액을 대출해주려고 한다.<br>왜냐하면 이자를 통해 이익을 창출해내기 때문이다.<br>따라서 은행 입장에서는 어떻게든지 간에 대출을 해주고 싶어한다.<br>왜냐하면 은행에서 돈이 놀고 있으면 돈을 벌 수 없기 때문이다.</p><p>그럼 왜 돈은 빚인지 알아보자.</p><ol><li>A가 은행에 100원을 예금했다고 생각해보자.<br>(A 은행의 잔여 예금액 <code>100원</code>, 통화량 <code>100원</code>)</li><li>그럼 지급 준비율 10%에 의해 은행은 10원만 은행에 남겨두고 B에게 90원을 대출해준다.<br>(은행의 잔여 예금액 <code>10원</code>, 통화량 <code>190원</code>)</li></ol><p>위와 같이 통화량 90원은 신용통화로 B가 진 빚에 해당한다.<br>즉, 90원은 실제 은행에서 찍어낸 돈이 아닌 빚이다.<br>즉, 돈은 빚이 됐다.</p><p>위 상황에서 만약 A가 예금액 100원을 찾으려고 하면 어떻게 될까?<br>은행은 예금액을 가지고 있지 않으므로 파산하게 된다.<br>아무리 우량한 은행이라도 뱅크런이 발생하게 되면 파산하게 된다.<br>이런 뱅크런 사태는 금융위기 때 사람들이 한 번에 현금을 찾으러 오면서 발생한다고 알고 있다.<br>대부분 이런 뱅크런 사태는 일어나지 않기 때문에 사람들의 예금액은 은행에 존재하지 않고, 다 대출돼있다.<br>즉, 새로운 <code>빚</code>으로써 새로운 <code>돈</code>이 탄생하게 되는 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/money-is-debt/thumb.png&quot; alt=&quot;돈은 빚이다.&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://youtu.be/0LYMTsj_eqc&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;EBS 다큐프라임 자본주의 제1부 돈은 빚이다&lt;/a&gt;를 보고 나면 더 많은 인사이트를 얻을 수 있다.&lt;/p&gt;&lt;h2 id=&quot;돈은-어떻게-생성되는가&quot;&gt;&lt;a href=&quot;#돈은-어떻게-생성되는가&quot; class=&quot;headerlink&quot; title=&quot;돈은 어떻게 생성되는가?&quot;&gt;&lt;/a&gt;돈은 어떻게 생성되는가?&lt;/h2&gt;&lt;p&gt;개인이 돈을 만드는 가장 쉬운 방법은 돈을 버는 것이다.&lt;br&gt;좀 더 큰 관점에서 보면 돈 자체를 찍어내는 은행에서 돈을 만들어야 진정한 의미의 돈이 생성되는 것 같다.&lt;br&gt;하지만 이렇게 은행에서 찍어내는 돈은 실제 &lt;code&gt;통화량(시중에 유통되고 있는 화폐의 양)&lt;/code&gt;의 극히 일부이다.&lt;br&gt;대부분의 돈은 &lt;code&gt;눈에 보이지 않는다.&lt;/code&gt;&lt;br&gt;즉 대부분의 돈은 &lt;code&gt;은행에 존재&lt;/code&gt;한다.&lt;/p&gt;
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="경제" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"/>
    
    
      <category term="경제" scheme="https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"/>
    
      <category term="자본주의" scheme="https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"/>
    
      <category term="재테크" scheme="https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"/>
    
  </entry>
  
  <entry>
    <title>(Java) 람다 캡처링과 final 제약조건</title>
    <link href="https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/"/>
    <id>https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/</id>
    <published>2019-06-30T05:18:57.000Z</published>
    <updated>2019-08-22T05:02:20.358Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java-8-lambda-capturing/thumb.png" alt=""></p><p>람다의 바디에서는 파라미터 말고 바디 외부에 있는 변수를 참조할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaCapturing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable r = () -&gt; System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable r2 = () -&gt; System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>이렇게 람다 시그니처의 <strong>파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수</strong>를 <strong>자유 변수(Free Variable)</strong>라고 부른다.<br>또한 람다 바디에서 <strong>자유 변수를 참조하는 행위</strong>를 유식한 말로 <strong>람다 캡처링(Lambda Capturing)</strong>이라고 부른다.</p><h2 id="람다-캡처링의-제약-조건"><a href="#람다-캡처링의-제약-조건" class="headerlink" title="람다 캡처링의 제약 조건"></a>람다 캡처링의 제약 조건</h2><p>지역 변수를 람다 캡처링 할 때 아래 두 가지 제약조건이 존재한다.</p><ol><li>지역변수는 final로 선언돼있어야한다.</li><li>final로 선언되지 않은 지역변수는 final처럼 동작해야한다.<br>즉, 값의 재할당이 일어나면 안 된다.  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaCapturing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 인스턴스 변수 a는 final로 선언돼있을 필요도, final처럼 재할당하면 안된다는 제약조건도 적용되지 않는다.</span></span><br><span class="line">            a = <span class="number">123</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 지역변수 b는 final로 선언돼있기 때문에 OK</span></span><br><span class="line">        <span class="keyword">final</span> Runnable r2 = () -&gt; System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 지역변수 c는 final로 선언돼있지 않지만 final을 선언한 것과 같이 변수에 값을 재할당하지 않았으므로 OK</span></span><br><span class="line">        <span class="keyword">final</span> Runnable r3 = () -&gt; System.out.println(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 지역변수 d는 final로 선언돼있지도 않고, 값의 재할당이 일어났으므로 final처럼 동작하지 않기 때문에 X</span></span><br><span class="line">        d = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">final</span> Runnable r4 = () -&gt; System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="왜"><a href="#왜" class="headerlink" title="왜??"></a>왜??</h2><p>왜 이런 제약조건이 생기게 돼었을까?<br>왜 인스턴스 변수에는 이런 제약조건이 없는 걸까?  </p><p>우선 JVM의 메모리 구조를 알아야한다.<br>JVM에서 지역 변수는 스택이라는 영역에 생성된다.<br>그리고 실제 메모리와는 달리 JVM에서 스택 영역은 쓰레드마다 별도의 스택이 생성된다.<br>따라서 지역 변수는 <strong>쓰레드끼리 공유가 안 된다.</strong><br>JVM에서 인스턴스 변수는 힙 영역에 생성된다.<br>인스턴스 변수는 <strong>쓰레드끼리 공유가 가능하다.</strong></p><p>람다는 별도의 쓰레드에서 실행이 가능하다.<br>따라서 원래 지역 변수가 있는 쓰레드는 사라져서 해당 지역변수가 사라졌는데도 불구하고,<br>람다가 실행 중인 쓰레드는 살아있을 가능성이 있다.<br>하지만 이 람다에서 사라진 쓰레드의 지역변수를 참조하고 있으면 어떻게 될까?<br>당연히 오류가 날 것이다. 하지만 우리의 예상과는 달리 오류는 나지 않는다.<br>또한 별도의 쓰레드에서 실행된다면 별도의 스택 영역을 가질테고, 그럼 다른 쓰레드의 스택에 있는 지역변수는 참조조차 할 수 없다.<br>왜 오류는 나지 않고, 어떻게 다른 쓰레드의 스택 영역에 있는 지역 변수를 참조할 수 있는 걸까?<br>이는 람다에서 지역 변수(해당 쓰레드의 스택)에 직접적으로 접근하는 게 아니라 변수를 자신(쓰레드)의 스택에 복사하기 때문이다.<br>그렇기 때문에 별도의 쓰레드의 스택에 있는 지역 변수와 동일한 값을 참조할 수 있는 거고, 원래 쓰레드가 사라져도 본인의 쓰레드에서 자신의 할 일을 착실히 수행할 수 있는 것이다.<br>하지만 위와 같이 변수를 복사해서 쓰는데 그 변수의 값이 중구난방으로 변경된다고 하면 해당 복사본을 믿고 쓸 수 있을까?<br>따라서 지역 변수에는 final이어야하거나 final 같이 동작해야한다는 제약 조건이 생긴 것이다.</p><p>그렇다면 인스턴스 변수는 왜 이런 조건이 없는 걸까?<br>이는 인스턴스 변수는 힙에 존재하고, 쓰레드끼리 공유도 가능하기 때문에 별도로 복사할 필요도 없고, 직접 힙에 접근해서 사용하면 되기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/java-8-lambda-capturing/thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;람다의 바디에서는 파라미터 말고 바디 외부에 있는 변수를 참조할 수 있다.&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LambdaCapturing&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Runnable r = () -&amp;gt; System.out.println(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Runnable r2 = () -&amp;gt; System.out.println(b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="Lambda" scheme="https://perfectacle.github.io/tags/Lambda/"/>
    
      <category term="Java8" scheme="https://perfectacle.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>어노테이션이 달린 빈의 자동 스캔 (Without Spring Boot)</title>
    <link href="https://perfectacle.github.io/2019/06/23/auto-scanning-annotation-based-bean/"/>
    <id>https://perfectacle.github.io/2019/06/23/auto-scanning-annotation-based-bean/</id>
    <published>2019-06-23T03:08:10.000Z</published>
    <updated>2019-08-22T02:27:36.598Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/auto-scanning-annotation-based-bean/thumb.png" alt=""></p><p>스프링 부트부터 접한 스프링 알못이라 스프링에 대해 공부를 하다보니 너무나 모르고 있는 게 많아서 정리해봤다.<br>되게 간단한 건데 스프링 부트부터 접하면 몰라도 코드 짜는데는 문제가 없지만 개인적으로는 알고 있으면 너무나 좋은 내용같다.</p><h2 id="어노테이션-없이-빈-설정"><a href="#어노테이션-없이-빈-설정" class="headerlink" title="어노테이션 없이 빈 설정"></a>어노테이션 없이 빈 설정</h2><p>스프링이 관리하는 객체인 빈으로 생성하기 위해서 아래와 같은 어노테이션이 필수<strong>인 줄 알았</strong>다.<br>@Component, @Configuration, @Bean, @Service, @Controller, @Repository</p><a id="more"></a><p>하지만 직접 코딩을 해보니 이 생각은 거짓이었다.</p><p>우선 느슨한 결합을 위해 인터페이스를 하나 선언한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>인터페이스의 구현체도 하나 만들어준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimonOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>해당 구현체를 의존성으로 갖는 다른 구현체도 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 스프링 4.3부터 생성자가 하나이면 @Autowired 어노테이션이 생략 가능하다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService orderSe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = orderSe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 의존성 주입이 제대로 됐는지 테스트하기 위한 용도의 getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 CoupangOrderService 빈이 제대로 생성되는지 테스트 코드를 작성해보자. (JUnit5를 사용하였다.)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;CoupangOrderService.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트를 실행하면 circular reference(순환 참조) 때문에 빈을 생성할 수 없는 오류가 난다.<br><code>Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;coupangOrderService&#39;: Requested bean is currently in creation: Is there an unresolvable circular reference?</code>  </p><p>CoupangOrderService는 OrderService 인터페이스를 의존성으로 받는데 그 구현체가 CoupangOrderService 자신 밖에 없기 때문이다.<br>(@ContextConfiguration(classes = {CoupangOrderService.class})에 의해 ApplicationContext에서는 CoupangOrderService 밖에 모르기 때문이다.)</p><p>그럼 ApplicationContext가 OrderService의 다른 구현체인 TimonOrderService까지 알게 해주자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;CoupangOrderService.class, TimonOrderService.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트는 성공한다.<br>우리는 빈에 대한 어노테이션을 인터페이스나 구현체 어디에도 사용을 하지 않았는데 빈의 생성도 잘 이뤄졌고, 의존성 주입도 아주 잘 되었다.<br>CoupangOrderService에서 OrderService를 의존성 주입 받는데 OrderService의 구현체는 CoupangOrderService와 TimonOrderService 두 개이다.<br>하지만 스프링에서는 똑똑하게 순환참조 이슈를 피하려고 본인을 제외하고 빈을 찾기 때문에 순환참조 오류가 안 났다.  </p><p>한 번 위 가설이 맞는지 검증해보자.<br>OrderService의 구현체를 하나 더 만들어보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeMakePriceOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트를 돌려보면 아래와 같이 CoupangOrderService에 OrderService를 주입하는데 TimonOrderService를 주입해야할지, WeMakePriceOrderService를 주입해야할지 모른다는 오류가 나온다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;CoupangOrderService.class, TimonOrderService.class, WeMakePriceOrderService.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;OrderService&#39; available: expected single matching bean but found 2: timonOrderService,weMakePriceOrderService</code></p><p>OrderService의 구현체는 세 개인데 당연스레 본인(CoupangOrderService)는 빼고 의존성 주입을 시도한 것이다.<br>그럼 위 테스트는 왜 실패한 것인가?<br>기본적으로 스프링은 아래와 같은 순서로 DI를 하게 된다.  </p><ol><li>빈의 타입으로 빈을 검색해서 주입한다.  </li><li>해당 빈의 타입이 두 개 이상이면 빈의 이름으로 검색해서 주입한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService orderSe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.otherService = orderSe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderService의 빈은 2개(CoupangOrderService 본인을 제외하고)라서 빈의 이름으로 검색을해야하는데 <strong>orderSe</strong>라는 이름의 빈은 없기 때문이다.<br>빈의 이름은 기본적으로 클래스 이름을 기반으로 생성된다. <del>(규칙은 나중에 찾아보는 걸로…)</del>  </p><p>이제 테스트가 성공하게 제대로 된 빈의 이름으로 바꿔주자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 스프링 4.3부터 생성자가 하나이면 @Autowired 어노테이션이 생략 가능하다.</span></span><br><span class="line">    <span class="comment">// 파라미터로 넘긴 변수 이름이 빈의 이름이 된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService timonOrderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = timonOrderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="빈-자동-스캔"><a href="#빈-자동-스캔" class="headerlink" title="빈 자동 스캔"></a>빈 자동 스캔</h2><p>우리가 생성한 빈이 많으면 많을 수록 @ContextConfiguration에 다 등록해주기도 부담이다.<br>이럴 때 쓰는 게 @Service, @Component, @Configuration, @Bean과 같은 어노테이션들이다.</p><p>우선 인터페이스와 구현체 어디다 쓰는 게 좋은지 모르니 다 붙여놓자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimonOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeMakePriceOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService timonOrderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = timonOrderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 빈을 자동으로 스캔해주는 빈을 만들어주자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"some.package"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>해당 패키지에 있는 @Service, @Component, @Configuration, @Bean 요런 어노테이션들이 붙은 빈들은 자동으로 스캔하고 생성해주는 어노테이션이다.<br><del>(자세한 건 나중에 또 알아보자 ㅠㅠ)</del></p><p>이제 테스트에서 Bean 클래스들을 한땀 한땀 넣어주는 부분을 수정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;ComponentScanConfig.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Config 파일 하나로 코드가 너무나 쾌적해졌다.<br>이렇게 빈을 자동으로 스캔하고 생성할 때는 <strong>@ComponentScan</strong> 어노테이션이 엄청 큰 도움이 된다.  </p><h2 id="어노테이션은-인터페이스에-구현체에"><a href="#어노테이션은-인터페이스에-구현체에" class="headerlink" title="어노테이션은 인터페이스에? 구현체에?"></a>어노테이션은 인터페이스에? 구현체에?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>어노테이션을 인터페이스에<strong>만</strong> 붙이면 구현체 타입으로 DI를 받을 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;ComponentScanConfig.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//    CoupangOrderService 타입의 빈은 @Service 어노테이션이 안 달려있어서 @ComponentScan에서 검색되지 못한다.    </span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private CoupangOrderService coupangOrderService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line"><span class="comment">//        OrderService 인터페이스에는 getOtherService() 메서드가 없다.</span></span><br><span class="line"><span class="comment">//        assertNotNull(coupangOrderService.getOtherService());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 이번엔 빈을 생성하지 못한다는 에러가 나온다.<br><code>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;example.domain.OrderService&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}</code><br>왜냐면 인터페이스만 @Service 어노테이션을 붙여서 빈으로 생성이 되는데 인터페이스는 객체로 생성이 불가능하기 때문에 위와 같은 오류가 나는 것이다.  </p><p>그럼 이번엔 구현체에만 @Service 어노테이션을 붙이면 어떻게 될까?  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoupangOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderService otherService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoupangOrderService</span><span class="params">(OrderService timonOrderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherService = timonOrderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">getOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트를 고쳐보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;ComponentScanConfig.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//    CoupangOrderService는 OrderService를 구현한 것이므로 OrderService 타입으로도 DI 받을 수 있다.</span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private OrderService coupangOrderService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoupangOrderService coupangOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(coupangOrderService);</span><br><span class="line">        assertNotNull(coupangOrderService.getOtherService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 돌리면 또 순환참조 오류로 실패한다.<br><code>Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;coupangOrderService&#39;: Requested bean is currently in creation: Is there an unresolvable circular reference?</code></p><p>다른 OrderService 구현체에도 @Service 어노테이션을 붙여주자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimonOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeMakePriceOrderService</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트를 돌리면 정상적으로 돌아간다.</p><p>인터페이스에 어노테이션 안 붙여도 인터페이스 타입으로 느슨하게 결합해서 DI도 가능하고, 특정 구현체에 기능이 쓰고 싶다면 해당 구현체 타입으로 DI도 가능하고…<br>따라서 내가 봤을 때는 인터페이스에 어노테이션을 붙여놓는 건 딱히 의미가 없는 것 같다. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/auto-scanning-annotation-based-bean/thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;스프링 부트부터 접한 스프링 알못이라 스프링에 대해 공부를 하다보니 너무나 모르고 있는 게 많아서 정리해봤다.&lt;br&gt;되게 간단한 건데 스프링 부트부터 접하면 몰라도 코드 짜는데는 문제가 없지만 개인적으로는 알고 있으면 너무나 좋은 내용같다.&lt;/p&gt;&lt;h2 id=&quot;어노테이션-없이-빈-설정&quot;&gt;&lt;a href=&quot;#어노테이션-없이-빈-설정&quot; class=&quot;headerlink&quot; title=&quot;어노테이션 없이 빈 설정&quot;&gt;&lt;/a&gt;어노테이션 없이 빈 설정&lt;/h2&gt;&lt;p&gt;스프링이 관리하는 객체인 빈으로 생성하기 위해서 아래와 같은 어노테이션이 필수&lt;strong&gt;인 줄 알았&lt;/strong&gt;다.&lt;br&gt;@Component, @Configuration, @Bean, @Service, @Controller, @Repository&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end" scheme="https://perfectacle.github.io/categories/Back-end/"/>
    
      <category term="Spring" scheme="https://perfectacle.github.io/categories/Back-end/Spring/"/>
    
    
      <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
      <category term="Bean" scheme="https://perfectacle.github.io/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) 내 로컬에서는 잘 되는데...? (내로잘)</title>
    <link href="https://perfectacle.github.io/2019/06/11/aws-sg-trobuleshooting/"/>
    <id>https://perfectacle.github.io/2019/06/11/aws-sg-trobuleshooting/</id>
    <published>2019-06-11T13:28:23.000Z</published>
    <updated>2019-08-22T02:48:30.047Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/aws-sg-trobuleshooting/thumb.jpg" alt="미리보는 교훈: 남탓을 하지 말자"></p><p><img src="/images/aws-sg-trobuleshooting/reporter.png" alt="오늘도 어김없이 외부를 통해 장애가 제보되었다."><br><img src="/images/aws-sg-trobuleshooting/work-on-my-local.png" alt="하지만 내 로컬에서는 잘 됐다. (이럴 때 쓰는 말이 내로잘, 내 로컬에서는 잘 되는데...?)"><br>내 PC에서는 잘 되는데 버그 제보자가 직접 모바일 웹에서 안 되는 걸 보여줬다.<br>그리고 내 모바일에서도 해봤고, 다른 사람들의 모바일에서도 전부 안 됐다. (안드로이드, iOS에서 크롬, 사파리, 삼성 인터넷 가릴 것 없이 다 안 됐다.)  </p><p>PC에서는 잘 되고, 모바일에서는 안 된다… 나는 당연히 프론트 이슈로 여겼다.<br>혹시 서버 쪽 이슈일까봐 액세스 로그를 모니터링해보니 헬스 체크 이외에 로그가 안 찍히길래 자바스크립트 어딘가에서 오류가 나서 API 호출도 못 하는 거라고 확신했다.  </p><a id="more"></a><p>프론트 개발자 분께서 모바일 브라우저 디버깅을 위해 세팅도 다 했는데 브라우저의 콘솔을 보니 에러 로그가 안 찍히는 것이었다.<br><img src="/images/aws-sg-trobuleshooting/charles.png" alt="그리고 혹시나 싶어서 프론트 개발자 분께서 Charles까지 깔아서 확인도 해주셨는데 패킷도 날아가지 않았다.">  </p><p>귀신이 곡할 노릇이라 환경을 완전히 통일시키기 위해 도커로 띄워야하나… 이런 고민까지 하고 있던 찰나에<br>프론트 개발자 분께서 내가 접속한 와이파이(사내 와이파이)와 자신이 모바일로 접속한 와이파이(게스트용 와이파이)의 차이점을 발견하였다.<br>(사내 정책 때문에 모바일에서는 게스트용 와이파이를 쓰고 있었다.)  </p><p><img src="/images/aws-sg-trobuleshooting/security-group.png" alt="뭔가 촉이 와서 Security Group을 전부 오픈했더니 문제가 해결되었다.">  </p><h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p><img src="/images/aws-sg-trobuleshooting/why-work-why-not-work.png" alt=""><br>우선 상황은 이랬다.  </p><ul><li>초반에 상품 10개는 잘 불러온다. (왜 잘 불러와지지?)  </li><li>추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다. (왜 안 불러와지지?)</li></ul><p>계속 고뇌에 빠졌고, 결국 네트워크 지식이 부족한 탓에 이런 일이 일어났었다.</p><h3 id="초반에-상품-10개는-잘-불러온다"><a href="#초반에-상품-10개는-잘-불러온다" class="headerlink" title="초반에 상품 10개는 잘 불러온다."></a>초반에 상품 10개는 잘 불러온다.</h3><p>우선 프론트 엔드에서 렌더링을 빠르게 하려는 이유에서인지 SSR(Server Side Rendering)을 사용했다.<br><img src="/images/aws-sg-trobuleshooting/ssr.png" alt="출처: https://medium.com/walmartlabs/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8"><br>일반적인 CSR(Client Side Rendering)에서는 클라이언트 측에서 AJAX 방식으로 API를 호출했다면,<br>SSR은 클라이언트 측에서 렌더링이 되기 전에 필요한 데이터가 모두 갖춰진 상태로 서버에서 HTML 파일을 내려주는 형태이다.<br>즉, API 호출이 서버에서 일어난다. (이는 <strong>Server to Server</strong>로 API 호출이 일어남을 의미한다.)  </p><p><img src="/images/aws-sg-trobuleshooting/server-to-server-bad.png" alt="Server to Server를 위해서 Public IP를 쓰면 네트워크 밖을 나갔다 들어오기 때문에 레이턴시와 비용이 추가될 수 밖에 없다."><br><img src="/images/aws-sg-trobuleshooting/internal.png" alt="따라서 Server to Server를 위해서는 Internal ELB를 통해 Private IP로만 통신하고 있다."><br><img src="/images/aws-sg-trobuleshooting/internal-sg.png" alt="내부 통신을 위한 Internal ELB의 경우에는 동일한 VPC 내의 요청이라면 허용하도록 Security Group을 구성했다.">  </p><p>위와 같이 Security Group을 세팅하고, 초반에 불러오는 상품은 SSR의 특성상 Server to Server로 호출하기 때문에 API 호출이 성공했던 것이다.</p><h3 id="추가로-상품-10개를-더-불러오려고-하면-불러와지지-않는다"><a href="#추가로-상품-10개를-더-불러오려고-하면-불러와지지-않는다" class="headerlink" title="추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다."></a>추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다.</h3><p><img src="/images/aws-sg-trobuleshooting/inbound-mistake.png" alt="나는 이 경우도 Front 서버와 API 서버가 Server to Server로 통신하는 걸로 착각을 했다."><br><img src="/images/aws-sg-trobuleshooting/inbound-real.png" alt="하지만 Front 서버를 경유하지 않고 클라이언트(브라우저)에서 바로 API 서버를 호출하고 있었다."><br><img src="/images/aws-sg-trobuleshooting/public-elb-sg.png" alt="나는 API 서버의 Public ELB는 개발 환경에서만 접근한다고 생각하고 위와같이 구성했었다."><br>위와 같이 구성하니 개발환경이 아닌 경우(게스트 와이파이나 LTE 등등)에는 API 호출이 실패하는 것이었다.<br>이래서 내 로컬(사내 와이파이)에서는 잘 되는데, 버그 제보자의 모바일(게스트 와이파이)에서는 장애가 재현된 것이다.<br>즉, 초기 SSR로 호출하는 API(Server to Server 방식)을 제외하고는 제대로 API 호출이 안 되는 상황이었다.  </p><p>따라서 모든 IP에 대해서 API에 대한 접근을 허용할 수 밖에 없었다.<br>(추후에는 Front 서버를 통해서만 통신하게 끔 변경해야할 것이다.) </p><h2 id="오늘의-교훈은-뭘까-요"><a href="#오늘의-교훈은-뭘까-요" class="headerlink" title="오늘의 교훈은 뭘까~요?"></a>오늘의 교훈은 뭘까<del>~</del>요?</h2><p><img src="/images/aws-sg-trobuleshooting/pokemon.jpg" alt="피..피카츄!!"><br>오늘 느낀 점은 <strong>남탓</strong>을 하지 말자 이다.<br>나는 당연히 프론트 이슈일 줄 알고 뒷짐지고 있었다.<br>그러는 와중에 프론트 개발자 분은 모바일 디버깅 환경까지 세팅하고, Charles(패킷 캡쳐 도구)까지 깔아서 오류를 분석해주셨다.<br>심지어 이번 이슈의 핵심인 와이파이가 다르다는 점까지 발견해주셨다.<br>그동안 나는 뒷짐을 지고 있었다. <del>(그렇다고 일을 안 하고 있던 건 아니고…)</del><br>프론트 개발자 분께서는 충분히 화가 날 수도 있는 상황이었다.<br>그 분의 바쁜 시간을 본인의 이슈가 아닌데도 불구하고 열심히 삽질을 했으니 말이다.  </p><p>요즘 들어 이 이슈, 저 이슈에 관여를 하면서 <code>아... 내가 이 이슈까지 봐야할까? 내가 하고 있는 일이랑은 관련이 적어보이는데...</code>하고 소극적인 태도를 많이 보였다.<br>하지만 이번 일을 계기로 이런 생각을 고쳐먹어야겠다고 다짐했다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/aws-sg-trobuleshooting/thumb.jpg&quot; alt=&quot;미리보는 교훈: 남탓을 하지 말자&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/aws-sg-trobuleshooting/reporter.png&quot; alt=&quot;오늘도 어김없이 외부를 통해 장애가 제보되었다.&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/aws-sg-trobuleshooting/work-on-my-local.png&quot; alt=&quot;하지만 내 로컬에서는 잘 됐다. (이럴 때 쓰는 말이 내로잘, 내 로컬에서는 잘 되는데...?)&quot;&gt;&lt;br&gt;내 PC에서는 잘 되는데 버그 제보자가 직접 모바일 웹에서 안 되는 걸 보여줬다.&lt;br&gt;그리고 내 모바일에서도 해봤고, 다른 사람들의 모바일에서도 전부 안 됐다. (안드로이드, iOS에서 크롬, 사파리, 삼성 인터넷 가릴 것 없이 다 안 됐다.)  &lt;/p&gt;&lt;p&gt;PC에서는 잘 되고, 모바일에서는 안 된다… 나는 당연히 프론트 이슈로 여겼다.&lt;br&gt;혹시 서버 쪽 이슈일까봐 액세스 로그를 모니터링해보니 헬스 체크 이외에 로그가 안 찍히길래 자바스크립트 어딘가에서 오류가 나서 API 호출도 못 하는 거라고 확신했다.  &lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="AWS" scheme="https://perfectacle.github.io/tags/AWS/"/>
    
      <category term="Network" scheme="https://perfectacle.github.io/tags/Network/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) Thread Dump 분석 도전기</title>
    <link href="https://perfectacle.github.io/2019/06/11/thread-dump-analyze/"/>
    <id>https://perfectacle.github.io/2019/06/11/thread-dump-analyze/</id>
    <published>2019-06-10T16:19:36.000Z</published>
    <updated>2019-08-22T05:54:34.669Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/thread-dump-analyze/thumb.png" alt="쓰레드 덤프도 처음인지라 하면서 뭔가 두려웠다."></p><h2 id="사건의-시작"><a href="#사건의-시작" class="headerlink" title="사건의 시작"></a>사건의 시작</h2><p><img src="/images/thread-dump-analyze/alert.png" alt="평화로운 어느날, Alert Manager의 역습"><br>갑자기 Nginx가 Down 됐다는 알림이 와서 해당 서버로 접속해보니 Nginx 서비스는 정상적으로 떠있고…<br>curl도 때려보고, 브라우저에서 직접 URL로 접속해봤을 때 문제가 없었다.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># blackbox exporter configuration</span></span><br><span class="line"><span class="attr">modules:</span></span><br><span class="line"><span class="attr">  http_health:</span></span><br><span class="line"><span class="attr">    prober:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">      valid_status_codes:</span> <span class="string">[200]</span></span><br><span class="line"><span class="attr">      preferred_ip_protocol:</span> <span class="string">"ip4"</span></span><br><span class="line"><span class="attr">      ip_protocol_fallback:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>80포트에 대해서 http 요청을 보냈을 때 5초 이내에 200 OK가 안 오면 알람을 발생시키게 했는데 내가 테스트 해 본 바로는 아무런 문제도 없었다.<br>(일단 5초라는 관대한 시간으로 걸어놓은 것도 문제였고, 내가 간단히 메인 페이지만 몇 번 들락날락 해본 것도 문제였다.)</p><p>따라서 <code>나는 Alert Manager가 오작동하나 보다... 역시 내가 이 쪽 경험이 부족하다보니 뭔가 잘못 셋팅했나 보다.</code>하며 대수롭지 않게 넘겼다.</p><h2 id="불행의-시작"><a href="#불행의-시작" class="headerlink" title="불행의 시작"></a>불행의 시작</h2><p><img src="/images/thread-dump-analyze/begin-unlucky.png" alt="우리가 먼저 알아차리려고 모니터링 시스템을 열심히 구축했는데 또 외부에서 먼저 제보를 받게 되었다."></p><p>우선 열심히 구축해놓은 모니터링 시스템을 굴릴 수 없으니 EC2 인스턴스 및 JVM 메모리에 대한 지표를 살펴보았다.<br>우선 인스턴스의 CPU나 메모리는 문제가 없었고 JVM 메모리나 GC 쪽에도 문제가 없었다.</p><p><img src="/images/thread-dump-analyze/http-5xx.png" alt="내가 최초로 알림을 받기 시작한 23분 쯤부터 5xx가 점점 발생하기 시작했다."><br><img src="/images/thread-dump-analyze/thread-monitoring.png" alt="쓰레드를 점점 많이 쓰더니 가용 가능한 쓰레드를 전부 쓰고 있었다.">  </p><p><img src="/images/thread-dump-analyze/cto-jjam.png" alt="CTO 님께서는 짬에서 나오는 바이브를 물씬 풍겨주었다."><br>나는 쓰레드 쪽에 문제가 있으니 우선 쓰레드 덤프부터 뜨고 봐야하나? 이 생각이었는데 저 지표를 보자마자 저런 생각이 떠오른다는 건 역시 경험은 무시할 수가 없는 것 같다.</p><p><img src="/images/thread-dump-analyze/rds-cpu.png" alt="해당 시간대의 AWS RDS의 CPU 사용량을 보니 100%를 치고 있었다."></p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>우선 DB 쪽에 장애가 서버까지 전파된 걸 확인했으니 서버 쪽에서 어떤 쿼리를 수행하길래 저런 에러가 나오는지 봐야했다.<br>쓰레드 쪽에 문제가 있다고 판단했으니 우선 jstack으로 쓰레드 덤프를 뜨고 별도의 툴을 깔지 않고 온라인(<a href="https://fastthread.io/" rel="external nofollow noopener noreferrer" target="_blank">fastThread</a>)에서 쓰레드 덤프를 분석해봤다.  </p><p><img src="/images/thread-dump-analyze/thread-group.png" alt="http-nio-8080-exec-xxx 이런 쓰레드 118개나 TIMED_WAITING 상태였다."><br><img src="/images/thread-dump-analyze/http-nio-8080-exec-xxx.png" alt=""><br>나는 뭔가 어플리케이션 코드가 스택 트레이스에 찍혀있길 기대했지만 그런 건 없었다.<br>일단 쓰레드 네임을 보아하니 http 요청에 의한 것으로 판단되니 Nginx의 Access Log를 뒤져보면 뭔가 나오지 않을까 싶었다.  </p><p><img src="/images/thread-dump-analyze/nginx-access-log.png" alt="다른 요청들 사이에 껴서 혼자 8 ~ 9초 정도 처리 시간이 걸렸다."><br>파라미터에도 ALL 하나만 들어가있는 걸 보면 뭔가 전체 조회를 하는 구린 냄새가 나는 코드 같다.<br>눈여겨 볼 점은 처음 발생한 시점이다.<br>11시 20분에 저렇게 느린 요청들이 발생하기 시작했는데, 내가 알람을 받은 건 23분부터 받기 시작했다.<br>아마 5초라는 관대한 시간을 줬기 때문에 더 알람을 늦게 받게된 게 아닌가 싶다.  </p><p><img src="/images/thread-dump-analyze/nginx-access-log-2.png" alt="심지어는 60초까지 걸렸다."><br>이제는 유저가 못참고 페이지를 이탈해서 <a href="https://httpstatuses.com/499" rel="external nofollow noopener noreferrer" target="_blank">HTTP Status Code 499</a>도 나왔다.<br>동일한 API에서 계속해서 10초 이상이 걸리고, 점점 느려지는 걸 보니 해당 API의 문제가 맞다고 80% 정도는 확신을 했다.</p><p>실제로 해당 코드를 보니 페이징 처리나 조건문이 좀 부실했었고, 쿼리를 손 본 후에야 문제를 해결할 수 있었다. </p><h2 id="오늘의-교훈"><a href="#오늘의-교훈" class="headerlink" title="오늘의 교훈"></a>오늘의 교훈</h2><p><img src="/images/thread-dump-analyze/pokemon.jpg" alt="오늘의 교훈은 뭘까~~~요?"><br><del>피…피카츄!!</del><br>Alert Manger가 알림을 줬을 때 난 무시를 했다.<br>아니 무시한 건 아니지만 아주 간단하게만 테스트했다.<br>기계는 사람보다 정확하니 무시하지 말고 좀 더 면밀히 관찰하고 얼른 팀 내에 공유를 해야 앞으로 이런 사태가 발생하지 않을 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/thread-dump-analyze/thumb.png&quot; alt=&quot;쓰레드 덤프도 처음인지라 하면서 뭔가 두려웠다.&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;사건의-시작&quot;&gt;&lt;a href=&quot;#사건의-시작&quot; class=&quot;headerlink&quot; title=&quot;사건의 시작&quot;&gt;&lt;/a&gt;사건의 시작&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/thread-dump-analyze/alert.png&quot; alt=&quot;평화로운 어느날, Alert Manager의 역습&quot;&gt;&lt;br&gt;갑자기 Nginx가 Down 됐다는 알림이 와서 해당 서버로 접속해보니 Nginx 서비스는 정상적으로 떠있고…&lt;br&gt;curl도 때려보고, 브라우저에서 직접 URL로 접속해봤을 때 문제가 없었다.  &lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# blackbox exporter configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;modules:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  http_health:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    prober:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;http&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    timeout:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    http:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      method:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;GET&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      valid_status_codes:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;[200]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      preferred_ip_protocol:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;ip4&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      ip_protocol_fallback:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="Thread" scheme="https://perfectacle.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) 레디스 사망일기</title>
    <link href="https://perfectacle.github.io/2019/05/29/redis-monitoring/"/>
    <id>https://perfectacle.github.io/2019/05/29/redis-monitoring/</id>
    <published>2019-05-28T18:00:50.000Z</published>
    <updated>2019-08-22T05:54:34.803Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/redis-monitoring/thumb.png" alt="점점 산으로 가는 그래프..."></p><h2 id="사건의-발단"><a href="#사건의-발단" class="headerlink" title="사건의 발단"></a>사건의 발단</h2><p>사내에서 사용하는 어드민(이하 <strong>어드민 A</strong>)/외부에서 사용하는 어드민(이하 <strong>어드민 B</strong>)이 사망하는 사례가 속출하였다.<br>그 시점은 내가 새롭게 서버를 옮긴 이후부터 발생했다.<br>내가 서버를 옮긴 것과 이 일이 관련이 없다고 생각했지만,<br>우선 내가 서버를 옮긴 이후에 발생한 사건이기도 해서 부검을 통해 사인을 밝혀내는 게 우선이었다.</p><a id="more"></a><h2 id="왜-사망했나"><a href="#왜-사망했나" class="headerlink" title="왜 사망했나"></a>왜 사망했나</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.QueryTimeoutException: Redis command timed out; nested exception is com.lambdaworks.redis.RedisCommandTimeoutException: Command timed out</span><br><span class="line">at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:66)</span><br><span class="line">at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:41)</span><br></pre></td></tr></table></figure><p>elasticsearch에 저장된 에러 로그를 확인해본 결과 위와 같은 스택 트레이스를 남기고 전사하셨다.<br>즉, 레디스가 사망해서 레디스를 사용하는 어드민 서버도 사망한 것이었다.<br>다행인 것은 아예 프로세스 자체가 사망한 게 아니라 Hang에 걸린 상태여서 레디스를 재시작하는 것만으로 사건은 일단락 되었다.<br>하지만 머지않은 시점에 또 다시 사망하는 사례가 발생하였다.</p><h2 id="응급-처치"><a href="#응급-처치" class="headerlink" title="응급 처치"></a>응급 처치</h2><p><img src="/images/redis-monitoring/legacy-redis.png" alt=""><br>우선 어드민 A가 사용하는 레디스(이하 <strong>레디스 A</strong>)와 어드민 B가 사용하는 레디스(이하 <strong>레디스 B</strong>)가 같은 EC2 인스턴스 내에 존재하였다.<br>또한 메모리 1GB라는 소규모 서버에서 구동하다보니 인메모리 기반의 DB인 레디스에는 굉장히 협소하다고 생각했다.<br>하지만 우리가 사용하는 건 로그인 세션을 위해서만 사용하지, 그 이외의 것은 사용하지 않고 있어서 여전히 의아하긴 했다.<br>하지만 문제가 계속해서 발생하다보니 우선은 스케일업을 해야했다.  </p><p><img src="/images/redis-monitoring/new-redis.png" alt=""><br>그 중에 레디스 A보다 레디스 B가 더 자주 뻗어서 레디스 B를 새로운 서버로 옮기기로 했다.<br>트래픽이 그렇게 많지도 않은 어드민 서버의 로그인 세션만 저장하는데<br>메모리를 8GB씩이나 주는 건 약간 오버하는 경향이 없잖아 보였지만 일단 안정성을 챙기고자 좀 빵빵하게 주었다.</p><h2 id="진짜-이유를-찾아서"><a href="#진짜-이유를-찾아서" class="headerlink" title="진짜 이유를 찾아서"></a>진짜 이유를 찾아서</h2><p>나는 이미 8GB로 스케일업 했기 때문에 더이상 이런 사건이 발생하지 않을 것으로 예상했지만,<br>CTO 님께서는 좀 더 정확하게 원인을 분석하자고 하셨다.<br>나도 대충대충 넘어가다보면 영 찜찜하기도 해서 <del>내 역량도 그닥 올라갈 거 같지 않아서</del> 정확하게 원인을 분석해보는 게 좋을 것 같았다.  </p><p><img src="/images/redis-monitoring/monitoring.png" alt="어디서부터 어떻게 접근해야할지 몰랐기 때문에 우선 레디스를 모니터링하기로 했는데, 이미 사내에 구축한 모니터링 시스템(Exporter - Prometheus - Grafana)이 있기 때문에 이를 이용하기로 했다.">  </p><p>우선 모니터링하기 위해선 지표(Metric)을 수집해야한다.<br>그래서 가장 유명한 <a href="https://github.com/oliver006/redis_exporter" rel="external nofollow noopener noreferrer" target="_blank">Redis Exporter</a>를 찾아서 적용해보려고 했다.<br>해당 Exporter는 Redis의 <a href="https://redis.io/commands/INFO" rel="external nofollow noopener noreferrer" target="_blank">INFO</a> 커맨드의 출력 결과를 수집해서 <code>/metrics</code>라는 HTTP 엔드포인트로 노출하는 역할을 한다.<br>그럼 Prometheus에서 일정 주기마다 Pulling 해서 저장하고, 그 데이터를 기반으로 Grafana라는 대시보드를 통해 볼 수 있다.   </p><p>하지만 해당 Exporter는 <a href="https://github.com/oliver006/redis_exporter/issues/262" rel="external nofollow noopener noreferrer" target="_blank">Port를 옵션으로 받는 게 아니</a>라 <a href="https://github.com/oliver006/redis_exporter/blob/7a06cf8af9e28ad109018d067ff653edf08e664f/main.go#L46" rel="external nofollow noopener noreferrer" target="_blank">하드코딩</a> 돼있다.<br>Redis Exporter를 하나만 띄울 거라면 상관 없지만, 우리는 나중에 레디스 A도 업어와야하기 때문에 Redis Exporter를 하나 더 띄워야하는 경우였다.  </p><p><img src="/images/redis-monitoring/redis-exporter.png" alt=""><br>따라서 주객이 전도된 것 같지만 지표 수집을 위해서 기존에 Host OS에 띄워놓은 Redis를 Docker Container로 띄우고,<br>Redis Exporter도 Docker Container로 띄워서 각 컨테이너끼리 통신하게 끔 하였다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  admin-b-redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">redis:5.0.5-alpine</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">admin-b-redis</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">6380</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">  admin-b-redis-exporter:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">oliver006/redis_exporter:v1.0.0-alpine</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">admin-b-redis-exporter</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_ADDR=redis://admin-b-redis</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_EXPORTER_REDIS_ONLY_METRICS=true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9122</span><span class="string">:9121</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">on-failure</span></span><br></pre></td></tr></table></figure><p>또한 레디스 B 뿐만 아니라 기존 서버에서 레디스 A도 모니터링을 붙여놓았다.</p><p><img src="/images/redis-monitoring/legacy-monitoring.png" alt="레디스 A를 재시작 한 이후에 모니터링 해보니 점점 산으로 간다..."><br>레디스 A는 우리 사내에서 사용하는 어드민이 사용하는 레디스다.<br>계열사까지 합쳐도 전사 직원이 1,000명도 안 될텐데 생성된 키만 70,000개를 넘었다. (실제로 해당 어드민을 사용하는 유저는 100명도 안 되는데 말이다.)<br>이는 분명히 이상했지만, 명확하게 이렇게 생성된 원인을 파악할 수 없었다. (못난 나레기 ㅠㅠ…)  </p><p><img src="/images/redis-monitoring/legacy-monitoring-1-day.png" alt=""><br>우선 스프링 레디스 세션에 설정한 만료기간인 하루가 지나야 뭔가 볼 수 있을 것 같아 날이 밝기를 기다렸다.<br>그러자 위와 같이 그래프의 양상이 바뀌었다.  </p><p><img src="/images/redis-monitoring/expired-graph.png" alt="그래프의 양상이 바뀐 시점부터 분명 뭔가 만료는 되고 있고..."><br><img src="/images/redis-monitoring/command-call-graph.png" alt="하지만 주말 새벽 시간에도 꾸준히 뭔가 call이 일어나고 있다."></p><p>여기서 내린 추측은 <code>세션이 만료됨과 동시에 누군가 계속 세션을 생성해서 그래프가 현상유지가 되는 것</code>이라고 전제를 깔고 분석하기 시작했다.<br>그래서 우선 Nginx의 Access Log부터 까보기로 했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:32+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:35+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:40+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:50+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:00+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:02+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:05+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:10+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:20+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br></pre></td></tr></table></figure><p>ELB와 Consul은 Health Check Endpoint를 제대로 찌르고 있다.<br>하지만 <code>Go-http-client/1.1</code>라는 Agent는 계속해서 <code>/</code>을 찌르는데 이 때 바로 세션이 생성되는 것이다.<br>(추후에 <code>/login</code>으로 302 redirect 되지만 실제 세션 생성 시점은 그 이전이다.<br>비로그인 유저의 세션을 만드는 이유는 해당 세션을 가지고 동시 접속자 체크, 쇼핑몰 등등에서 비회원에게 장바구니 기능 제공 등등의 기능에서 사용이 가능하기 때문이다.<br>라고 <a href="https://www.facebook.com/groups/springkorea/permalink/1993894000722219/" rel="external nofollow noopener noreferrer" target="_blank">한국 스프링 사용자 모임에 질문</a>한 결과 알게 되었다.)  </p><p>내부 아이피를 직접 찌르고 있기 때문에 외부 크롤러나 봇에 의한 것이라는 전제는 일단 접어두었다. <del>(AWS 계정이 해킹당했을 거라는 끔찍한 상상은 하지 않았다.)</del><br>그리고 한 가지 든 의심이 서버의 헬스 체크를 해서 슬랙으로 알림을 주기 위해 사용한 <a href="https://github.com/prometheus/blackbox_exporter" rel="external nofollow noopener noreferrer" target="_blank">Blackbox Exporter</a>의 설정에 의해 Prometheus에서 위와 같이 헬스체크를 하는 게 아닐까 의심이 되었다.<br>그리고 <a href="https://github.com/prometheus/prometheus/issues/2440" rel="external nofollow noopener noreferrer" target="_blank">의심은 확신</a>으로 접어들기 시작했다.  </p><p>곧장 Prometheus에서 헬스 체크 엔드포인트를 어떻게 불러오는지 확인을 해보았다.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">  evaluation_interval:</span> <span class="number">1</span><span class="string">s</span></span><br></pre></td></tr></table></figure><p>내가 수집 주기를 <code>scrape_interval: 10s</code>로 설정해놨고, 아래는 172.12.1.189:80을 찌른 로그만 추려본 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br></pre></td></tr></table></figure><p>정확히 10초 주기로 172.12.1.189:80을 찔렀고, 점점 강한 확신으로 변해가고 있다.</p><p>Prometheus에서 Blackbox Exporter와 관련된 설정을 또 살펴보자.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'blackbox_exporter_http'</span></span><br><span class="line"><span class="attr">    metrics_path:</span> <span class="string">/probe</span></span><br><span class="line"><span class="attr">    params:</span></span><br><span class="line"><span class="attr">      module:</span> <span class="string">[http_2xx]</span></span><br><span class="line"><span class="attr">    consul_sd_configs:</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-001.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-002.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-003.dns:8500'</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__meta_consul_tags]</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">.*,blackbox_exporter_http,.*</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">keep</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__address__]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">__param_target</span> <span class="comment"># 여기가 중요</span></span><br><span class="line"><span class="attr">      - target_label:</span> <span class="string">'__address__'</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">'blackbox-exporter:9115'</span></span><br></pre></td></tr></table></figure><p>유동적으로 늘어나고 줄어드는 인스턴스에 대비하기 위해 consul을 사용하였다.<br>우선 consul에 등록된 태그 중에 <code>blackbox_exporter_http</code>란 값을 가지고 있는 서비스를 골라내고<br><code>__address__</code> 레이블에 설정된 값(<strong>ip:port</strong>)을 그대로 <code>__param_target</code>에 설정되는 것에서부터 문제가 시작됐다.<br>prometheus는 <code>__param_target</code>에 설정된 값을 토대로 헬스체크 한다는 것을 테스트를 통해 밝혔다.<br>이제는 완전한 확신을 했다.</p><p>우선 consul client가 설치된 어드민 A서버로 가서 consul에 어떤 service들을 등록하게 했는지 설정부터 살펴보았다.  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"services"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Nginx"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">80</span>,</span><br><span class="line">      <span class="attr">"check"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"Nginx Health Check"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Nginx Status"</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"http://localhost/health"</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8080"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8080</span>,</span><br><span class="line">      <span class="attr">"check"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"Server:8080 Health Check"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Server:8080 Status"</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"http://localhost:8080/health"</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8081"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8081</span>,</span><br><span class="line">      <span class="attr">"check"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"Server:8081 Health Check"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Server:8081 Status"</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"http://localhost:8081/health"</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또한 이제 보니 Nginx 말고 8080 및 8081 포트까지 찌르게 되어있었다.<br>(우리는 내부적으로 빠른 롤백을 위해 한 서버 인스턴스에 두 개의 어플리케이션 서버를 띄운 후 Nginx Upstream Server를 바꾸는 Blue/Green Deployment 전략을 사용 중이다.)<br>8080/8081 포트는 Nginx를 타지 않고 직접 프라이빗 IP를 찌르기 때문에 Access Log에 남지는 않았지만 세션도 생성됐을거라고 추측된다.  </p><p>우선 Prometheus에게 health check endpoint를 넘길 수 있게 끔 수정해야된다.  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"services"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Nginx"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">80</span>,</span><br><span class="line">      <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"health_check_endpoint"</span>: <span class="string">"health"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8080"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8080</span>,</span><br><span class="line">      <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"health_check_endpoint"</span>: <span class="string">"health"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"Server:8081"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"b2b-admin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"blackbox_exporter_http"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">8081</span>,</span><br><span class="line">      <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"health_check_endpoint"</span>: <span class="string">"health"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>meta.health_check_endpoint</code>를 사용하게 끔 Prometheus 설정 파일도 바꿔주자.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'blackbox_exporter_http'</span></span><br><span class="line"><span class="attr">    metrics_path:</span> <span class="string">/probe</span></span><br><span class="line"><span class="attr">    params:</span></span><br><span class="line"><span class="attr">      module:</span> <span class="string">[http_2xx]</span></span><br><span class="line"><span class="attr">    consul_sd_configs:</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-001.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-002.dns:8500'</span></span><br><span class="line"><span class="attr">      - server:</span> <span class="string">'http://consul-server-003.dns:8500'</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__meta_consul_tags]</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">.*,blackbox_exporter_http,.*</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">keep</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__address__,</span> <span class="string">__meta_consul_service_metadata_health_check_endpoint]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">__param_target</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">'(.*)(\/*);(.*)'</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">'$1/$3'</span></span><br><span class="line"><span class="attr">      - target_label:</span> <span class="string">'__address__'</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">'blackbox-exporter:9115'</span></span><br></pre></td></tr></table></figure><p>위와 같이 이제 설정을 바꾼 후 다시 Nginx의 Access log를 뒤져보았다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:57:52+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:57:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:02+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.000&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:12+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:15+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:19+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.005&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:22+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.003&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:32+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;</span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.003&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>Go-http-client/1.1</code>라는 Agent도 <code>/health</code>을 찌르기 시작했다.<br>그 이후에 이제 레디스 A를 모니터링 해봤다.  </p><p><img src="/images/redis-monitoring/legacy-monitoring-2.png" alt="그래프가 쭉쭉 떨어지는 걸 봐서 잘 해결된 것 같다."></p><h2 id="진짜-진짜로-죽은-이유"><a href="#진짜-진짜로-죽은-이유" class="headerlink" title="진짜 진짜로 죽은 이유"></a>진짜 진짜로 죽은 이유</h2><p>레디스 A와 같이 그래프가 현상유지만 됐으면 별 문제가 되지 않는다.<br>램은 1GB이지만, 실제로 사용량은 100MB도 되지 않았으므로 전혀 문제될 게 없다.<br>문제는 레디스 A가 아닌 레디스 B였다.<br>레디스 B는 어드민 B(외부에서 사용하는 어드민)이 사용하는 레디스이다.<br>해당 프로젝트는 세션의 만료기간을 Integer.MAX_VALUE(2³¹ − 1 = 2,147,483,647)로 잡아놓았다.<br>나는 해당 프로젝트의 개발에 참여하지 않아 잘 모르겠는데 아마 외부에서 사용하는 사람들이라면 매번 로그인하는 걸 번거롭게 생각해서 직접 요구사항이 들어오지 않았을까 싶다.<br><img src="/images/redis-monitoring/integer_max_value_to_year.png" alt="무려 68년동안이나 세션이 유지된다.">  </p><p>거의 평생동안 쓰레기 세션이 만들어진 채로 계속 유지가 된 거다.<br><img src="/images/redis-monitoring/forever-session-monitoring.png" alt="그 결과 500mb가 넘는 쓰레기 세션들이 만들어지고 있었다."><br>1GB 장비에서 500mb가 넘는 메모리는 엄청난 장애를 동반할 수 있다.<br>계속 유지되다가 버티지 못하고 레디스가 뻗고, 해당 레디스를 사용하는 서버도 뻗고, 다른 레디스 및 서버에도 영향을 미친 것으로 보인다.  </p><p><img src="/images/redis-monitoring/forever-session-garbage.png" alt=""><br>헬스 체크 엔드포인트를 변경한 이후에는 새로운 세션은 거의 만들어지지 않고 계속 현상 유지만 된 것이다.<br>500MB가 넘는 쓰레기 세션을 68년이 넘는 시간동안이나 끌고 가야하는 문제에 직면하게 되었다.<br>일단 로그인이 풀리겠지만 쓰레기 세션이 너무 많은 관계로 한 번 털고 가고(레디스 재시작), 세션의 만료기간도 좀 줄이기로 하였다.   </p><p><img src="/images/redis-monitoring/after-garbage-collection.png" alt=""><br>쓰레기 세션을 한 번 털고 나니 메모리 사용량이 확 줄어들었다.  </p><h2 id="이후-상황"><a href="#이후-상황" class="headerlink" title="이후 상황"></a>이후 상황</h2><p><img src="/images/redis-monitoring/admin-a-30-days.png" alt="어드민 A(세션 유지기가 1일)100MB를 치던 키가 쭉쭉 떨어지는 걸 볼 수 있다."><br>재밌는 건 중간에 줄어들다가 현상유지되는 구간이다.<br>이 구간은 내 실수로 두 대의 서버가 떠있는데 한 대의 서버의 헬스 체크 엔드포인트만 수정하고, 나머지 한대는 제대로 수정하지 않아서 현상 유지가 되었다.<br>(Consul 클라이언트 프로세스를 죽이고 다시 띄웠는데도 Consul 서버에서는 해당 노드와 서비스들이 좀비처럼 살아있었다 ㅠㅠ…)<br><img src="/images/redis-monitoring/admin-a-24-hours.png" alt="지금은 뭐 피크 타임 때도 2메가 쓸까 말까이다."><br><img src="/images/redis-monitoring/admin-b-30-days.png" alt="어드민 B(세션 유지기간 68년)의 경우에는 너무 쓰레기 세션이 많아서 한 번 털고 갔다."><br><img src="/images/redis-monitoring/admin-b-24-hours.png" alt="얘는 피크 때 그나마 6~7메가 정도를 쓰고 있다.">  </p><p>솔직히 말해서 스케일 아웃은 괜히했고, 애초에 로그인 세션만 사용하는데 비정상적으로 키가 많이 생성되고 용량 차지를 많이하는 것부터가 이상했다.<br>다음부터는 좀 더 조심히 일하고 현상 파악을 해야겠다. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/redis-monitoring/thumb.png&quot; alt=&quot;점점 산으로 가는 그래프...&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;사건의-발단&quot;&gt;&lt;a href=&quot;#사건의-발단&quot; class=&quot;headerlink&quot; title=&quot;사건의 발단&quot;&gt;&lt;/a&gt;사건의 발단&lt;/h2&gt;&lt;p&gt;사내에서 사용하는 어드민(이하 &lt;strong&gt;어드민 A&lt;/strong&gt;)/외부에서 사용하는 어드민(이하 &lt;strong&gt;어드민 B&lt;/strong&gt;)이 사망하는 사례가 속출하였다.&lt;br&gt;그 시점은 내가 새롭게 서버를 옮긴 이후부터 발생했다.&lt;br&gt;내가 서버를 옮긴 것과 이 일이 관련이 없다고 생각했지만,&lt;br&gt;우선 내가 서버를 옮긴 이후에 발생한 사건이기도 해서 부검을 통해 사인을 밝혀내는 게 우선이었다.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="Redis" scheme="https://perfectacle.github.io/tags/Redis/"/>
    
      <category term="Monitoring" scheme="https://perfectacle.github.io/tags/Monitoring/"/>
    
  </entry>
  
  <entry>
    <title>(JVM) Garbage Collection Advanced</title>
    <link href="https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/"/>
    <id>https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/</id>
    <published>2019-05-11T07:05:47.000Z</published>
    <updated>2019-08-23T02:33:39.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jvm-gc-advanced/thumb.jpeg" alt="출처: https://medium.com/@iacomini.riccardo/hadoop-namenode-garbage-collector-tuning-7f6a029e9012"></p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p><img src="/images/jvm-gc-advanced/optimizing-java.jpeg" alt=""><br>이 글은 이일웅 님께서 번역하신 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14796595" rel="external nofollow noopener noreferrer" target="_blank">자바 최적화</a>란 책을 읽던 도중 공부한 내용을 정리한 글입니다.<br>절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.<br>이 글을 읽어보시기 전에 <a href="/2019/05/07/jvm-gc-basic/">Garbage Collection Basic</a> 편을 읽어보시면 더 도움이 될 것입니다 :) </p><a id="more"></a><h2 id="Mark-and-Sweep-Algorithm"><a href="#Mark-and-Sweep-Algorithm" class="headerlink" title="Mark and Sweep Algorithm"></a>Mark and Sweep Algorithm</h2><p>Basic 편에서는 간단하게 Young/Old Generation과 Mark and Sweep 알고리듬에 대해서 간단하게 알아보았다.<br>해당 알고리듬을 사용하는 GC를 <strong>scavenge garbage collector</strong>라고도 부른다.<br>Mark and Sweep Algorith의 단점은 GC를 수행하는 동안 Stop the World(이하 STW)가 발생한다는 것이다.<br><img src="/images/jvm-gc-advanced/stop-the-world.png" alt="출처: https://www.youtube.com/watch?v=_cNXjmuhCCc"> </p><p>그럼 이제 해당 알고리듬을 사용하는 GC 알고리듬에는 뭐가 있는지 알아보자.</p><h3 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h3><p><strong>프로덕션에서 절대 사용하면 안 되는 GC이다.</strong> (싱글 코어 CPU를 사용하는 서버를 제외하고… <del>설마 아직도??</del>)<br>CPU 코어를 한 개만 사용하기 때문에, 해당 GC는 싱글 코어 환경에서만 적합하다. (쓰레드 간의 컨텍스트 스위칭도 적기 때문에…)<br>Young/Old Generation 모두 Mark and Sweep 알고리듬을 사용하여 GC를 수행한다.<br>Young Generation에서는 gc 수행 시간을 줄이고자 memory compaction을 수행하지 않고 survivor 영역을 전전긍긍하다 Old Generation으로 승진시켜버린다.<br>Old Generation은 survivor 영역처럼 별도의 메모리 영역이 없다보니 memory compaction도 하고, 메모리 사이즈도 크다보니 수행 시간이 길다. (그만큼 STW도 길다…)</p><p>-XX:+UseSerialGC 파라미터를 주고 실행하면 적용된다.</p><h3 id="ParallelGC-Young-ParallelOldGC-Old"><a href="#ParallelGC-Young-ParallelOldGC-Old" class="headerlink" title="ParallelGC(Young) / ParallelOldGC(Old)"></a>ParallelGC(Young) / ParallelOldGC(Old)</h3><p>Java 7<del>8의 기본 GC이며 <a href="#Serial-GC">Serial GC</a>의 멀티 코어 판이다.<br>‘Serial GC에서 하던 걸 다수의 코어(및 쓰레드)가 하다보니 더 빠르게 수행하겠구나</del>‘정도로 받아들이고 있다.</p><p>둘은 쌍쌍바 같은 녀석이라 -XX:+UseParallelGC 파라미터를 주면 자동으로 -XX:+UseParallelOldGC 파라미터가 활성화되고,<br>-XX:+UseParallelOldGC 파라미터를 주면 자동으로 -XX:+UseParallelGC 파라미터가 활성화된다.</p><h2 id="Tri-color-Marking-Algorithm"><a href="#Tri-color-Marking-Algorithm" class="headerlink" title="Tri-color Marking Algorithm"></a>Tri-color Marking Algorithm</h2><p>Tri-color Abstraction으로도 불리는 것 같으며 ‘자바 최적화’란 책에서는 ‘삼색 마킹 알고리즘’이라고 번역하였다.<br>Tri라는 접두사는 숫자 3을 의미하며, 총 3가지 색을 써서 마킹하는 알고리듬을 뜻한다.<br><a href="/2019/05/07/jvm-gc-basic/#Mark-and-Sweep-Algorithm">Mark and Sweep Algorithm</a>에서는 2가지 색(마킹되었거나, 마킹되지 않았거나)을 쓴 것과 차이점을 지닌다.<br>이 알고리듬은 동시성 알고리듬과 GC의 정확성을 증명했다는데, 즉 어플리케이션이 멈추지 않으면서 GC를 <strong>동시</strong>에 <strong>정확</strong>하게 쓰기 위해 나온 알고리듬 같다.  </p><p>먼저 알고리듬을 알아보기 전에 각각의 색에는 무엇이 있고, 어떤 역할을 하는지 알아보자.  </p><ol><li>회색(Grey)<br>해당 객체가 참조하고 있는 객체를 식별하지 않은, 즉 처리가 되지 않은 객체</li><li>검은색(Black)<br>해당 객체가 참조하고 있는 객체를 모두 식별한, 즉 모든 처리를 끝마친 객체</li><li>흰색(White)<br>해당 객체를 참조하고 있는 객체가 아무런 객체도 없는 객체, 수집 대상이 되는 객체</li></ol><p><img src="/images/jvm-gc-advanced/tri-color-marking-01.png" alt="Stack과 같은 GC Root(외부에서 힙 메모리에 대한 레퍼런스를 갖고 있는 메모리 풀?)에 있는 객체를 전부 회색으로 표시한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-02.png" alt="마킹 스레드가 회색 객체를 랜덤하게 돌아다니면서 해당 회색 객체가 참조하고 있는 객체를 전부 회색으로 마킹한 후 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-03.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으니 자신을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-04.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으므로 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-05.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으므로 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-06.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체는 회색으로 마킹하고 본인은 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-07.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체는 회색으로 마킹하고 본인은 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-08.png" alt="또 마킹 스레드가 랜덤하게 회색 객체를 돌아다니다가 참조하고 있는 객체가 없음을 확인했으므로 본인을 검은색으로 마킹한다."><br><img src="/images/jvm-gc-advanced/tri-color-marking-09.png" alt="회색 객체가 없을 때까지 위 작업을 반복하고 흰색 객체를 전부 수거해간다.">  </p><h3 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h3><p>Mark and Sweep Algorithm과 달리 Tri-color Marking Algorithm은 어플리케이션과 동시에 수행된다.<br>따라서 마킹하는 도중에 어플리케이션 스레드(책에선 Mutator라고 표기)에서 수정 사항이 반영되기 때문에 라이브 객체가 수집되는 현상이 발생될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aInstance.setSomeField(cInstance);</span><br></pre></td></tr></table></figure><p><img src="/images/jvm-gc-advanced/tri-color-marking-issue-01.png" alt="A라는 객체는 검은색으로 마킹돼있기 때문에 참조하는 객체에 대한 처리가 모두 끝난 객체이다.">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aInstance.setSomeField(cInstance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// blah blah...</span></span><br><span class="line"></span><br><span class="line">aInstance.setSomeField(bInstance);</span><br></pre></td></tr></table></figure><p><img src="/images/jvm-gc-advanced/tri-color-marking-issue-02.png" alt="A가 C에서 B를 바라보게 끔 변경되었다."><br>여기서 두 가지 문제점이 발생한다.  </p><ol><li>A는 검은색 객체로 모든 작업이 끝난 객체다.<br>또한 B는 흰색으로 마킹돼있다, 즉 수집의 대상이다.<br>라이브 객체를 수집하기 때문에 추후에 NPE(NullPointerException)이 발생할 가능성이 존재한다.</li><li>C는 회색 객체로 마킹돼있고, 나중에 검은색 객체로 바뀐다.<br>즉, C는 GC 루트로부터 아무도 참조하지 않는 객체가 된 죽은 객체인데도 불구하고 흰색으로 마킹되지 않는다.<br>따라서 수집 대상이 되지 않기 때문에 메모리 릭을 유발할 수 있다. (물론 다음 GC에서 수거해가겠지만…)<br>이렇게 아무도 참조하고 있지 않은데 혼자 남아있는 객체를 부유 가비지(Floating Garbage)라고 부른다.</li></ol><p>위와 같은 경우에는 애플리케이션 스레드가 객체를 변경했을 때 재마킹하게 끔하거나,<br>알고리듬을 깨버릴만한 모든 변경 사항을 큐 형태로 넣어놓고 GC의 main phase가 끝난 다음에 fixup phase에서 바로 잡는 방법 등등이 존재한다. </p><h3 id="CMS-Concurrent-Mark-Sweep-GC"><a href="#CMS-Concurrent-Mark-Sweep-GC" class="headerlink" title="CMS(Concurrent Mark Sweep) GC"></a>CMS(Concurrent Mark Sweep) GC</h3><p>CMS GC는 Tri-color Marking Algorithm을 사용하기 때문에 GC와 함께 어플리케이션을 돌릴 수 있다.<br>그렇다고 해서 아예 STW가 없는 건 아닌데 Parallel(Old)GC에 비하면 훨씬 짧다.<br>즉, 레이턴시에 엄청 민감한 경우에 적합한 GC라고 볼 수 있다.<br>절반은 GC 돌리고, 절반은 어플리케이션 스레드를 돌리는 것이다. (물론 평상시에는 100% 어플리케이션이 쓰겠지만…)<br>CMS GC는 Old Generation 전용 GC이고, 해당 GC를 사용하면 자동적으로 Young Generation 전용으로 ParNewGC를 사용한다.<br>(Java 8에서 -XX:+UseConcMarkSweepGC -XX:-UseParNewGC 이 조합이 Deprecate 되었다.<br>그냥 -XX:+UseConcMarkSweepGC만 사용하면 된다.)<br>ParNewGC에 대해선 좀 이따 간단히 설명하겠다.</p><p>CMS GC의 장점은 아래와 같다.</p><ol><li>어플리케이션 스레드가 오랫동안 멈추지 않는다. (짧게 짧게 쪼개서 멈춘다.)  </li></ol><p>CMS GC의 단점은 아래와 같다.  </p><ol><li>GC 풀 사이클 자체는 Parallel(Old)GC 보다 길다.  </li><li>GC가 도는 도중에는 어플리케이션 스레드가 절반만 돌기 때문에 처리율이 감소한다. </li><li>Mark and Sweep 알고리듬에 비해 하는 일도 많고 복잡하다보니 메모리, CPU를 더 많이 쓴다.  </li><li>CMS GC는 Old Generation의 메모리 Compaction을 수행하지 않으므로 단편화가 발생한다.</li></ol><p>역시 은총알은 없는 것 같다… ㅠㅠ</p><p>CMS GC는 어플리케이션 쓰레드와 같이 돌기 때문에 좀 복잡하게 동작한다.  </p><ol><li><p>초기 마킹(Initial Mark, <strong>STW 발생</strong>)<br><img src="/images/jvm-gc-advanced/cms-01.png" alt="GC Root나 Young Generation에서 참조하는 객체를 회색으로 마킹한다."><br>이렇게 마킹해놓으면 마킹 단계에서 다른 메모리 영역은 신경쓰지 않고 하나의 GC 풀에만 신경쓰면 된다.  </p></li><li><p>동시 마킹(Concurrent Mark)<br><img src="/images/jvm-gc-advanced/cms-02.png" alt="마킹 쓰레드와 어플리케이션 쓰레드가 동시에 돌기 때문에 객체 참조 간에 변경 사항이 발생한다.">  </p></li><li><p>동시 사전 정리(Concurrent Preclean)<br><img src="/images/jvm-gc-advanced/cms-03.png" alt="Old Generation 영역을 일정 공간으로 나누어 Card라 불리는 곳에 저장한다."><br>그리고 Initial Mark 이후에 참조 간에 변경이 생긴 곳을 Dirty Card라고 부른다.<br>자세한 내용은 <a href="http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html" rel="external nofollow noopener noreferrer" target="_blank">The JVM Write Barrier - Card Marking</a>을 참고하자.<br><img src="/images/jvm-gc-advanced/cms-04.png" alt="사전 정리를 해야 Dirty Card에서 일반 Card가 될 수 있다."><br>이 phase의 목적은 5단계(재마크, Final Remark) 시에 STW 시간을 줄이기 위함이다.</p></li><li><p>Abort 가능한 동시 사전 정리(Concurrent Abortable Precelan)<br>이 phase의 목적 역시 5단계(재마크, Final Remark) 시에 STW 시간을 줄이기 위함이다.<br>해당 phase는 이름부터 Abortable이 들어가기 때문에 아래와 같은 조건 의해 Abort 될 수 있다.<br>반복 횟수를 넘거나, 정해진 시간을 초과하거나, 사전 정리가 효과적으로 이루어졌거나 등등… (JVM 옵션으로 설정 가능한 것들도 있다.)  </p></li><li><p>재마크 (Final Remark, <strong>STW 발생</strong>)<br><img src="/images/jvm-gc-advanced/cms-05.png" alt="Old Generation의 모든 live object를 마킹한다.">  </p></li><li><p>동시 쓸어담기 (Concurrent Sweep)<br><img src="/images/jvm-gc-advanced/cms-06.png" alt="어플리케이션 스레드가 돌아감과 동시에 하얀색으로 마킹된 오브젝트를 전부 수거해간다.">  </p></li><li><p>동시 리셋 (Concurrent Reset)<br><img src="/images/jvm-gc-advanced/cms-07.png" alt="어플리케이션 스레드가 돌아감과 동시에 마킹했던 내용들을 리셋한다."></p></li></ol><h4 id="CMF-Concurrent-Mode-Failure"><a href="#CMF-Concurrent-Mode-Failure" class="headerlink" title="CMF(Concurrent Mode Failure)"></a>CMF(Concurrent Mode Failure)</h4><p>ParallelOldGC는 긴 STW를 가지는 대신에 CMS는 짧은 두 번의 STW만 있으므로 지연이 매우 적다.  </p><p>하지만 Old Generation을 GC하고 있는 와중에 동시에 Eden 영역도 차게 되는데, 이러다 Eden 영역이 꽉찬 경우에는 어떻게 될까?<br>Young Generation을 GC해야하는데 ParNewGC도 STW를 유발하는데 쓰레드 절반은 Minor GC, 쓰레드 절반은 Major GC를 수행하고 있기 때문에 Minor GC는 ParallelGC 보다 느리다.<br>또한 Minor GC 이후에 적당한 나이를 먹은 객체는 Old Generation으로 <a href="/2019/05/07/jvm-gc-basic/#Promotion">승진</a>시켜야하는데,<br>CMS GC는 메모리 컴팩션을 하지 않기 때문에 메모리 단편화가 발생하기 때문에 ParallelGC 보다 더 적은 객체를 Old Generation으로 승진시킨다.<br>(-XX:InitialTenuringThreshold와 -XX:MaxTenuringThreshold의 기본 값을 좀 높여서 사용하는 걸까…?)<br>또한 Old Generation으로 승진시킴과 동시에 Old Generation은 아직 GC 중이기도 하고해서 좀 더 긴밀한 조정을 하게되는데 이것도 ParNewGC와 ParallelGC와의 차이점이다.</p><p>또한 객체의 할당률이 급증해서 <a href="/2019/05/07/jvm-gc-basic/#Premature-Promotion">조기 승진</a>이 일어나기도 하고,<br>급기야 승진한 객체가 너무 많은 경우에는 Old Generation 조차 꽉차는 경우가 존재한다. (단편화로 인해 연속된 메모리 공간을 확보하지 못하는 것도 한 몫 한다.)<br>이런 경우에는 어쩔 수 없이 CMS GC에서 ParallelOldGC로 바뀌게 되고, STW가 발생한다.</p><p>CMF가 발생하지 않게 하려면, Old Generation이 꽉 차기 전에 얼른얼른 GC를 수행해야하는데<br>-XX:CMSInitiatingOccupancyFraction 파라미터로 정할 수 있고 기본값은 75이다. (Old Generation의 75%가 차면 GC 시작)</p><p>CMS는 내부적으로 사용 가능한 빈 공간을 ‘프리 리스트’라는 걸 통해 관리한다.<br>Concurrent Sweep 단계에서 Sweeper 쓰레드는 다음의 일을 한다.  </p><ol><li>여유 공간을 더 큰 덩어리로 만든다.  </li><li>단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉친다.</li></ol><p>하지만 Sweeper는 어플리케이션 쓰레드와 동시에 작동하므로 쓰레드가 적절히 동기화되지 않는 한 새로 할당된 블록이 잘못 수집될 가능성이 존재한다.<br>따라서 Sweeper 쓰레드는 프리 리스트를 잠근 후에 작업한다.</p><h3 id="G1-GC-Garbage-First-GC"><a href="#G1-GC-Garbage-First-GC" class="headerlink" title="G1 GC(Garbage First GC)"></a>G1 GC(Garbage First GC)</h3><p>G1 GC는 자바 6에 실험적으로 등장하여 자바 8u40 이후부터 쓸만큼의 성능 및 안정성을 발휘하기 시작했고, <strong>자바 9부터 기본 GC</strong>로 채택됐다. (자바 12가 나온 현재도 기본 GC이다.)<br>G1 GC는 처음부터 CMS를 대체할 목적으로 설계되었는데 CMS GC를 사용중인데 아무런 문제가 없는데 성급하게 바꾸는 행위는 하지 않는 게 좋다.<br>굳이 바꾸지 않아도 바꾸는 건 안정성을 떨어뜨리는 행위이며 조금이라도 처리율을 높이고 싶어서 올리고 싶다면 충분한 테스트를 거친 이후에 하자.</p><p><img src="/images/jvm-gc-advanced/g1-gc-01.png" alt="G1 GC는 Young(Eden/Survivor) Generation 및 Old Generation이 존재하는데 각 Generation이 연속된 메모리 공간일 필요가 없다는 게 큰 차이점이다. (물론 힙 메모리 자체로 봤을 때는 각 Region은 연속된 메모리 공간에 할당된다.)"><br>즉, Survivor 영역도 기존에는 2개였는데 G1 GC에서는 그러한 개념도 사라졌다.<br>또한 거대한 객체(Humongous Object)를 저장하는 ‘거대 영역(Humongous Region)’이라는 특수한 영역도 존재한다.(Humongous Object는 Old Generation에 바로 할당된다.)<br>Humongous Object라고 식별하는 기준은 리전 사이즈의 50%를 넘는 객체면 된다.   </p><p>G1 GC는 처음부터 CMS를 대체할 목적으로 중단 시간이 짧은 수집기로 설계했기 때문에 아래와 같은 특징이 있다.    </p><ol><li>수십 GB 이상의 힙에서도 짧은 STW를 지향한다.  </li><li>객체 할당과 Old Generation으로 승진이 많은 경우에도 메모리 Compaction을 하기 때문에 CMS처럼 Full GC가 돌지 않는다.  </li><li>짧은 STW와 예측 가능한 STW 시간  </li></ol><p>-XX:MaxGCPauseMillis라는 옵션으로 지정할 수 있는데 100(ms) 이하로 지정하면 이를 어길 가능성이 크다고 한다.</p><ol><li>Java 10부터 Full GC 시에 Multi Thread로 작동한다. (<a href="https://bugs.openjdk.java.net/browse/JDK-8172890" rel="external nofollow noopener noreferrer" target="_blank">JEP 307: Parallel Full GC for G1</a>)<br>참고로 CMS GC는 Full GC 시에 Single Thread로 동작하는 것으로 알고 있는데, 지금은 고쳐졌는지 모르겠다.<br>애초에 CMS GC를 대체할 목적으로 G1 GC 개발에 몰두했을 거 같기 때문에 안 고쳤을 것 같다…</li></ol><p>G1 GC는 힙을 ‘영역(Region)’이라는 것으로 구성한다. (일단 힙크기는 4GiB라고 가정해보자.)<br>영역의 크기 = 힙크기 / 2048 =&gt; 4096 / 2048 = 2(MiB)<br>만약 딱 나누어떨어지지 않는다면 크기 값게 가장 가까운 수치로 반올림하여 계산한다.<br>영역의 크기는 1, 2, 4, 8, 16, 32 MiB 중에 정해진다.  </p><h4 id="Why-G1"><a href="#Why-G1" class="headerlink" title="Why G1?"></a>Why G1?</h4><p>이름이 왜 G1(Garbage First)일까?<br>G1 GC는 살아있는 객체를 마킹한 후에 리전 별로 얼만큼을 살려둬야하는지 알 수 있다. (생존률?)<br>그 다음 G1 GC는 리전 중에 모든 객체가 죽은 리전(유효한 객체가 없는 리전, 즉 <strong>Garbage</strong>만 있는 Region)부터 회수를 한다.<br>메모리 회수를 먼저 하면 빈 공간 확보를 더 빨리 할 수 있다.<br>빈 공간 확보를 더 빨리 한다는 건 조기 승격이나 급격히 할당률이 늘어나는 경우를 방지할 수 있다.<br>이렇게 되면 Old Generation이 비교적 한가해지게 된다.</p><p>다른 컬렉터들과 달리 G1 GC는 죽어있는 객체만 있는 Region(Garbage)을 처음에(First) 수거하기 때문에 이런 이름이 붙게 됐다.  </p><h4 id="G1-GC는-어떻게-대용량-힙에서-낮은-중단-시간을-가질-수-있게-되었을까"><a href="#G1-GC는-어떻게-대용량-힙에서-낮은-중단-시간을-가질-수-있게-되었을까" class="headerlink" title="G1 GC는 어떻게 대용량 힙에서 낮은 중단 시간을 가질 수 있게 되었을까?"></a>G1 GC는 어떻게 대용량 힙에서 낮은 중단 시간을 가질 수 있게 되었을까?</h4><p>힙 용량이 커지면 커질 수록 객체의 갯수가 많아지고, 객체의 갯수가 많아지면 GC 수행시간이 길어지고, 그러다보면 STW 시간도 당연히 늘어나게 된다.<br>근데 G1 GC는 어떻게 그렇게 빨리 대용량 힙을 GC할 수 있는 걸까??</p><ol><li>GC 시에 전체 Heap에 대해서 GC를 수행해도 되지 않는다.<br>GC 해야하는 Region만 GC를 하면 되기 때문이다.<br>이 GC 해야만하는 Region을 뒤질 때도 좀 더 특수한 기법을 쓴다.<br>바로 Region 별로 RSet(Remembered Set)을 두고, 이 RSet만 뒤져서 추적을 하면 되기 때문이다.<br>RSet에는 외부에서 힙 영역 내부를 참조하는 레퍼런스를 관리하기 위한 정보들이 저장돼있다.  </li><li>Old Generation Compaction을 하는데 전체 Old Generation 대해서 Compaction을 하지 않아도 된다.<br>해당 Region에 대해서만 Compaction을 하면된다.  </li><li>Garbage를 먼저 수집해간다.<br>이는 G1 GC의 이름의 유래에서도 설명했는데 빈 공간을 먼저 확보하기 때문에 메모리의 여유 공간이 확보가 많이 된다.<br>여유 공간이 확보가 빨리 빨리 되니 그만큼 GC 빈도도 줄어들게 되는 것이다.</li></ol><h4 id="Evacuation"><a href="#Evacuation" class="headerlink" title="Evacuation"></a>Evacuation</h4><p>Minor GC 이후에 Survivor Space로 객체를 옮기거나 Old Generation으로 객체를 옮겨야한다.<br>이 때 G1 GC는 해당 객체를 기존의 Region 혹은 새 Region에 복사후에 메모리를 compact시킨다.<br>마치 전쟁통에 <strong>피난(Evacuation)</strong>가는 느낌 때문인지 이러한 행위를 Evacuation이라고 부른다.</p><p>Major GC 시에도 마찬가지다.<br>Old Generation Region에 있는 생존 객체를 다른 리전으로 피난(Evacuation)시킨 후 해당 메모리를 Compact한다.<br>하지만 Old Generation의 특수한 리전인 Humongous Region에 대해서는 Evacuation이 발생하지 않는다.<br>그냥 해당 리전의 객체(Humongous Object)가 더 이상 참조하는 객체가 없어서 사망하셨으면 바로 회수해간다.</p><h4 id="G1-GC-Cycle"><a href="#G1-GC-Cycle" class="headerlink" title="G1 GC Cycle"></a>G1 GC Cycle</h4><p><img src="/images/jvm-gc-advanced/g1-gc-cycle.png" alt="출처: https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180"><br>위 그림은 알고리듬의 Phase 및 STW가 발생하는 걸 표현한 것이다.  </p><p>모든 원은 STW가 발생함을 나타낸 것이고, 그 크기에 따라 시간이 달라진다고 생각하면 될 것 같다.<br>파란원은 Minor GC가 진행함에 따라 STW가 발생하는 것이고,<br>주황원은 Major GC가 진행하면서 객체를 마킹하느라고 생기는 STW이고,<br>빨간원은 Mixed Collection(Minor/Major GC)을 진행함에 따라 STW가 발생하는 것이다.  </p><p>Young Only Phase는 이름에서 보듯이 Young Only (Garbage Collection) Phase라고 이해하면 될 것 같다.<br>여기서 Major GC가 일어나긴 하지만 마킹만 하는 단계고, 메모리를 회수해가는 단계는 아니기 때문이다.<br>파란원이 Minor GC 때문에 생긴 STW이다.<br>이렇게 평화롭게 Minor GC만 수행하다가 -XX:InitiatingHeapOccupancyPercent에 지정한 값을 초과하는 순간 Major GC도 시작한다.<br>Major GC의 첫단계는 Initial Mark이며 Minro GC와 동시에 수행되며 둘 다 STW를 수반한다. (따라서 다른 파란원보다 크기가 크다.)<br>그 이후에 어플리케이션 쓰레드, Minor GC, Concurrent Mark가 동시에 수행되는데 Remark가 수행되는 순간 다른 작업은 멈추게 된다.<br>그리고 주황색 원에서 보다싶이 Remark가 수행되면서 STW가 발생한다. (일반 파란원보다 긴 시간이 필요하다.)<br>그 이후에 또 짜잘하게 Minor GC가 수행되다가 주황색 원에서 보다싶이 Cleanup을 수행한다.  </p><p>이제 Young Only Phase가 끝나고 Space Reclamation(공간 회수) Phase가 시작된다.<br>Space Reclamation Phase는 이름에서 보다싶이 Young Only Phase에서 마킹한 리전(Space)의 메모리를 수집(Reclamation)하는 단계이다.<br>Space Reclamation Phase에서는 Mixed Collection(Minor/Major GC)이 수행되는데 이는 빨간원으로 표시했다.<br>Mark 단계가 없어서인지 Space Reclamation Phase에서는 STW 빈도가 훨씬 줄어든 모습을 볼 수 있다.</p><p>Space Reclamation Phase가 끝나면 다시 Young Only Phase로 돌아가서 Minor GC만 메모리를 수집하게 된다.<br>이렇게 G1 GC는 Young Only Phase와 Space Reclamation Phase를 번갈아 수행하는 싸이클을 갖고 있다.  </p><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p>이제부터는 각 GC 및 단계를 좀 더 면밀히 관찰해보자.<br>아래 나오는 모든 그림의 출처는 <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" rel="external nofollow noopener noreferrer" target="_blank">Getting Started with the G1 Garbage Collector - Oracle</a>이다.</p><h5 id="Minor-GC-Young-Generation"><a href="#Minor-GC-Young-Generation" class="headerlink" title="Minor GC (Young Generation)"></a>Minor GC (Young Generation)</h5><p>Minor GC는 기존 GC들과 크게 다르지 않다.<br>물론 멀티 쓰레드에서 병렬로 돌아간다.<br><img src="/images/jvm-gc-advanced/g1-gc-02.png" alt="연속되지 않은 메모리 공간에 Young Genration이 Region 단위로 메모리에 할당돼있다."><br><img src="/images/jvm-gc-advanced/g1-gc-03.png" alt="live object가 suvivor region이나 old generation으로 evacuation(피난, copy or move)된다."><br>이 단계에서 STW가 발생하고, Eden과 Survivor의 사이즈는 다음 Minor GC를 위해 재계산 된다.<br><img src="/images/jvm-gc-advanced/g1-gc-04.png" alt="Minor GC를 모두 마친 후의 모습이다.">  </p><h5 id="Major-GC-Old-Generation"><a href="#Major-GC-Old-Generation" class="headerlink" title="Major GC (Old Generation)"></a>Major GC (Old Generation)</h5><p><img src="/images/jvm-gc-advanced/g1-gc-05.png" alt="Initial Mark는 STW를 발생시킨다."><br>Initial Mark는 Survivor Region에서 Old Region을 참조하는 게 있는지 파악해서 Mark하는 단계이다.<br>Survivor Region에 의존적이기 때문에 Survivor Region은 깔끔한 상태여야하고,<br>Survivor Region이 깔끔하려면 Minor GC가 전부 끝난 상태여야한다.<br>따라서 Initial Mark가 Minor GC에 의존적이다.  </p><p><img src="/images/jvm-gc-advanced/g1-gc-06.png" alt="X 표시한 Region은 모든 객체가 사망한 Empty Region이다."><br>Concurrent Mark 단계에서는 Old Generation 내에 생존해있는 모든 객체를 마크하고 다닌다.<br>STW가 없기 때문에 어플리케이션 쓰레드와 동시에 돌고, 종종 Minor GC한테 인터럽트 당한다.  </p><p><img src="/images/jvm-gc-advanced/g1-gc-07.png" alt="Concurrent Mark에서 X 표시 친 Empty Region을 바로 회수해버린다."><br>Remark Phase 역시 STW를 수반한다.<br>또한 Concurrent Mark 단계에서 깔짝깔짝 마킹하던 걸 완전히 끝내버린다.<br>그리고 SATB(snapshot-at-the-beginning) 기법을 쓰기 때문에 CMS GC보다 더 빠르다.<br>여기서 SATB는 <code>수집 사이클을 시작할 때 접근 가능하거나 그 이후에 할당된 객체를 라이브 객체로 간주하는 기법</code>이다.</p><p><img src="/images/jvm-gc-advanced/g1-gc-08.png" alt="Old Generation에서도 evacuation(피난, 살아있는 객체를 copy or move)이 발생한다."><br>이 단계는 STW를 수반하지 않는다.<br>Remark에서 제일 수집하기 쉬운 Empty Region을 수집해갔으니 이제 그 다음으로 수집하기 쉬운 영역을 수집해갈 차례다.<br>Empty Region 다음으로 수집하기 쉬운 Region은 생존률이 제일 낮은 Region이고 생존률이 낮은 순으로 순차적으로 수거해가는 것이다.<br>먼저 해당 region을 피난(copy or move)시키고, 수집해간다.<br>G1 GC는 이렇게 Garbage의 수집을 우선(First)해서 계속해서 여유 공간을 신속하게 확보해둔다.  </p><p>또한 Cleanup 단계에서는 아래와 같은 일을 한다. </p><ul><li>Performs accounting on live objects and completely free regions. (STW 발생)<br>살아있는 객체와 완전히 비어있는 region을 계산함(번역이 맞는지 확인해주십시오 ㅠㅠ)</li><li>RSet을 정리(STW 발생)</li><li>빈 리전을 정리하고나서 Free List에 추가(Concurrent)</li></ul><p><img src="/images/jvm-gc-advanced/g1-gc-09.png" alt="Major GC 이후 깔끔하게 정리된 Old Generation의 모습이다."></p><h2 id="Epsilon-Collector"><a href="#Epsilon-Collector" class="headerlink" title="Epsilon Collector"></a>Epsilon Collector</h2><p>이 컬렉터는 GC를 전혀 수행하지 않는 컬렉터이다.<br>따라서 <strong>실서버 운영 환경에서는 절대 절대 쓰면 안된다.</strong>  </p><p>다음의 경우에 적합하다.  </p><ul><li>성능 테스트 전용<br>정확한 성능 테스트를 해야하는데 GC가 돌아감에 의해 영향을 미칠 수도 있기 때문에<br>이마저도 없앤 후에 성능 테스트를 하고 싶을 때 사용한다.<br><a href="https://openjdk.java.net/projects/code-tools/jmh/" rel="external nofollow noopener noreferrer" target="_blank">JMH</a>란 툴로 마이크로벤치마킹 할 때 이런 GC가 영향을 미치는 테스트도 있는 모양이다.</li><li>할당률이 낮거나 0인 자바 앱 등등<br>존재하기나 할까… 싶다.</li><li>회귀 테스트(정확히 뭔지 모르겠음)<br>변경된 코드 때문에 메모리 할당률이 급격히 달라지지 않았나 확인할 때 유용하다고 한다.</li></ul><p>혹시나 사용하고 싶다면 <code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code> 옵션을 주자.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>은총알은 없는 것 같습니다.<br>모든 GC에는 각자 장단점이 있으니 충분하고 검증된 테스트를 통해 본인의 상황에 맞는 GC를 고르는 역량을 길러야합니다. (이러고 작성자는 무조건 G1 GC를 디폴트로 쓰고 있습니다 ㅠㅠ)<br>또한 작성자의 역량 부족으로 인해 <a href="https://wiki.openjdk.java.net/display/zgc/Main" rel="external nofollow noopener noreferrer" target="_blank">Z GC</a>에 대해서는 다루지 못했습니다.<br>또한 Hotspot VM 계열의 GC만 다루었습니다. (제가 OpenJDK만 사용하고 있고, 다 다루기에는 이해하기도 힘들기도 하고 많기도 해서 ㅠㅠ…)<br>혹시나 다른 VM 계열의 GC(셰난도아(Shenandoah), C4, IBM J9)가 궁금하신 분은 이일웅 님께서 번역하신 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14796595" rel="external nofollow noopener noreferrer" target="_blank">자바 최적화</a>란 책을 참고하시면 좋을 것 같습니다.<br>다시 한 번 거듭 말씀드리지만 절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.</p><h2 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h2><ul><li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep" rel="external nofollow noopener noreferrer" target="_blank">Concurrent Mark and Sweep | Plumbr</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" rel="external nofollow noopener noreferrer" target="_blank">Concurrent Mark Sweep (CMS) Collector - Oracle</a>  </li><li><a href="https://d2.naver.com/helloworld/1329" rel="external nofollow noopener noreferrer" target="_blank">Java Garbage Collection - Naver D2</a>  </li><li><a href="https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99" rel="external nofollow noopener noreferrer" target="_blank">쓰레기 수집 (컴퓨터 과학) - 위키피디아</a></li><li><a href="http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html" rel="external nofollow noopener noreferrer" target="_blank">The JVM Write Barrier - Card Marking</a> </li><li><a href="https://docs.oracle.com/en/java/javase/12/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" rel="external nofollow noopener noreferrer" target="_blank">Java 12 HotSpot VM Options - Oracle</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573" rel="external nofollow noopener noreferrer" target="_blank">Java 12 Garbage-First Garbage Collector - Oracle</a>  </li><li><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" rel="external nofollow noopener noreferrer" target="_blank">Getting Started with the G1 Garbage Collector - Oracle</a>  </li><li><a href="https://imp51.tistory.com/entry/G1-GC-Garbage-First-Garbage-Collector-Tuning" rel="external nofollow noopener noreferrer" target="_blank">JVM 튜닝</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jvm-gc-advanced/thumb.jpeg&quot; alt=&quot;출처: https://medium.com/@iacomini.riccardo/hadoop-namenode-garbage-collector-tuning-7f6a029e9012&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/jvm-gc-advanced/optimizing-java.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;이 글은 이일웅 님께서 번역하신 &lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=14796595&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;자바 최적화&lt;/a&gt;란 책을 읽던 도중 공부한 내용을 정리한 글입니다.&lt;br&gt;절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.&lt;br&gt;이 글을 읽어보시기 전에 &lt;a href=&quot;/2019/05/07/jvm-gc-basic/&quot;&gt;Garbage Collection Basic&lt;/a&gt; 편을 읽어보시면 더 도움이 될 것입니다 :) &lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://perfectacle.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>(JVM) Garbage Collection Basic</title>
    <link href="https://perfectacle.github.io/2019/05/07/jvm-gc-basic/"/>
    <id>https://perfectacle.github.io/2019/05/07/jvm-gc-basic/</id>
    <published>2019-05-06T16:43:52.000Z</published>
    <updated>2019-08-23T02:31:19.354Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jvm-gc-basic/thumb.png" alt="PermGen은 자바 8에서 Metaspcae로 대체됐다. 이미지 출처: https://help.sap.com/">  </p><h2 id="읽기-전-주의사항-그림을-보는-법"><a href="#읽기-전-주의사항-그림을-보는-법" class="headerlink" title="읽기 전 주의사항(그림을 보는 법)"></a>읽기 전 주의사항(그림을 보는 법)</h2><p>그림을 그리다보니 Stack에 있는 동그라미 모양과 힙 메모리에 있는 동그라미 모양이 동일한 그림들이 많이 있습니다.<br>이건 <strong>둘이 동일한 메모리를 의미하는 게 아니라 그냥 스택에서 힙을 참조</strong>한다는 걸 그린 건데,<br>사실 둘의 모양을 다르게 그려야하는데 아무 생각없이 복붙해서 그리다보니 이렇게 그리게 되었고…<br>되돌리기에는 너무 많이 그림을 그려놔서(히스토리 추적이 안 되게 막 그려서…) 귀챠니즘으로 인해 그림을 수정하지 않았습니다.<br>이 점 참고하셔서 보시길 바랍니다!</p><a id="more"></a><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p><img src="/images/jvm-gc-basic/optimizing-java.jpeg" alt=""><br>이 글은 이일웅 님께서 번역하신 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14796595" rel="external nofollow noopener noreferrer" target="_blank">자바 최적화</a>란 책을 읽던 도중 공부한 내용을 정리한 글입니다.<br>절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다. </p><p>자바는 C언어와 달리 프로그래머가 일일이 쓰지 않는 메모리(가비지)를 회수할 필요가 없게 끔 가비지 컬렉터가 알아서 열일한다.<br>자바의 모든 가비지 컬렉션에는 Stop the World(어플리케이션 스레드를 모두 멈추기 때문에 어플리케이션이 멈추게 된다.)가 발생하고 GC 쓰레드만 열일하게 된다.<br><img src="/images/jvm-gc-basic/stop-the-world.png" alt="죠죠의 기묘한 모험이 떠오르는 건 왜일까... 출처: https://www.youtube.com/watch?v=_cNXjmuhCCc"><br>저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사상이 자바의 핵심이다.</p><blockquote><p>자바는 블루 컬러(주로 생산직에 종사하는 육체 노동자) 언어입니다.<br>  박사 학위 논문 주제가 아니라 일을 하려고 만든 언어죠.<br>  — 제임스 고슬링(자바의 아버지) —</p></blockquote><p>즉, 일일이 메모리 해제하는 걸 ‘박사 학위 논문 주제’ 급의 어려운 일이라고 자바에서 여기는 것이다.<br>이런 어려운 일은 우리가 할테니 너희는 일을 해라!(비즈니스 로직이나 짜라!) 이런 뉘앙스 같다.</p><p>GC는 아래 두 가지 원칙을 준수해야한다. (프로그래머가 일일이 메모리 해제하다간 이런 유형의 휴먼 에러가 발생한다는 걸 보여준다.)</p><ul><li>반드시 모든 가비지(쓰지 않는 메모리)를 수집(free)해야한다.<br>메모리만 엄~청 빵빵하다면 가비지가 많더라도 굳이 메모리 해제할 필요가 없다.<br>사실 GC도 메모리가 부족할 때만 수행한다.</li><li>살아있는 객체(접근 가능한 객체)는 절대로 수집해선 안 된다.<br>C언어에서는 살아있는 객체(접근 가능한 객체)를 해제하면 Dangling pointer가 만들어지고, 어플리케이션이 뻗거나 해당 메모리에 다른 데이터가 할당돼서 해당 데이터를 더럽히는 등의 버그가 발생하게 된다.<br>자바에서는 살아있는 객체를 수집해가면 나중에 참조하는 쪽에서 NPE(NullPointerException) 등등이 발생할 가능성이 높다.</li></ul><h2 id="Mark-and-Sweep-Algorithm"><a href="#Mark-and-Sweep-Algorithm" class="headerlink" title="Mark and Sweep Algorithm"></a>Mark and Sweep Algorithm</h2><p>자바의 GC 알고리듬의 기본은 Mark(살아있는 객체를 표시) and Sweep(쓸어담기) 알고리듬이다.</p><p><img src="/images/jvm-gc-basic/mark-and-sweep-01.png" alt="GC 루트(스택 프레임, 전역 객체 등등과 같이 메모리 풀 외부에서 내부를 가리키는 포인터)로부터 살아있는 객체(접근 가능한 객체)를 찾는다."><br><img src="/images/jvm-gc-basic/mark-and-sweep-02.png" alt="살아있는 객체를 찾으면 mark bit를 true(혹은 1)로 세팅한다."><br><img src="/images/jvm-gc-basic/mark-and-sweep-03.png" alt="모든 객체에 대해 마크가 끝났으면 이제 mark bit가 false(혹은 0)인 객체를 찾는다."><br><img src="/images/jvm-gc-basic/mark-and-sweep-04.png" alt="mark bit가 false(혹은 0)인 객체는 죽은 객체(접근 불가능한 객체)이므로 가비지 컬렉터가 수거해간다."></p><h2 id="Weak-Generational-가설"><a href="#Weak-Generational-가설" class="headerlink" title="Weak Generational 가설"></a>Weak Generational 가설</h2><blockquote><p>JVM 및 유사 소프트웨어에서 객체 수명은 이원적 분포 양상을 보인다.<br>대부분의 객체는 아주 짧은 시간만 살아있지만, 나머지 객체는 기대 수명이 훨씬 길다.</p></blockquote><p>이 법칙은 사람들이 실제 실험과 경험을 토대로 얻어냈다.<br>따라서 GC의 대상인 힙은 아래 두 가지가 핵심이라는 결론이 나왔다.</p><ul><li>젊은 객체를 빠르게 수집할 수 있도록 설계해야한다.</li><li>늙은 객체와 단명 객체를 떼어놓는 게 가장 좋다.</li></ul><p>Hotspot VM은 Weak Generational 가설을 활용해 아래와 같은 규칙을 만들었다.</p><ul><li>객체마다 generational count(객체가 지금까지 무사통과한 가비지 컬렉션 횟수)를 센다.</li><li>새로운 객체는 Young Generation이라는 공간에 생성된다.</li><li>장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역(Old Generation 또는 Tenured Generation)에 보관된다.</li></ul><p>또한 Weak Generational 가설 중에 <strong>‘늙은 객체가 젊은 객체를 참조할 일은 거의 없다.’</strong>는 내용도 있는데 아예 없는 건 아니므로<br>Hotspot VM에서는 카드 테이블(JVM이 관리하는 바이트 배열로 각 요소는 Old Generation 공간의 512 바이트 영역을 가리킨다.)이라는 자료구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록한다.<br>따라서 Young Generation의 GC가 수행될 때 늙은 객체가 젊은 객체를 참조하는지도 확인해봐야한다.<br>하지만 이 때는 늙은 객체를 전부 뒤져보는 게 아니라 카드 테이블만 뒤져보면 돼서 GC의 수행 속도를 높여준다.</p><p><img src="/images/jvm-gc-basic/c-01.png" alt="또한 메모리의 raw address를 가지고 데이터에 접근(역참조) 가능한 C언어 같은 언어는 이렇게 이분법적으로 메모리 영역을 나눈 구조와 맞지 않는다."><br><img src="/images/jvm-gc-basic/c-02.png" alt="Young Generation에서 Old Generation으로 이동한 데이터는 메모리의 raw address도 바뀔텐데, 해당 raw address로 역참조를 했을 때 메모리 재할당으로 인해 다른 값이 튀어나올 가능성이 높기 때문이다."><br>다행히 자바는 메모리의 raw address를 사용하지도 않고, offset 연산자(. 연산자)만으로 필드나 메서드에 액세스 할 수 있기 때문에 이런 문제로부터 자유롭다.</p><h2 id="Young-Generation"><a href="#Young-Generation" class="headerlink" title="Young Generation"></a>Young Generation</h2><p>Weak Generational 가설에 따라 단명하는 젊은 객체들만 모아놓은 공간이다.<br>대부분의 객체가 Young Generation에서 사망하시고, 새로 생성된 객체가 할당되기 때문에 GC가 자주 일어나는 영역이다.<br>GC가 일어나는 동안 Stop the World가 발생하는데 이 빈도가 매우 잦기 때문에 Young Generation의 GC는 수행 시간이 짧아야한다.<br>수행 시간이 짧으려면 수거해가는 객체의 수를 줄이면 되고, 객체의 수를 줄이려면 영역의 사이즈를 적당히 줄이면 된다.<br>수행 시간이 짧은 GC이기 때문에 Minor GC라고 부르는 게 아닐까?</p><p>Young Generation 사이즈를 지정하는 JVM flag는 -XX:NewSize와 -XX:MaxNewSize이며<br>-XX:NewRatio 속성을 통해 Old Generation 사이즈와 Young Generation 사이즈의 비율을 정할 수 있다.<br>예를 들어 -XX:NewRatio=3으로 지정하면 1:3=Young:Old 라고 보면 된다.<br>(Young은 힙 메모리의 1/4를 먹고, Old는 힙 메모리의 3/4를 먹게 되는 것이다.)  </p><blockquote><p>The parameters NewSize and MaxNewSize bound the young generation size from below and above.<br>Setting these to the same value fixes the young generation,<br>just as setting -Xms and -Xmx to the same value fixes the total heap size.<br>This is useful for tuning the young generation at a finer granularity than the integral multiples allowed by NewRatio.<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html</a></p></blockquote><p>-XX:NewRatio 파라미터보다는 -XX:NewSize와 -XX:MaxNewSize의 사이즈를 동일하게 설정하는 게 튜닝하는데 더 좋다고 한다.<br>아마 동일하게 설정하는 이유는 해당 영역의 사이즈가 동적으로 줄어들고 늘어나게 되면, GC에도 영향을 미치고 기타 Ratio 관련 설정을 재계산해야되기 때문에 성능에 영향을 미치지 않기 때문 아닐까…?</p><p>또한 Young Generation의 GC는 자주 일어나기 때문에 수행 시간이 매우 짧아야하니 적어도 Old Generation의 사이즈보다 적게 할당하는 게 일반적이라고 한다.<br>다만 객체의 수명이 긴 객체들이 많거나 새로운 객체의 할당이 별로 없는 객체의 경우는 Young Generation의 사이즈를 좀 더 과감하게 줄이는 등 케이스 바이 케이스로 사이즈를 정해야할 것 같다.<br>이 모든 결정은 추측이 아닌 모니터링을 통해 할당 비율이라던지 기타 등등의 데이터들을 수치화해서 정확한 데이터 기반으로 의사 결정을 내려야할 것이다. <del>(말이 쉽지 ㅠㅠ 어떻게 하는지도 모른다…)</del></p><h3 id="Eden-Space"><a href="#Eden-Space" class="headerlink" title="Eden Space"></a>Eden Space</h3><p>Young Generation의 일부분이다.<br><img src="/images/jvm-gc-basic/eden-space-01.png" alt="새롭게 생성된 객체의 용량이 Eden Space의 용량보다 큰 경우를 제외하고는 Eden 영역에 할당된다."><br><img src="/images/jvm-gc-basic/eden-space-02.png" alt="그러다가 새롭게 할당할 객체의 메모리 확보를 하지 못한 경우, 즉 Eden 영역이 꽉 찬 경우에 Minor GC를 수행하게 된다."><br><img src="/images/jvm-gc-basic/eden-space-03.png" alt="이 때 GC를 수행하게 되면 메모리 단편화가 생기게 되고 이로 인해 객체를 할당할 전체적인 용량은 확보됐지만 연속된 메모리 공간이 없게 된다."><br>OS 레벨에서는 연속된 메모리 공간에 할당하지 않고 쪼개서 할당해도 되긴 하지만 할당하는 데도 오랜 시간이 걸리고, 데이터를 불러올 때도 순차적인 접근이 아니기 때문에 오래 걸리게 된다.<br>또한 JVM의 메모리 할당은 <a href="#알아두면-좋을-상식">알아두면 좋을 상식</a>에도 나오다시피 bump-the-pointer라는 기술을 써서 저렇게 중간에 메모리를 할당하는 일은 없다.<br><img src="/images/jvm-gc-basic/eden-space-04.png" alt="아니면 GC 이후에 메모리 Compaction을 수행해야하기 때문에 오버헤드가 발생할 수 밖에 없다.">  </p><h3 id="Survivor-Space"><a href="#Survivor-Space" class="headerlink" title="Survivor Space"></a>Survivor Space</h3><p>위에서 언급한 Eden 영역에서 GC로 인해 생기는 오버헤드를 줄이고자 생긴 영역이다.<br>이 영역 또한 Young Generaion의 일부이다.<br>Survivor 영역은 동일한 사이즈의 두 개의 영역으로 구분되는데 각각의 이름은 from과 to이다.<br>(VisualVM 같은 모니터링 툴에는 S0, S1으로 표시되곤 한다.)<br><img src="/images/jvm-gc-basic/survivor-space-01.png" alt="Eden 영역에서 생존한 객체들이 Survivor 영역의 연속된 메모리 공간으로 넘어오게 되고"><br><img src="/images/jvm-gc-basic/survivor-space-02.png" alt="Eden 영역은 싹 비우게 됨으로써 Eden 영역의 제일 처음부터 할당하면 되므로 Eden 영역의 메모리 단편화 문제를 해결했다.">  </p><p>또한 -XX:SurvivorRatio 속성을 통해 Eden Space 사이즈와 Survivor Generation 사이즈의 비율을 정할 수 있다.<br>예를 들어 -XX:SurvivorRatio=6으로 지정하면 1:6=Survivor:Eden 라고 보면 된다.<br>(Suivovr는 Young Generation의 1/7를 먹고, Eden은 Young Generation의 6/7를 먹게 되는 것이다.)<br>즉, 두 Survivor 영역의 합보다 Eden 영역의 메모리가 더 크다.<br>(생존해서 Survivor 영역에 존재하는 객체보다 새롭게 생성돼서 Eden 영역에 할당되는 객체가 훨씬 많으므로…)</p><blockquote><p>You can use the parameter SurvivorRatio can be used to tune the size of the survivor spaces, but this is often not important for performance.<br>  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html</a></p></blockquote><p>퍼포먼스에 영향을 주는 경우는 드물다고 적혀있지 않으니 굳이 쓸 필요는 없을 것 같다.</p><h4 id="Survivor-Space는-왜-2개일까"><a href="#Survivor-Space는-왜-2개일까" class="headerlink" title="Survivor Space는 왜 2개일까?"></a>Survivor Space는 왜 2개일까?</h4><p><img src="/images/jvm-gc-basic/survivor-space-03.png" alt="그 이유는 Minor GC의 대상이 Eden에만 국한되는 게 아니라 Survivor 영역까지 Minor GC를 하기 때문이다."><br><img src="/images/jvm-gc-basic/survivor-space-04.png" alt="Survivor 영역을 Minor GC를 수행하면 어떻게 될까? Eden 영역만 존재할 때와 마찬가지로 Survivor 영역에도 메모리 단편화가 존재하게 된다.">  </p><p><a href="#알아두면-좋을-상식">알아두면 좋을 상식</a>에도 나오다시피 bump-the-pointer라는 기술을 써서 중간에 빈 공간이 있더라도 해당 공간에 할당하지 않는다.<br>그럼 Survivor Space의 단편화를 없애려면 어떻게 하면 될까?<br><img src="/images/jvm-gc-basic/survivor-space-05.png" alt="Eden 영역에서 Survivor 영역을 만든 것과 같이 새로운 영역을 추가하면 된다!"><br>따라서 새롭게 영역을 추가하다보니 Survivor Space가 두 개가 된 거다.</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>그럼 이제 Young Generation에서 일어나는 Minor GC에 대해서 알아보자.<br>(물론 JVM 플래그를 어떻게 주느냐에 따라서 Minor GC의 알고리듬이 달라질 수 있고, 여기서 설명하는 Minor GC의 알고리듬은 아주 간단하고 기본적인 수준에서 설명하고 있다.)</p><p><img src="/images/jvm-gc-basic/minor-gc-01.png" alt="새롭게 생성된 객체는 전부 Eden Space에 할당된다. 이 때 객체의 generational count는 0이다."><br><img src="/images/jvm-gc-basic/minor-gc-02.png" alt="새롭게 생성된 객체를 또 할당하려는데 Eden Space에 할당할 공간이 없으면 Minor GC를 수행하게 된다. 이제부터 Stop the World의 시작이다."><br><img src="/images/jvm-gc-basic/minor-gc-03.png" alt="Eden 영역에 할당된 객체를 순회하면서 GC 루트로부터 접근 가능한 객체만 mark를 한다."><br><img src="/images/jvm-gc-basic/minor-gc-04.png" alt="생존한 모든 객체(mark 당한 객체)는 Survivor Space로 복사한다."><br><img src="/images/jvm-gc-basic/minor-gc-05.png" alt="GC로부터 살아남은 객체는 이제 generational count가 1로 증가한다. (이렇게 generational count를 1씩 늘리는 프로세스를 aging이라고 부른다... 나이를 먹어가는 ㅠㅠ)"><br><img src="/images/jvm-gc-basic/minor-gc-06.png" alt="Eden Space를 비운다. (Sweep) 이제 Stop the World가 끝났다."><br><img src="/images/jvm-gc-basic/minor-gc-07.png" alt="이제 Eden Space의 공간 확보가 됐으니 새롭게 생성된 객체를 Eden Space에 할당한다."><br><img src="/images/jvm-gc-basic/minor-gc-08.png" alt="새롭게 생성된 객체를 또 할당하려는데 Eden Space에 할당할 공간이 없으면 Minor GC를 수행하게 된다. (Stop the World의 시작)"><br><img src="/images/jvm-gc-basic/minor-gc-09.png" alt="이번에는 Eden 영역과 더불어 Survivor Space에 할당된 객체를 순회하면서 GC 루트로부터 접근 가능한 객체만 mark를 한다."><br><img src="/images/jvm-gc-basic/minor-gc-10.png" alt="Survivor Space에서 생존하지 못한(mark 당하지 않은) 모든 객체를 수거해간다. (Sweep)"><br><img src="/images/jvm-gc-basic/minor-gc-11.png" alt="이 때 Survivor Space에서 생존한 객체는 generational count가 2로 증가한다."><br><img src="/images/jvm-gc-basic/minor-gc-12.png" alt="Eden Space에서 mark된(생존한) 객체는 Survivor Space로 복사된다."><br><img src="/images/jvm-gc-basic/minor-gc-13.png" alt="이 때 Eden에서 복사되는 객체는 generational count가 1로 증가한다."><br><img src="/images/jvm-gc-basic/minor-gc-14.png" alt="이제 Eden Space를 비워준다, Sweep. (Stop the World의 끝)"><br><img src="/images/jvm-gc-basic/minor-gc-15.png" alt="이제 새로운 객체를 할당하면 된다."><br><img src="/images/jvm-gc-basic/minor-gc-16.png" alt="위 과정들을 반복하다가 또 Eden Space가 꽉 차서 GC를 수행하게 됐다고 가정하자. (Stop the world의 시작)"><br><img src="/images/jvm-gc-basic/minor-gc-17.png" alt="모든 과정을 마치고 이제 Eden Space에서 생존한 객체들을 Survivor Space로 옮기려고 했더니 Survivor Space에 연속된 메모리 공간을 확보하지 못해서 더 이상 메모리 할당이 불가능하다고 가정해보자."><br><img src="/images/jvm-gc-basic/minor-gc-18.png" alt="이 때 From Survivor Space에서 생존한 모든 객체들을 To Survivor Space의 연속된 공간에 먼저 옮기고, 그 후에 Eden Space에서 생존한 객체를 To Survivor Space의 연속된 공간에 옮긴다."><br>To Survivor Space에 Eden Space에 있는 내용보다 From Survivor Space에 있는 내용을 먼저 복사하는 이유는<br>generational count가 적은 객체(Eden Space에 거주중인 객체들)보다 generational count가 높은 객체(From Survivor Space에 거주중인 객체들)의<br>수명이 더 길 가능성이 높기 때문이다. (Weak Generational 가설에 의해…)<br>수명이 더 길 가능성이 높은 메모리를 먼저 배치하는 이유는 메모리의 단편화를 줄이기 위함이다.<br><img src="/images/jvm-gc-basic/minor-gc-19.png" alt="생존한 모든 객체를 옮겼으므로 From Survivor Space와 Eden Space를 비운다."><br><img src="/images/jvm-gc-basic/minor-gc-20.png" alt="기존 From Survivor Space의 역할을 To Survivor Space가 대신하게 됐으므로 둘의 이름을 바꾼다. (Stop the World의 끝)"><br><img src="/images/jvm-gc-basic/minor-gc-21.png" alt="GC가 끝났으므로 새로운 객체를 Eden Space에 할당한다."><br><img src="/images/jvm-gc-basic/minor-gc-22.png" alt="위 과정을 반복하다가 생존을 반복한 From Survivor Space에 있는 객체가 적당히 나이를 먹었다고 가정해보자."><br><img src="/images/jvm-gc-basic/minor-gc-23.png" alt="그럼 해당 객체는 Promotion(승진)을 한다."><br><img src="/images/jvm-gc-basic/minor-gc-24.png" alt="그러다 다시 Minor GC를 해야되게 됐다."><br><img src="/images/jvm-gc-basic/minor-gc-25.png" alt="이 경우에는 흔치 않게 Old Generation에서 Young Generation을 참조하고 있어서 GC 로직이 복잡해보이는데 간단하게 카드 테이블에 저장된 객체만 추가로 검사해서 Old Generation에서 Young Generation으로 참조 중인 객체를 쉽고 빠르게 찾을 수 있다.">  </p><h4 id="Promotion"><a href="#Promotion" class="headerlink" title="Promotion"></a>Promotion</h4><p>아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다.<br><img src="/images/jvm-gc-basic/promotion-01.png" alt="Promotion(승진)은 Young Generation에서 적당히 나이를 먹어서(GC로 부터 살아남아서 계속해서 generational count가 늘어나서 적당한 generational count가 됐음을 의미)"><br><img src="/images/jvm-gc-basic/promotion-02.png" alt="이제 Old Generation으로 갈 나이가 됐으니 Old Generation으로 이동하는 걸 의미한다."><br>generational count가 어느정도 있으려면<del>(짬밥을 어느정도 먹었으려면)</del> 당연히 Survivor Space에 있는 객체가 이동됨을 의미한다.</p><p>적당한 나이는 -XX:InitialTenuringThreshold와 -XX:MaxTenuringThreshold 파라미터로 정할 수 있다.<br>(Old 영역으로 승진하는 객체의 갯수나 비율이 많아지면 자동으로 TenuringThreshold를 늘리는 원리인지 뭔지 잘 모르겠다…)    </p><h4 id="Premature-Promotion"><a href="#Premature-Promotion" class="headerlink" title="Premature Promotion"></a>Premature Promotion</h4><p>적당한 나이(TenuringThreshold)를 먹지 않았는데 어쩔 수 없이 Old Generation으로 이동하는 행위를 premature promotion(조기 승진)이라고 부른다.<br>아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다.<br><img src="/images/jvm-gc-basic/premature-promotion-01.png" alt="주로 메모리 할당이 잦다보니 Survivor Space에 적당한 공간이 없어서"><br><img src="/images/jvm-gc-basic/premature-promotion-02.png" alt="나이를 먹지 않았음에도 Old Generation으로 옮겨지는 경우도 Premature Promotion이고,"><br><img src="/images/jvm-gc-basic/premature-promotion-03.png" alt="새롭게 할당될 객체의 용량이 Eden Space의 용량보다 큰 경우에는"><br><img src="/images/jvm-gc-basic/premature-promotion-04.png" alt="바로 Old Generation에 할당되게 되는데 이 경우에도 Premature Promotion이고,"><br><img src="/images/jvm-gc-basic/premature-promotion-04.png" alt="원래 같으면 Eden Space의 내용이 From Survivor Space 영역의 바로 아래 공간에 할당되면 되는데, -XX:TargetSurvivorRatio(기본값 50)에 의해 할당되지 못하는 경우가 있다."><br>-XX:TargetSurvivorRatio는 Minor GC 이후의 From Survivor Space의 사용률(%)을 제한하는 옵션이다.<br><img src="/images/jvm-gc-basic/premature-promotion-06.png" alt="적당한 나이가 되지 않은 어린 객체가 Old Generation으로 이동하는 것도 Premature Promotion이다."></p><p>이 premature promotion의 경우에는 Old Generation에 놓기 때문에 Major GC 혹은 Full GC가 일어나기 전에는 회수해가지 않으며<br>적당한 나이를 먹지 않고 와서 단명할 가능성이 높음에도 불구하고 쓸데없이 Old Generation을 차지하고 있기 때문에<br>Major GC 혹은 Full GC의 발생 빈도를 늘려 어플리케이션 전반에 영향을 미치기 때문에 적절하게 Young Generation과 관련된 사이즈를 정하는 게 중요하다.</p><h2 id="Old-Generation"><a href="#Old-Generation" class="headerlink" title="Old Generation"></a>Old Generation</h2><p>객체가 적당한 나이를 먹거나 조기 승진을 통해 넘어온 객체들이 존재하는 영역이다.<br>Tenure Generation이라고도 부른다.<br>해당 영역에 존재하는 객체들을 Young Generation에 있는 객체들보다 회수당할 가능성이 적다는 게 Weak Generational 가설이다.<br>또한 대부분의 객체가 Young Generation에서 사망하시기 때문에 Old Generation으로 오는 객체는 Young Generation에 할당되는 객체의 비율에 비해 현저히 낮다.</p><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>Major GC 역시 Old Generation이 꽉 찼을 때 수행된다.<br>기본적으로 Old Generation은 메모리 할당률이 낮기 때문에 GC가 일어나는 빈도가 적다.<br>또한 대부분 Old Generation은 Young Generation 보다 용량을 크게 잡기 때문에 객체의 갯수도 많아서 GC 시간이 길다.<br>GC의 시간이 길다는 것은 그만큼 Stop the World, 어플리케이션이 멈추는 시간도 길다는 의미고 그런 의미에서 Major GC(주요한 GC)라고 이름을 붙인 게 아닐까 싶다.<br>또한 Old Generation은 Young Generation과 같이 Survivor Space가 존재하는 게 아니기 때문에 메모리 단편화도 신경써야하고 관리해야할 객체도 많다보니 훨씬 알고리듬이 복잡해진다.<br>이에 대해선 다음에 글을 써볼 예정이다.</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>Minor GC + Major GC를 Full GC라고 부른다.<br>정확히 언제 일어나는지 모르겠지만 Old Generation GC에 대해 좀 더 자세히 공부하고 다시 작성해야겠다.</p><h2 id="Permanent-Generation"><a href="#Permanent-Generation" class="headerlink" title="Permanent Generation"></a>Permanent Generation</h2><p>JVM의 Method Area를 Hotspot VM에서 Permanent Generation(줄여서 PermGen)으로 부르기 시작하면서 다른 VM에서도 PermGen이라고 부르는 것 같다.<br>PermGen은 자바 8에서 사라졌다.<br>PermGen에는 클래스의 메타데이터, 메서드의 메타데이터, 상수풀, static 변수 등등이 들어간다.<br>PermGen은 이름만 들어보면 Permanent(영구적인)가 들어가다보니 영구히 존재하는 데이터들만 저장될 거 같은데 필수는 아니지만 GC가 수행되기도 한다.<br>GC가 수행된다는 관점에서인지 이 영역을 힙 메모리로 보는 사람도 있는데 나는 클래스의 인스턴스가 저장되는 것도 아니고<br>-Xmx, -Xms와는 별개로 사이즈가 지정되다보니 힙메모리가 아니라고 생각하고 있다.<br>-XX:PermSize와 -XX:MaxPermSize로 사이즈를 지정할 수 있고, GC를 수행하지 않는다면 용량이 부족해질 수 있고 아래와 같은 OOME가 난다.<br><code>java.lang.OutOfMemoryError: PermGen space</code><br>이러한 에러가 나는 이유는 여러가지가 있는데 대표적으로 다음과 같다.</p><ul><li>collection을 static으로 만들고 계속해서 요소를 추가하는 경우(이런 실수를 범하면 절대 안된다.)</li><li>서버를 재시작하지 않고 변경 내역을 바로바로 반영해주는 HotDeploy를 계속해서 사용하다보면 Class와 Method의 메타데이터가 계속해서 쌓이게 되는데<br>서버를 주기적으로 재시작해주지 않고, 계속해서 HotDeploy 하는 경우(실서버에서 이런 경우는 거의 없을 것이다.)</li></ul><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>자바 8부터 PermGen의 역할을 Metadata 영역에서 맡기 시작했고 Native 영역으로 옮겨졌다. (즉 OS에서 관리한다는 의미)<br>PermGen 중에 일부만 Metadata 영역에서 맡기 시작했고, 상수풀이나 static 변수는 Heap 메모리로 옮겨져왔다.<br>즉, 개발자가 실수하기 쉽거나 변경이 잦은 내용들은 힙 메모리로 끌고와서 GC의 대상이 되게 하고, 정말 변경이 될 가능성이 적은 내용들만 Native 영역으로 옮겨버렸다.<br>문제는 Native 영역은 dump를 떠도 안 나와서 분석하기 힘들다는데 이럴 일은 아마 거의 없을 것이다…<br>Metadata에 대한 관리는 OS에서 함으로 믿고 맡겨도 된다고 생각하지만(개발자가 직접하는 것보다 낫지 않을까?),<br>혹시 이 쪽을 튜닝해야하거나 OOME(java.lang.OutOfMemoryError: Metadata space)가 발생한 경우에는 -XX:MetaspaceSize와 -XX:MaxMetaspaceSize 파라미터를 사용해보자.</p><h2 id="OutOfMemoryException"><a href="#OutOfMemoryException" class="headerlink" title="OutOfMemoryException"></a>OutOfMemoryException</h2><p>주로 OOME라고 줄여부르며 메모리 공간이 부족해서 나는 예외로 어플리케이션 자체가 뻗는 현상이 발생한다.<br>이 예외가 발생했을 때는 메모리 릭(메모리 결함)이 발생한 경우이고 Heap 메모리나 PermGen(Metaspace) 등등의 영역이 부족할 때 발생하는데<br>어떤 메모리가 부족한 건지, 아니면 왜 이 오류가 났는지 Stacktrace를 찍고 사망한다.</p><p>여기서는 힙 메모리가 부족해서 OOME가 발생한 경우의 원인에 대해서만 설명하겠다.<br>우선 메모리가 부족하면 가비지 컬렉터는 힙메모리의 가비지 컬렉션을 수행한다.<br>가비지 컬렉션을 수행했음에도 불구하고 새로운 객체를 더이상 할당할 수 없는 경우에 OOME가 발생하게 된다.<br>이 때는 아주 급한 경우에는 일단 -Xmx와 -Xms로 메모리를 늘리고 보고,<br><img src="/images/jvm-gc-basic/mat.png" alt="">  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=<span class="variable">$&#123;PATH&#125;</span>/<span class="variable">$&#123;FILE_NAME&#125;</span>.hprof</span><br></pre></td></tr></table></figure><p>위 두가지 설정을 주고 실행해서 재발하면 힙덤프를 생성하거나 아니면<br>jmap 등등으로 살아있는 서버의 힙덤프를 떠서 어디서 메모리 릭이 발생했는지 Eclipse MAT 등등으로 분석하거나</p><p><img src="/images/jvm-gc-basic/visual-vm.png" alt="">  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.port=<span class="variable">$&#123;JMX_PORT&#125;</span></span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span></span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span></span><br><span class="line">-Dcom.sun.management.jmxremote.rmi.port=<span class="variable">$&#123;RMI_PORT&#125;</span></span><br><span class="line">-Djava.rmi.server.hostname=<span class="variable">$&#123;HOST_NAME&#125;</span></span><br></pre></td></tr></table></figure><p>위 설정 등등을 줘서 VisualVM으로 서버에 실제로 떠있는 어플리케이션 등등을 모니터링하는 방법이 있다.</p><h2 id="알아두면-좋을-상식"><a href="#알아두면-좋을-상식" class="headerlink" title="알아두면 좋을 상식"></a>알아두면 좋을 상식</h2><ul><li>Hotspot VM의 GC는 Arena라는 메모리 영역에서 작동한다.</li><li>Hotspot VM은 시작 시 메모리를 유저 공간에 할당/관리한다.<br>따라서 힙 메모리를 관리할 때 시스템 콜을 하지 않으므로 커널 공간으로 컨텍스트 스위칭을 하지 않아서 성능 향상에 도움이 된다.</li><li>Hotspot VM은 할당된 메모리 가장 마지막의 다음 영역을 가리켜 연속된 빈 공간에 효율적으로 빠르게 할당하는 bump-the-pointer라는 기술을 사용했다.</li><li>Hotspot VM은 멀티 스레드 환경에서 객체를 할당할 때 스레드 간의 경합 등등의 문제를 줄이고자 TLAB(Thread Local Allocation Buffer)를 사용했다.<br>Eden Space를 여러 버퍼로 나누어 각 어플리케이션 스레드에게 할당함으로써 자기 자신이 사용해야 할 버퍼를 바로 찾게되고, 리소스를 공유해서 생기는 문제를 없애버렸다.<br>만약 본인에게 할당된 TLAB가 부족할 경우에는 크기를 동적으로 조정한다.</li></ul><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>해당 글을 읽고 <a href="/2019/05/11/jvm-gc-advanced/">Garbage Collection Advanced</a> 편을 읽어보시면 GC에 대해 더 깊게 이해하실 수 있을 겁니다 :)</p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://d2.naver.com/helloworld/1329" rel="external nofollow noopener noreferrer" target="_blank">Naver D2 - Java Garbage Collection</a>  </li><li><a href="https://d2.naver.com/helloworld/1230" rel="external nofollow noopener noreferrer" target="_blank">Naver D2 - JVM Internal</a>  </li><li><a href="https://www.youtube.com/watch?v=DoJr5QQYsl8" rel="external nofollow noopener noreferrer" target="_blank">The JVM and Java Garbage Collection - OLL Live (Recorded Webcast Event)</a>  </li><li><a href="https://starplatina.tistory.com/entry/JDK8%EC%97%90%EC%84%A0-PermGen%EC%9D%B4-%EC%99%84%EC%A0%84%ED%9E%88-%EC%82%AC%EB%9D%BC%EC%A7%80%EA%B3%A0-Metaspace%EA%B0%80-%EC%9D%B4%EB%A5%BC-%EB%8C%80%EC%8B%A0-%ED%95%A8" rel="external nofollow noopener noreferrer" target="_blank">JDK8에선 PermGen이 완전히 사라지고 Metaspace가 이를 대신 함.</a>  </li><li><a href="https://brunch.co.kr/@heracul/1" rel="external nofollow noopener noreferrer" target="_blank">JDK8 적용 후, 심각한 성능저하가 발생한다면?</a></li><li><a href="https://yckwon2nd.blogspot.com/2015/03/java8-permanent.html" rel="external nofollow noopener noreferrer" target="_blank">JAVA8 Permanent 영역은 어디로 가는가</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html" rel="external nofollow noopener noreferrer" target="_blank">Understand the OutOfMemoryError Exception - Oracle Docs</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">Sizing the Generations - Oracle Docs</a>  </li><li><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc" rel="external nofollow noopener noreferrer" target="_blank">Minor GC vs Major GC vs Full GC</a>  </li><li><a href="https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection/" rel="external nofollow noopener noreferrer" target="_blank">Useful JVM Flags – Part 5 (Young Generation Garbage Collection)</a></li><li><a href="http://www.herongyang.com/Java-GC/Serial-TargetSurvivorRatio-Second-Tenuring-Condition.html" rel="external nofollow noopener noreferrer" target="_blank">“-XX:TargetSurvivorRatio” - Second Tenuring Condition</a>  </li></ul><p>그 외 더 많은 거 같은데 기억이 잘 나지 않는다…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jvm-gc-basic/thumb.png&quot; alt=&quot;PermGen은 자바 8에서 Metaspcae로 대체됐다. 이미지 출처: https://help.sap.com/&quot;&gt;  &lt;/p&gt;&lt;h2 id=&quot;읽기-전-주의사항-그림을-보는-법&quot;&gt;&lt;a href=&quot;#읽기-전-주의사항-그림을-보는-법&quot; class=&quot;headerlink&quot; title=&quot;읽기 전 주의사항(그림을 보는 법)&quot;&gt;&lt;/a&gt;읽기 전 주의사항(그림을 보는 법)&lt;/h2&gt;&lt;p&gt;그림을 그리다보니 Stack에 있는 동그라미 모양과 힙 메모리에 있는 동그라미 모양이 동일한 그림들이 많이 있습니다.&lt;br&gt;이건 &lt;strong&gt;둘이 동일한 메모리를 의미하는 게 아니라 그냥 스택에서 힙을 참조&lt;/strong&gt;한다는 걸 그린 건데,&lt;br&gt;사실 둘의 모양을 다르게 그려야하는데 아무 생각없이 복붙해서 그리다보니 이렇게 그리게 되었고…&lt;br&gt;되돌리기에는 너무 많이 그림을 그려놔서(히스토리 추적이 안 되게 막 그려서…) 귀챠니즘으로 인해 그림을 수정하지 않았습니다.&lt;br&gt;이 점 참고하셔서 보시길 바랍니다!&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://perfectacle.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>(삽질기) SSH 터널링을 통해 원격지에 존재하는 도커 컨테이너 안의 JMX 모니터링하기</title>
    <link href="https://perfectacle.github.io/2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/"/>
    <id>https://perfectacle.github.io/2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/</id>
    <published>2019-05-04T23:36:13.000Z</published>
    <updated>2019-08-23T02:31:34.166Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/thumb.png" alt="네가 알던 로컬호스트가 아냐! (로컬호스트처럼 보이지만 실제론 원격지에 있는 서버에 붙었음을 의미)"></p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>JMX를 모니터링 하려면 <a href="https://visualvm.github.io/" rel="external nofollow noopener noreferrer" target="_blank">VisualVM</a>이나 JDK에 기본적으로 내장돼있는 <a href="http://openjdk.java.net/tools/svc/jconsole/" rel="external nofollow noopener noreferrer" target="_blank">JConsole</a>을 사용해야한다.</p><h2 id="로컬에서-JMX-모니터링하기"><a href="#로컬에서-JMX-모니터링하기" class="headerlink" title="로컬에서 JMX 모니터링하기"></a>로컬에서 JMX 모니터링하기</h2><p>우선 로컬에 어플리케이션을 띄우고 JMX 모니터링하기란 참 쉽다.<br>우선 자바 어플리케이션을 띄워보자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar air.jar</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/01.png" alt="그리고 모니터링 툴을 보면 바로 해당 어플리케이션이 잡혀있다."></p><h2 id="도커-컨테이너-안의-JMX-모니터링-하기"><a href="#도커-컨테이너-안의-JMX-모니터링-하기" class="headerlink" title="도커 컨테이너 안의 JMX 모니터링 하기"></a>도커 컨테이너 안의 JMX 모니터링 하기</h2><p>우선 도커 이미지 파일부터 만들어야한다.  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jdk-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY build/libs/air.jar .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD (java \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.port=9090 \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.rmi.port=9090 \</span></span><br><span class="line"><span class="bash">          -Djava.rmi.server.hostname=localhost \</span></span><br><span class="line"><span class="bash">          -jar air.jar)</span></span><br></pre></td></tr></table></figure><p>jmxremote.port와 jmxremote.rmi.port를 달리 해도 되는데 그럼 docker container의 port 2개를 host os port 2개랑 바인딩해야한다.<br>그냥 둘을 하나로 통일하면 하나만 바인딩하면 되기 때문에 굳이 두 개로 해야할 필요성을 느끼진 못했다.<br>java.rmi.server.hostname에 로컬의 사설 IP(private ip)를 넣어도 되는데 굳이 귀찮게 그렇게 할 필요성도 느끼지 못했다.<br>또한 SSH Tunneling을 거치게 됐을 때 서버의 사설 IP를 적었을 때는 접속이 불가능했으므로 <strong>무조건 localhost라고 적어주자.</strong> </p><p>해당 이미지를 빌드하고 이제 이미지를 container로 띄워보자.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JMX를 모니터링 하는 것이기 때문에 어플리케이션의 포트는 바인딩하지 않았다.</span></span><br><span class="line"><span class="comment"># JMX remote port(9090)와 다른 포트를 Host OS에 매핑하면 모니터링이 불가능하다.</span></span><br><span class="line"><span class="comment"># 9091:9090 이렇게 하면 못 붙는다 무조건 9090:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.</span></span><br><span class="line"><span class="comment"># 혹시 jmx remote port와 jmx remote rmi port를 다르게 했다면 두 포트를 모두 바인딩 시켜줘야한다.</span></span><br><span class="line"><span class="comment"># jmx remote port가 9090이고 jmx remote rmi port가 9091이라면 -p 9090:9090 -p 9091:9091 이렇게 해줘야한다.</span></span><br><span class="line">docker run -p 9090:9090 air</span><br></pre></td></tr></table></figure><p>Host OS에 자바 어플리케이션이 뜬 게 아니라 컨테이너 안에서 뜬 거고, HostOS는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다.<br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/02.png" alt="좌측 상단의 해당 버튼을 클릭해주자."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/03.png" alt="localhost와 jmx remote port를 입력해주고 적당히 보기 쉬운 이름으로 Display name에 채워주고 스크린샷을 따라서 작성한 후에 OK 버튼을 눌러주자."><br>만약 jmx remote port와 jmx remote rmi port를 다르게 했더라도 입력하는 포트는 jmx remote port를 입력해줘야한다.<br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/04.png" alt="성공적으로 불러와졌다."><br>아쉽지만 도커 컨테이너로 띄우게 되면 쓰레드 덤프는 떠지지만 힙 덤프는 안 떠진다.<br><strong>혹시 도커 컨테이너로 띄웠을 때도 힙 덤프를 뜨게 하려면 어떻게 해야하는지 댓글에 남겨주시면 정말 감사하겠습니다.</strong></p><h2 id="SSH-Tunneling을-통해-원격지의-JMX-모니터링하기"><a href="#SSH-Tunneling을-통해-원격지의-JMX-모니터링하기" class="headerlink" title="SSH Tunneling을 통해 원격지의 JMX 모니터링하기"></a>SSH Tunneling을 통해 원격지의 JMX 모니터링하기</h2><p>서버를 퍼블릭 존에 두는 건 매우 위험하다. (크래커가 직접 SSH로 붙을 가능성이 존재하거나 각종 공격에 직접적으로 노출되기 때문에…)<br>따라서 프라이빗 존에 둬야하는데 VPN을 쓸 경제적 여력이 안 되는 가난한 환경이나 VPN을 적용하지 않은 환경에서는 매우 귀찮아진다.<br><del>(우리 회사가 가난하다는 게 아니다.)</del><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/aws-bastion-host.png" alt="따라서 퍼블릭 존에 Bastion Host를 두고 해당 Host를 경유해 프라이빗 존에 있는 서버에 접근하게 된다."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/aws-ssh-local-port-forwading.png" alt="이런 환경에서는 Bastion Host를 거쳐 SSH Tunneling의 일종인 Local Port Forwading을 해야한다."><br>기본적인 명령어는 위 사진에서 보는 바와 같고 명령어의 예시를 들어보겠다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JMX remote port(9090)와 다른 포트를 Localhost에 매핑하면 모니터링이 불가능하다.</span></span><br><span class="line"><span class="comment"># 9091:$&#123;application_server_ip&#125;:9090 이렇게 하면 못 붙는다.</span></span><br><span class="line"><span class="comment"># 무조건 9090:$&#123;application_server_ip&#125;:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.</span></span><br><span class="line">ssh -N -L 9090:<span class="variable">$&#123;application_server_ip&#125;</span>:9090 -i ~/.ssh/key.pem ec2-user@&#123;bastion_host_ip&#125;</span><br></pre></td></tr></table></figure><p>이번에도 역시 Host OS에 자바 어플리케이션이 뜬 게 아니라 원격지의 도커 컨테이너 안에서 뜬 거고, Localhost에는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다.<br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/02.png" alt="좌측 상단의 해당 버튼을 클릭해주자."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/05.png" alt="localhost와 jmx remote port를 입력해주고 적당히 보기 쉬운 이름으로 Display name에 채워주고 스크린샷을 따라서 작성한 후에 OK 버튼을 눌러주자."><br><img src="/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/06.png" alt="정상적으로 접속됐다."></p><p>JMX remote port(9090)와 다른 포트를 매핑하는 바람에 몇 시간을 삽질했는지 모르겠다…<br><strong>혹시 이거보다 더 간단하게 연결하는 방법이 있다면 댓글로 남겨주시면 정말 감사하겠습니다.</strong></p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://stackoverflow.com/questions/1609961/visualvm-over-ssh" rel="external nofollow noopener noreferrer" target="_blank">VisualVM over ssh</a>  </li><li><a href="https://www.popit.kr/docker-jmx-profiling-tip/" rel="external nofollow noopener noreferrer" target="_blank">Docker 안에 숨어 있는 Web application JMX profiling Tip</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jmx-monitoring-inside-docker-container-over-ssh-tunneling/thumb.png&quot; alt=&quot;네가 알던 로컬호스트가 아냐! (로컬호스트처럼 보이지만 실제론 원격지에 있는 서버에 붙었음을 의미)&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;JMX를 모니터링 하려면 &lt;a href=&quot;https://visualvm.github.io/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;VisualVM&lt;/a&gt;이나 JDK에 기본적으로 내장돼있는 &lt;a href=&quot;http://openjdk.java.net/tools/svc/jconsole/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;JConsole&lt;/a&gt;을 사용해야한다.&lt;/p&gt;&lt;h2 id=&quot;로컬에서-JMX-모니터링하기&quot;&gt;&lt;a href=&quot;#로컬에서-JMX-모니터링하기&quot; class=&quot;headerlink&quot; title=&quot;로컬에서 JMX 모니터링하기&quot;&gt;&lt;/a&gt;로컬에서 JMX 모니터링하기&lt;/h2&gt;&lt;p&gt;우선 로컬에 어플리케이션을 띄우고 JMX 모니터링하기란 참 쉽다.&lt;br&gt;우선 자바 어플리케이션을 띄워보자.  &lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -jar air.jar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="JMX" scheme="https://perfectacle.github.io/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) Hibernate MultipleBagFetchException 정복하기</title>
    <link href="https://perfectacle.github.io/2019/05/01/hibernate-multiple-bag-fetch-exception/"/>
    <id>https://perfectacle.github.io/2019/05/01/hibernate-multiple-bag-fetch-exception/</id>
    <published>2019-05-01T11:04:41.000Z</published>
    <updated>2019-08-22T04:55:48.521Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hibernate-multiple-bag-fetch-exception/thumb.jpg" alt="이미지 출처: https://pgr21.com/pb/pb.php?id=humor&amp;no=166185"></p><h2 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h2><p>Spring Data JPA를 이용하다보면 종종 <code>org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags</code>이란 메세지를 보게 된다.<br>우선 어떤 상황에 나타나는지 한 번 살펴보자.  </p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Daughter&gt; daughters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Son&gt; sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> List&lt;Daughter&gt; daughters, <span class="keyword">final</span> List&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> List&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> List&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엄마가 있고, 아들/딸들이 있는데 아들/딸들을 EAGER로 fetch해 올 때 발생한다.<br><strong>(즉, OneToMany, ManyToMany인 Bag 두 개 이상을 EAGER로 fetch할 때 발생한다.)</strong><br>EAGER로 땡겨오면 N+1 쿼리 문제가 존재하기 때문에 fetchType을 전부 LAZY로 바꾼 후 한 방 쿼리로 불러와도 문제는 재발한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MotherRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Mother</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@EntityGraph</span>(attributePaths = &#123;<span class="string">"daughters"</span>, <span class="string">"sons"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;Mother&gt; <span class="title">findAllWithChildrenBy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bag"><a href="#Bag" class="headerlink" title="Bag"></a>Bag</h2><p>우선 MultipleBagFetchException 파일을 둘러보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exception used to indicate that a query is attempting to simultaneously fetch multiple</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.hibernate.type.BagType bags&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>여러 BagType을 동시에 fetch 해 올 때 발생하는 예외라고 한다.<br>그럼 Bag이 뭘까…?  </p><blockquote><p>A generalization of the notion of a set is that of a multiset or bag, which is similar to a set but allows repeated (“equal”) values (duplicates).<br>  <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</a></p></blockquote><blockquote><p>A Bag is a java collection that stores elements without caring about the sequencing, but allow duplicate elements in the list.<br>  A bag is a random grouping of the objects in the list.<br>  <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</a></p></blockquote><blockquote><p>A <bag> is an unordered collection, which can contain duplicated elements.<br>  That means if you persist a bag with some order of elements, you cannot expect the same order retains when the collection is retrieved.<br>  There is not a “bag” concept in Java collections framework, so we just use a java.util.List corresponds to a <bag>.<br>  <a href="https://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate</a></bag></bag></p></blockquote><p>즉, Bag(Multiset)은 Set과 같이 순서가 없고, List와 같이 중복을 허용하는 자료구조이다.<br>하지만 자바 컬렉션 프레임워크에서는 Bag이 없기 때문에 하이버네이트에서는 List를 Bag으로써 사용하고 있는 것이다.</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>우선 두 Bag을 Set으로 바꾸면 우리가 원하는대로 한 방 쿼리로 날아간다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Daughter&gt; daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Son&gt; sons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Set&lt;Daughter&gt; daughters, <span class="keyword">final</span> Set&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> Set&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> Set&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실무에서 급하면 딱 이 수준까지만 하면 끝이고 이제 왜 Multiple Bag을 Fetch해 올 수 없는지 알아보자.  </p><p>우선 두 Bag 중 하나만 Set으로 바꾼 후 결과를 보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Daughter&gt; daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Son&gt; sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Set&lt;Daughter&gt; daughters, <span class="keyword">final</span> List&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> Set&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> List&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 MotherRepository#findAllWithChildrenBy() 메서드를 통해 호출하면 아래와 같은 결과를 볼 수 있다.<br>일단 날아간 쿼리는 아래와 같다. (혹시나 join 했을 때 자식들이 없을까봐 엄마라도 불러오려고 기본적으로 outer join을 하고 있다.)  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    mother0_.id <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">    daughters1_.id <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">    sons2_.id <span class="keyword">as</span> id1_2_2_,</span><br><span class="line">    daughters1_.mother_id <span class="keyword">as</span> mother_i2_0_1_,</span><br><span class="line">    daughters1_.mother_id <span class="keyword">as</span> mother_i2_0_0__,</span><br><span class="line">    daughters1_.id <span class="keyword">as</span> id1_0_0__,</span><br><span class="line">    sons2_.mother_id <span class="keyword">as</span> mother_i2_2_2_,</span><br><span class="line">    sons2_.mother_id <span class="keyword">as</span> mother_i2_2_1__,</span><br><span class="line">    sons2_.id <span class="keyword">as</span> id1_2_1__ </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    mother mother0_ </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">    daughter daughters1_ </span><br><span class="line">        <span class="keyword">on</span> mother0_.id=daughters1_.mother_id </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">    son sons2_ </span><br><span class="line">        <span class="keyword">on</span> mother0_.id=sons2_.mother_id</span><br></pre></td></tr></table></figure><p><img src="/images/hibernate-multiple-bag-fetch-exception/01.png" alt="주목할 부분은 파란색으로 쳐놓은 부분이다."><br>Set으로 저장한 딸들은 중복없이 잘 불러와졌고, List(Bag)로 저장한 아들들은 중복있이 잘 불러와졌다.<br>(List라고 무조건 중복이 발생하는 건 아니다. 단일 List(Bag)만 Fetch 해오면 중복없이 잘 불러온다.)  </p><p>이 결과를 Row로 표시해보자면 다음과 같다.  </p><table><thead><tr><th>mother.id</th><th>daughter.id</th><th>son.id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td></tr><tr><td>1</td><td>1</td><td>3</td></tr><tr><td>1</td><td>2</td><td>1</td></tr><tr><td>1</td><td>2</td><td>2</td></tr><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>3</td><td>1</td></tr><tr><td>1</td><td>3</td><td>2</td></tr><tr><td>1</td><td>3</td><td>3</td></tr></tbody></table><p>만약 daughters 마저도 중복도 보장이 안 되고, 순서도 보장이 안 됐다면 어떤 기준을 가지고 Row를 매핑할 수 있을까?<br>(뭐, 물론 이 경우에는 될 수도 있겠지만 좀 더 엔터티의 관계가 복잡한 경우에는 매핑이 불가능하거나 너무 복잡해지는 거 아닐까?)<br>그렇기 때문에 Multiple Bag은 Fetch가 안 되는 게 아닐까 싶다.</p><p>실제로 List로 저장한 데이터를 하이버네이트에서는 BagType으로 취급하고 있고, Set으로 저장한 데이터는 SetType으로 취급하고 있다.<br>ListType 클래스도 있긴 한데 언제 어떻게 써야하는지는 잘 모르겠다 ㅠㅠ…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hibernate-multiple-bag-fetch-exception/thumb.jpg&quot; alt=&quot;이미지 출처: https://pgr21.com/pb/pb.php?id=humor&amp;amp;no=166185&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;Trouble&quot;&gt;&lt;a href=&quot;#Trouble&quot; class=&quot;headerlink&quot; title=&quot;Trouble&quot;&gt;&lt;/a&gt;Trouble&lt;/h2&gt;&lt;p&gt;Spring Data JPA를 이용하다보면 종종 &lt;code&gt;org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags&lt;/code&gt;이란 메세지를 보게 된다.&lt;br&gt;우선 어떤 상황에 나타나는지 한 번 살펴보자.  &lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="Hibernate" scheme="https://perfectacle.github.io/tags/Hibernate/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://perfectacle.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>(삽질기) Spring Data JPA에서 Entity Manager 관련 삽질기</title>
    <link href="https://perfectacle.github.io/2019/05/01/jpa-entity-manager-with-test/"/>
    <id>https://perfectacle.github.io/2019/05/01/jpa-entity-manager-with-test/</id>
    <published>2019-05-01T08:26:48.000Z</published>
    <updated>2019-08-22T05:15:57.041Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jpa-entity-manager-with-test/thumb.png" alt="이미지 출처: http://bemil.chosun.com/nbrd/bbs/view.html?b_bbs_id=10044&amp;pn=0&amp;num=128739"></p><p>오랜만에 Spring Data JPA를 가지고 뭔가 뻘뻘 대보고 있었다.<br>하지만 내 의도대로 동작하지 않았다.<br>아래 코드를 보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SomeEntityRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.save(<span class="keyword">new</span> SomeEntity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>우선 테스트를 돌릴 때마다 DB를 초기화했다. (인메모리 DB인 H2를 사용했다.)<br>따라서 테스트 할 데이터를 setup 메서드를 통해 데이터를 DB에 밀어넣고 있었다.<br>그리고 테스트 케이스에서 해당 엔터티를 불러오는 간단한 코드인데 나는 select 쿼리가 날아갈 줄 알았다.<br>하지만 insert 쿼리만 날아가고, 이거 가지고 코드를 이리저리 바꿔보며 온갖 삽질을 한 것 같다.  </p><p>왜 select 쿼리가 찍히지 않을까… 한 2시간 가까이를 이거 때문에 계속 삽질하고 있었다.<br>그리고 스프링 관련 커뮤니티에 질문하려고 <code>아마 SomeEntity 엔터티가 생성되면서 ID 값이 어딘가에 저장돼서 동일한...</code>까지 딱 치고 있는데<br><strong>어딘가 저장</strong>에 딱 꽂혀서 아! 맞다! 하고 그동안 JPA를 안 쓴 지 오래돼서 까먹었구나… 하고 한참동안 너무 허무했었다.  </p><p>답은 JPA의 동작 방식에 있었다.<br>기본적으로 JPA는 select 쿼리를 DB에 날리기 전에 엔터티 매니저를 뒤짐으로써 성능을 향상시킨다.<br>바로 save 메서드 당시에 엔터티 매니저에 해당 엔터티를 저장한 것이다.<br>엔터티 매니저에 없는 다른 ID를 조회하거나 @Id 어노테이션이 붙지 않은 다른 필드를 조건에 줄 경우에는 실제로 select 쿼리가 날아갔다.</p><p>그럼 setup 메서드와 test 메서드에서 사용하는 엔터티 매니저가 동일하다는 것을 어떻게 알 수 있을까?<br>기본적으로 엔터티 매니저는 thread safe하지 않아서 thread 별로 한 개의 엔터티 매니저 생성을 권장하는 것으로 알고 있다.<br>따라서 Spring Data JPA에서도 그렇게 하지 않았을까…?  </p><p>아래 테스트 코드를 통해 내가 생각한 가설이 맞는 거 같다. (멀티 스레드 환경에서 돌려본 건 아니긴 하지만…)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SomeEntityRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SomeEntity entity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        entity = <span class="keyword">new</span> SomeEntity();</span><br><span class="line">        </span><br><span class="line">        assertFalse(em.contains(entity));</span><br><span class="line"></span><br><span class="line">        repository.save(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(Long.valueOf(<span class="number">1L</span>), entity.getId());</span><br><span class="line">        assertTrue(em.contains(entity));</span><br><span class="line"></span><br><span class="line">        repository.findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본에 충실해야겠다 ㅠㅠ…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jpa-entity-manager-with-test/thumb.png&quot; alt=&quot;이미지 출처: http://bemil.chosun.com/nbrd/bbs/view.html?b_bbs_id=10044&amp;amp;pn=0&amp;amp;num=128739&quot;&gt;&lt;/p&gt;&lt;p&gt;오랜만에 Spring Data JPA를 가지고 뭔가 뻘뻘 대보고 있었다.&lt;br&gt;하지만 내 의도대로 동작하지 않았다.&lt;br&gt;아래 코드를 보자.  &lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@RunWith&lt;/span&gt;(SpringRunner.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@DataJpaTest&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MotherTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SomeEntityRepository repository;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Before&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        repository.save(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SomeEntity());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        repository.findById(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
      <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
  </entry>
  
</feed>
